[{"title":"Shell 脚本笔记","date":"2022-08-27","updated":"2022-08-29","path":"2022082758002/","text":"字符串定义字符串 string=&quot;abcdef&quot; 截取字符串 - 根据索引和长度 # 从左往右 $&#123;string:start:length&#125; # 例如 $&#123;string:2:2&#125; # 结果为&quot;cd&quot; # 省略长度则截取到字符串末尾 $&#123;string:2&#125; # 结果为&quot;cdef&quot; # 从右往左 $&#123;string:0-start:length&#125; # 例如 $&#123;string:0-2&#125; # 结果为&quot;ef&quot; 截取字符串 - 根据子字符串 # 使用&quot;#&quot;截取指定子字符串右侧的所有字符 $&#123;string#*chars&#125; # 例如 $&#123;string#*cd&#125; # 结果为&quot;ef&quot;，&quot;*&quot;为通配符 # 使用&quot;%&quot;截取指定子字符串左侧的所有字符 $&#123;string%chars*&#125; # 例如 $&#123;string%cd*&#125; # 结果为&quot;ab&quot;，&quot;*&quot;为通配符 拼接字符串 str1=&quot;abc&quot; str2=&quot;def&quot; str=$&#123;str1&#125;$&#123;str2&#125; # 结果为&quot;abcdef&quot; str1=$&#123;str1&#125;$&#123;str2&#125; # 追加，结果为&quot;abcdef&quot; 数组定义数组很简单，总之就是圆括号括起来，元素之间用空格或者换行间隔就行。需要注意 shell 脚本中赋值符号”=“前后不能加空格。 list=(item1 item2 ... item3) 获取指定元素 $&#123;list[index]&#125; 添加元素 # 在列表list索引3的位置插入或覆盖为字符串&quot;abc&quot; list[3]=&quot;abc&quot; 获取数组长度 $&#123;#list[@]&#125; $&#123;#list[*]&#125; 获取数组所有元素 $&#123;list[@]&#125; $&#123;list[*]&#125; 循环带索引的循环 # 格式一 for var in item1 item2 ... itemN do command1 command2 ... commandN done # 格式二 for var in item1 item2 ... itemN; do command1 command2 ... commandN done 实际编写脚本的时候，一般都不会把所有的遍历的情况都列出来，所以更多的场景我们需要自动的遍历一个数组。 遍历数组中所有元素 for var in $&#123;list[@]&#125;; do echo $&#123;var&#125; done 用索引遍历数组所有元素 for i in &quot;$&#123;!list[@]&#125;&quot;; do echo $&#123;list[i]&#125; done 无限循环 while true; do command1 command2 ... commandN done 带次数的无限循环 index=1 while true; do command1 command2 ... commandN index=$((index + 1)) done 将命令后台运行此前我也纠结过nohup和&amp;都有什么作用，但后来发现其实基本需要这种操作的大部分场景都得两者搭配使用。 nohup command &amp; 按行读文件while read line; do echo $&#123;line&#125; done &lt; file 将字符串作为命令执行总之就是 eval 命令，后面跟要执行的命令的字符串就行。 eval command_string","categories":[],"tags":[{"name":"shell","slug":"shell","permalink":"https://mxy493.xyz/tags/shell/"}]},{"title":"python subprocess 子进程多次读写","date":"2022-03-23","updated":"2022-03-23","path":"2022032325189/","text":"subprocess 子进程多次写入命令示例： p = subprocess.Popen(&#x27;bluetoothctl&#x27;, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) p.stdin.write(&#x27;power on\\n&#x27;.encode(&#x27;utf-8&#x27;)) # 需要加换行符表示输入结束 p.stdin.flush() # 刷新缓冲区才会立即执行写入的命令 p.stdin.write(&#x27;scan on\\n&#x27;.encode(&#x27;utf-8&#x27;)) p.stdin.flush() # 如果没有手动刷新，则会在调用communicate()时刷新将多条命令一起写入并执行 sleep(5) # 如果没有手动刷新缓冲区，该延时前后通过stdin写入的命令都还没有执行 p.stdin.write(&#x27;scan off\\n&#x27;.encode(&#x27;utf-8&#x27;)) p.stdin.flush() p.stdin.write(&#x27;exit&#x27;.encode(&#x27;utf-8&#x27;)) p.stdin.flush() stdout_data, stderr_data = p.communicate() 简单总结下： 调用 subprocess.Popen() 后命令就已经开始执行了； 需要将 stdin 和 stdout 设为 subprocess.PIPE 才能通过 stdin 和 stdout 继续读写； 写入命令使用 p.stdin.write()，注意写入的是字节流还是文本； 写入的命令需要带 \\n 换行符，否则命令不会执行； 通过 write() 写入命令后如果需要命令立即执行，需要手动调用 flush() 刷新缓冲区； 读取输出可以使用 read()、readline() 或 readlines()。 需要特别注意，使用这种方式读取输出的内容，当管道中没有更多内容的时候，函数会阻塞直到读到新的输出： p.stdout.read() p.stdout.readline() p.stdout.readlines()","categories":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"}]},{"title":"2020这一年找工作的经历","date":"2021-07-05","updated":"2022-03-23","path":"2021070552935/","text":"序言2020年确实是极不平凡的一年，突如其来的新冠疫情让绝大多数的中国人不得不在家度过2020的上半年，而这半年是我大三的下学期。 我大概是在大三上期的时候决定了要找工作，所以后面就一心在为找工作做准备，其实并没有特意去做什么，更多的是做好了这样的打算吧。 先简单描述一下这一年我找工作的经历。首先是上半年由于疫情原因在家上网课，一边复习，一边投简历找实习，期间放弃了一两个不那么理想的实习岗位，到7月初终于找到了一份并不算完美但值得一去的实习工作。接着便是五个月的实习经历，到八九月份秋招，又一边实习一边投简历找正式工作，直到最终尘埃落定，算下来我应该是拿了三份offer，其中一份是来自实习公司的留用，我认为这是对我几个月实习工作的最大肯定，而最终我选择去的公司正是我梦寐以求的小米，毕竟做了五年的米粉了吧！ 关于我找工作的经历，并不是说多么典型，或者说我自己也并不完全清楚别的同学都是什么情况，但总的来说我认为我的经历还是非常有参考意义的。 一些概念春招：春季校园招聘。集中在3月到7月，一些公司的春招会开始的更早，主要是大三下期的同学找实习岗位，以及上一年秋招没找好正式工作的同学继续找毕业后的正式工作（你不会希望是其中之一）。 秋招：秋季校园招聘。集中在8月到12月，主要是找毕业后的正式工作。 HR：人力资源，“Human Resource”的英语缩写，一般就是指负责招聘工作的人。 SP：就是Special，指特别的offer。 SSP：Super Special，更牛皮一些的，高薪的象征。 五险一金： 养老、医疗、失业、工伤、生育和住房公积金，不同公司缴纳标准不一样。住房公积金通常可以提取部分用于租房。 时间线1）大三下期春招（3月到7月）：复习的同时投简历找实习工作 2）暑假以及大四上期（到春节前）：什么时候找到实习，也就什么时候开始实习，如果没有其他事情可以一直实习到春节前。 3）大四上期秋招（8月到12月）：实习的同时找毕业后的正式工作。 4）大四下期（2月到6月）：理想情况下已经找好毕业后的正式工作，仍然可以实习大概两个月的时间，如果是找好的正式工作去提前实习可以这么搞，否则再实习就不是很必要了，这学期主要需要做的事情是做毕业设计，或者没有找好工作的同学需要继续找工作。 5）4月到5月：这两个月会比较集中的用于完成毕业设计，顺利毕业是头等大事！ 首先是对于找工作还是考研这个问题，越早想清楚越好，最晚到大三上期也该做好决定了，有了明确的方向，才好朝着这个方向前进。 我相信大部分大学生对于大学的一些时间段是没有明确认知的，包括最开始的我，可能最初的想法就是大学就像高中一样安心上课，毕业之后才找工作。事实是，大部分学校都会将最后一年留作找工作或是准备考研，所以别想着时间充足，即便学校没有明确表示所有课程要在前三年修读玩，自己也要尽可能这么去做，尤其是对于要找工作的同学。如果大四了还有课程没有修读完，想想哪来的时间去实习？虽然实习不必要，但我百分百确定地说，实习经历是很有用的！ 实习在时间上来说基本集中在每年的暑假，也就是说很多公司都会在暑假之前开始招聘实习生，到暑假七八月份的时候就可以入职实习了。以我的经历来说，我三四月份就开始投简历找实习，最终找到的实习工作七月中旬入职。当然这不是绝对的，后面的几个月仍然是可以找到实习岗位的，但我觉得那是留给没有找到合适实习岗位的同学的，所以最好别抱着这样的想法去找实习。还有就是可以这么算一下，很多公司都希望实习生能至少工作三个月以上，而很多同学也都会在春节前离职，所以想想也知道到十月份以后基本就不用想太多实习的事了。 不管是找实习还是找正式工作，都要趁早，我知道很多同学都会觉得自己还没有准备好，我自己也是这么过来的，确实会有这样的想法，一方面没准备好是事实，另一方面绝大多数同学也是第一次投简历、第一次笔试、第一次面试，往往还会经历第一次收到“感谢信”……但始终要明白，那些公司不可能等你做好了万全准备再来招聘，准备工作要提前做，都到了春招秋招的时候就别犹豫了，投了简历至少有个机会，说不定仅仅是因为你先投了简历就恰好被录用了。春招大概从3月开始以及秋招大概8月开始，就要开始投简历，一边投简历一边复习。 这一年剩下的时间都留给实习，期间甚至可以换一份实习，理想的情况下第一份实习工作7月入职，实习三个月10月结束，时间上确实是可以换一份实习工作实习到春节前的，但大多数情况下都不会遇上这种情况。 八九月的时候秋招，这时候应该正在实习中，工作的同时一定要关注秋招动态，继续找正式工作，除非你有决心和十足的把握要留在实习的公司。 总之后续一切以找到合适的正式工作为目的，应届生找工作相对机会多得多，只要自身能力不是太差，同时再稍微多努力一点，秋招找好工作并不是多么困难。 大四下期以顺利毕业为核心，通常至少需要花两个月以上的时间做毕业设计，主要集中在四五月份，六月毕业要处理一些毕业相关的杂事。其它时间根据个人情况安排即可，无非是实习或者找正式工作。 怎么做准备？自身硬实力永远是找到工作和找到好工作的前提，所以怎么做准备的核心就是怎么提升自身能力？ 首先是准备工作要融入到前期的学习中，大一大二的时候很多同学不清楚自己要做什么也不知道该怎么做，我觉得倒也不用过于担心，不过没有人会嫌自己准备的太早了是吧？所以尽早的去了解和学习一些对工作有帮助的东西，比如学校一定不会教的git，但几乎所有公司都会用到；比如Python语言的岗位并不多，但几乎所有公司都希望你会Python。 本科生找工作大多还是以编程语言为主，所以认准一门编程语言去深入学习，C++或Java是主流，更普遍的情况下是推荐学习主流语言的，同时学一下Python的有必要的，并不难，学了甚至有点上头😂 然后是大学一般会学到的几门课：数据结构、计算机组成原理、操作系统、Linux、数据库。这几门学科除了数据库对于找工作比较有针对性，其他几门学科可以说是房子的地基，面试的时候基本也是问这些基础知识，难度不会太大，只不过涉及的面会比较广。 前面已经说到本科生找工作通常还是以编程语言为主，像算法、深度学习一类的岗位要求会更高一下，但掌握一些简单的算法仍然是很必要的，比如说排序算法、递归算法就是笔试的大概率事件。强烈建议去Leetcode和牛客网刷题，笔试基本就是靠算法，难题一般都是动态规划，总而言之没什么捷径，多学多刷多练就是了，别让自己笔试就挂掉。 在哪里找工作？首先大家要明确一下，“校园招聘”并不仅仅是企业到学校里面去办的线下招聘会，其实是泛指了针对学生群体的招聘，可以去很多公司的招聘网站看看，都会有校园招聘和社会招聘两大类，简言之就是校园招聘门槛会更低一些。 然后这个问题比较简单，主推各大公司的招聘官网和招聘微信公众号，投简历前建议去牛客网或其它地方找找有没有这个公司的内推码。 然后是各大招聘平台，个人对BOSS直聘、拉勾和智联招聘比较看好。BOSS直聘的用户群体比较大，的的确确是很多岗位都会发布在上面，并且能直接和公司相关负责人联系，总而言之就是有效信息更多，使用也更方便；拉勾上互连网岗位比较多，但怎么说呢，我觉得它有的BOSS直聘也都有，更多是将它作为对BOSS直聘的一个补充；智联招聘就比较花哨了，一方面很多公司的招聘官网就是智联定制的，比如OPPO，另一方面智联上会有很多线上校园招聘会，感觉机会会更大一些，但大多都是小公司。 最后才是企业到学校办的线下招聘会，将它放到最后是因为能到学校办招聘会的大公司并不多，小公司占多数。不过不同的学校也不一样，大公司会去好的学校办招聘会，如果你的学校恰好是这样，那应该将它放在首位，有一说一这样的招聘会成功率会高得多。 关于内推内推大家基本都知道，就是公司内部员工推荐，内推的简历通常可以免简历筛选或者免笔试直接进入面试环节。但另一方面，现在内推太普遍了，你使用的内推码但你连内推人都不认识，到面试环节该挂还得挂。 总的来说，内推码有的话还是填上，大公司基本都有内推，去牛客网很容易找到，能免简历筛选、免笔试也是好事。 更靠谱的内推，其实是你和某个内部人员真的认识，或者说同学校的学长学姐吧，让他给你看看简历啥的，最好是部门直推，也就是直接把你推荐到他所在的部门，这种情况下能不能通过通常就看该部门领导了，但由于你和内推人认识，他去给领导推荐一下效果显然是好很多的。当然这种情况太难遇到了。 关于简历简历一定是重点，务必要认真对待，毕竟看你简历的人对你一点都不了解，他需要从你的简历中了解到你有什么样的能力，有什么闪光点，也可能从中发现你的缺陷。所以做简历就是要凸显自己的优势，规避自己的劣势，让对方尽可能多的看到你对公司有价值的地方。 简历制作最常见的方式是Word文档，虽然可以，但其实我并不太推荐，我自认为Word的排版是极不方便的。也有很多人推荐像超级简历一列的简历制作网站，只需要填写内容就行，排版会自动完成，确实方便。 以上的两种方式我都是用过的，总的来说我并不是很满意，事实上有更专业的排版工具，比如微软的Publisher和Adobe公司的InDesign，这种工具是可以用来制作海报报刊一类东西的，也就是说你可以发挥自己的想象力，喜欢怎么排就可以怎么排，当然难度会大一些，付出的学习成本我认为是值得的。确实是有难度，我推荐这种方式，但也不是说别的方法制作的简历就不好，毕竟都只是工具。 简历的排版尽量避免花里胡哨，我自认为最简单的黑白配色就很简约大方，黑色用墨黑色个人觉得更雅致一些，纯黑色有点黑乎乎一片的感觉。配色别超过三种颜色，总之内容才是核心，别搞得花里胡哨的，越是简洁大方才越是让人眼前一亮；注意下字体大小、字间距以及行间距；段落文字使用两端对齐的方式，看起来更整齐；同级别的多个段落，尽量字数别相差太多，字数较少的尽量写大半行或恰一整行，字数较多的保持在一行半到两行范围内，会让人觉得内容丰富而排版简洁。 内容是核心，内容肯定是要改多个版本的，以我自身经历为例，我的简历贯穿找实习和找正式工作，总共改了六个大版本，以及针对不同公司的很多小版本。简历内容要有针对性，要找什么样的工作，内容就得往相应的方向靠。 简历的内容要点： 个人信息：姓名、年龄、性别、电话、邮箱； 教育经历：高中及以前的都不用写，写主修课程和学业状态，如果成绩特别优异可以写，否则就别写成绩； 专业技能：编程语言、Git、Linux、数据结构、计算机网络等，部分技能可以标注掌握程度； 实习经历：只专业相关实习经历，写明自己通过哪些技术做了哪些工作，取得了怎样的成果； 项目经历：真要有项目经历那写上去就是，很多同学大学期间仅仅是做了些很简单的课程设计，挑两个最具代表性，最能体现自己能力的项目写上去； 其它：英语水平（四六级）、获得的奖项、兴趣爱好等，有个人博客一定是不错的加分项； 不要放上去的：专业无关的兼职、没啥用的社团经历等。 我自己的能力是挺一般的，不排除大学有些同学确实是很优秀，但我觉得大部分同学的情况都没有那么理想。我相信，很多同学跟我一样会觉得自己很菜，没什么能往简历上写的，虽然这可能就是事实，但仍然要认真对待简历，多改改，避开自己的缺陷，找出自己的闪光点。凑字数的内容都不要，跟专业能力相关的基本都可以删，什么社团经历、兼职经历都不要；兴趣爱好、自我评价也不必要，即便要写也要精简，否则基本就是摆明了能力不够，字数来凑。 实习经历和项目经历我认为是核心，最能体现自己对某些技术的掌握程度。当然也必须是和专业相关的，可以采用 STAR法则 介绍自己的项目经历，用事实和数据说话，吹牛也可以，别吹的太过了就行。面试的时候面试官一般都是看着简历问问题，如果自己写上去的内容被问到又答不上来，那就是自己给自己挖坑。 接上一段，自己不会或者不太熟的技术点，都尽量别忘简历上写。简历上的内容不说面试官所有都会问到，也至少会问到1/3，而简历上没有写到的，面试官通常并不会多问，除非是他们需要用到相关的技术，也就是对应聘者有这方面的要求。所以，写到简历上的内容要尽可能保证自己会，写自己不会的就是给面试时的自己埋下的地雷。 最后放上我最后一版简历做参考吧： 城市工作的城市我认为对于大多数同学无非是离家近的还是任意两种选择。有的同学希望离家近方便些，那针对某个城市去找合适的公司和岗位就行了；其他同学没有这个要求的话，可能对在哪个城市工作就没太多要求了。 总的来说当前国内的情况大概是北上广深分布了百分之八九十的互连网公司，比如北京的中关村就集中了超级多的企业总部，去这些地方找工作机会更多，薪资更高，通常物价也会更高一些。 很多人都不会一直做一份工作，在像中关村这样的地方就很方便跳槽到其他公司，概括地说就是机会更多一些吧。 对于想拼一下闯一下的同学，那去北上广深是必然有更大的发展空间的。 薪资水平薪资受多方面因素影响的，没有一个绝对的标准。985或211院校，开发岗在成都、武汉这样的城市大概月薪大概能开到10k到12k，在北京、上海应该能开到16k到20k这样。 普通本科或者专科院校，开发岗在成都、武汉估计在6k到10k不等，在北京、上海估计在10k到14k不等。 以上只是我自己估计的一个区间，并不绝对，并且薪资水平也受很多因素影响。推荐关注”校招薪水“微信公众号，可以估算一下自己的薪水大概在什么范围。 当面试通过后，有的HR会和你谈薪资待遇，有的公司是定死了薪资是多少，看你能不能接受；有的公司则是可以谈，看你要多少，然后公司能不能给你你想要的。了解自己能拿的薪资范围，对于可以谈薪资的岗位，当然是往高了要，实在不行还能再让点步，如果自己要少了，那只能说是血亏🤣 不同地区薪资水平不一样是正常的，比如北京的16k薪资和成都12k的薪资相比，差别不大，毕竟成都2000租的套一比北京5000租的独卫舒服多了。什么？你要在北京租2000的房？好吧，9平米的超大单间了解一下…… 关于面试推荐观看：做好面试自我介绍，你需要知道这几点 | 核心要点、万能技巧、常见的错误介绍方式、案例分享 个人简记： 穿着得体，程序员一般没必要穿西装啥的，只要干净精神就行； 千万别迟到，注意礼貌； 说话别太着急，组织好语言，说清楚最重要； 诚实，不会就直言不会，不用急于表现自己多么厉害，保持谦虚； 技术问题上可以多引导面试官提问自己会的领域。 技术面向面试官提问： 工作使用的技术栈； 工作的大致内容。 向HR提问： 别问有没有五险一金，正经公司都有，可以问缴纳标准； 可以问工作时间、是否弹性工作制、加班情况（加班正常，主要看加班的严重程度）； 可以问公司的福利、休假制度 可以问公司的培养体系，个人的发展前景等。 其它“海王”听说过吗？就是像我这种疯狂海投简历的，我找实习和找正式工作疯狂投了大约一百五十份简历，虽然我自知自己能力并不是特别强，但知名互连网大厂也是被我投了个遍，比如简历都没过的阿里和笔试挂掉的腾讯，事实就是我最终拿了小米的offer，尽管我一直以为进小米是遥不可及的。有些过来人会说简历别乱投，认准自己感兴趣的公司并结合自身水平去投简历。我认同但也不完全认同，认同的是要认准自己感兴趣的公司，或者说我觉得别去投自己丝毫不感兴趣的公司或岗位更符合我的观念，我认同要结合自身水平，但往往很多同学对自己的水平并没有一个概念，或者说往往都觉得自己很菜（即便这是事实），所以我觉得更准确的是大厂或者那些以为很牛逼的岗位都别怕，反正自己水平就这样了，投了就是个机会，没投就永远都不可能，说不准就被捞了呢！ 关于找工作会有很多人讲经验、技巧什么的，本文我也讲了很多，但归根结底，自身能力才是解锁理想工作的金钥匙，永远不要幻想着靠运气或者什么技巧拿到理想的offer，你以为谁都能有我这样的运气吗？😂玩笑话，反正，努力学校才是硬道理，多积累知识，提升自身能力，当你能力足够强的时候，有没有好运气都是次要的了~ 在我写下这篇博文的此时此刻，高中的同班同学，也是我们年级的第一名，考研考上了北大😂说实话我内心真的是羡慕和震撼！我们那小县城，不知道要多少年才能考上个清华北大，真的是🐂🍺！真心恭喜他！同时也感慨啊，比自己优秀的人还比自己努力，所以要虚心吖，多向别人学习！加油吧，打工人！","categories":[],"tags":[{"name":"求职","slug":"求职","permalink":"https://mxy493.xyz/tags/%E6%B1%82%E8%81%8C/"}]},{"title":"Windows 修改控制台编码为 UTF-8","date":"2021-05-27","updated":"2022-03-23","path":"2021052715441/","text":"直入主题修改 Powershell 默认编码打开注册表，进入 计算机\\HKEY_CURRENT_USER\\Console ，该路径下有两个 Powershell 的注册表项，分别对应 32 位和 64 位的版本，如图： 双击 CodePage 进行修改，基数选择十进制，数值数据修改为 65001 ，点击确定保存即可。 修改 CMD 默认编码打开注册表并进入路径 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor ，修改 autorun 项的数值数据为 chcp 65001&gt;nul ，点击确定保存即可。一定注意是 nul 而不是 null 。 如果没有 autorun 可以新建一个字符串值的项，数值名称设置为 autorun ，其他操作保持一致。 知根知底查看控制台当前的编码，CMD 和 Powershell 都适用： chcp 没修改过的话应该会输出：Active code page: 936 ，表示当前的编码为 GBK 编码。 关于代码页可以参考： 微软官方文档：https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/chcp 以及：https://ss64.com/nt/chcp.html 主要记住 GBK 编码对应 936 ，而 UTF-8 编码对应 65001 。 前文对 CMD 修改编码用的是： chcp 65001&gt;nul 首先 chcp 65001 即设置编码为 UTF-8 ，不带后面的部分也是可以的，只不过会在启动 CMD 的时候输出一行 Active code page: 65001 ，强迫症可能有点难受，加上后面的部分就可以避免输出这一行。 &gt; 是重定向符，即将前面的输出重定向的后面的设备，可能是文件或设备，而 nul 是 Windows 的空设备名，可以尝试一下在 Windows 中新建一个名叫 nul ，没法创建，一定注意别看成 null 了，如果写成了 null ，会认为这是一个文件，所以每次启动 CMD 都会将 Active code page: 65001 写入到当前目录的 null 文件中，搞不好还会遇到一些奇怪的问题。 重定向：https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_redirection 空设备名 nul ：https://ss64.com/nt/nul.html","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://mxy493.xyz/tags/Windows/"},{"name":"CMD","slug":"CMD","permalink":"https://mxy493.xyz/tags/CMD/"},{"name":"Powershell","slug":"Powershell","permalink":"https://mxy493.xyz/tags/Powershell/"}]},{"title":"Visual Studio & Qt 设置可执行程序图标","date":"2021-05-26","updated":"2022-03-23","path":"2021052615395/","text":"直入主题下面是通过 Visual Studio 创建的 QtWidgetsApplication 的默认界面，一行代码都没有写，可以看到窗口左上角的图标是默认没设置的。 随意找了个图标用于测试，如图，文件名分别是 app.png 和 app.ico 。 在主窗口类的构造函数里添加代码： setWindowIcon(QIcon(&quot;app.webp&quot;)); 再编译运行，就可以看到窗口图标有了。 进入到编译后的文件目录看一下，可以看到可执行程序的图标仍旧是默认的图标。 接下来按照众多博客的方法添加资源文件，操作方式如图： 以我的实际经验来说，这一步直接弹出了报错对话框，如图： 看报错我猜应该是路径问题，路径中有空格，它应该是不支持带空格的路径，不过没关系，文件实际上是创建了的，自动创建了两个文件： 两个文件可以自行打开看一下，生成了一堆代码，也不清楚有啥用，实际上此时此刻编译一下还会报错。但总的来说这跟众多博文描述的并不一样，我也不知道为什么会是这样，至少这一开始让我很困惑。我的理解是 VS 以为我们想要的资源文件和我们实际想要的并不是同一个东西。 直接删除生成的头文件 resource.h 并清除 xxx.rc 文件的内容，重新写入如下代码，保存并重新编译。 IDI_ICON1 ICON &quot;app.ico&quot; 详细可参考 Qt 官方文档：https://doc.qt.io/qt-5/appicon.html 重新编译后就可以看到图标已经有了： 另外也可以通过手动新建文本文件的方式添加的，只不过就需要手动修改项目的配置文件。 以手动新建一个 res.rc 资源文件为例，新建文件并写入： IDI_ICON1 ICON &quot;app.ico&quot; 在 xxx.vcxproj 文件中添加以下内容，注意路径： &lt;ItemGroup&gt; &lt;ResourceCompile Include=&quot;res.rc&quot; /&gt; &lt;/ItemGroup&gt; 在 xxx.vcxproj.filters 文件中添加以下内容，注意路径保持一致： &lt;ItemGroup&gt; &lt;ResourceCompile Include=&quot;res.rc&quot;&gt; &lt;Filter&gt;Resource Files&lt;/Filter&gt; &lt;/ResourceCompile&gt; &lt;/ItemGroup&gt; 再重新编译一次就可以了，跟 VS 添加资源是一样的，只不过 VS 会自动完成上述两个配置。","categories":[{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/categories/Qt/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"},{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/tags/Qt/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://mxy493.xyz/tags/Visual-Studio/"}]},{"title":"C++ 日志框架 spdlog 的初步上手","date":"2021-05-25","updated":"2022-03-23","path":"2021052530658/","text":"简述最近一直在忙着做毕业设计，就是一个客户端程序，算下来我做过的两个比较大的项目，一个是去年实习用 Python 和 Qt 做的客户端程序，一个就是毕业设计用 C++ 和 Qt 做的客户端，和 Qt 还挺有缘分的。 在这两个项目中我都写了日志打印的代码，自己写的，因为完全没接触到过日志框架这种东西，当然一方面我的需求也不是特别的高，都是很基础的日志打印，在这两个项目中我都是采用写一个标准日志打印函数，这个函数接受一个字符串，即日志内容，然后函数内部获取当前时间并添加到字符串首部，打印到控制台，或者同时写入日志文件保存。挺简单的，毕竟日志数量并不算多，也不会有太大的性能问题。 前些天突然了解到日志框架这种概念，就特意去了解了 C++ 的日志框架，挺多的，比如 glog 、spdlog 、 log4cplus 等等。 没有做详细的对比，我直接选了 GitHub 星星最多的 spdlog 作为尝试。总的来说，是非常方便，挺值得使用的。 安装spdlog 是仅含有头文件的开源库，直接下载源码把头文件包含到项目里就可以，我比较喜欢 vcpkg ： vcpkg install spdlog 仓库首页也提供了很多种安装方式。 使用快速上手关于使用我也不做过多的介绍了，推荐查看官方文档：https://github.com/gabime/spdlog/wiki 能想到的以及不能想到的特性它都支持，比如： 输出日志到终端； 输出日志到文件； 以不同颜色输出到终端； 日志等级； 多文件文件管理； …… 如前所述，我的需求是很简单的，只要可以通过一个标准接口将日志输出到终端和文件即可。spdlog 可以在包含头文件后一行代码直接输出日志，像 std::cout 一样，但实际上创建一个 logger 更方便管理一些。如下代码分别创建了一个输出日志到终端的 logger 和一个输出日志到文件的 logger ，后续就可以调用 logger 的日志输出函数用于打印日志。 #include &lt;spdlog/spdlog.h&gt; #include &lt;spdlog/sinks/stdout_color_sinks.h&gt; #include &lt;spdlog/sinks/basic_file_sink.h&gt; std::shared_ptr&lt;spdlog::logger&gt; console_logger = spdlog::stdout_color_mt(&quot;console_logger&quot;); std::shared_ptr&lt;spdlog::logger&gt; file_logger = spdlog::basic_logger_mt(&quot;file_logger&quot;, &quot;filename.log&quot;); console_logger-&gt;info(&quot;Welcome to spdlog!&quot;); file_logger-&gt;warn(&quot;Welcome to spdlog!&quot;); 但上述代码并没有满足我的需求，因为我希望的是通过一个函数同时输出到终端和日志文件，而上述代码需要分别调用两个 logger 的日志输出函数才可以做到。查阅 spdlog 的文档，其实也是可以做到的，例如如下的代码即官方给出的示例，可以将多个 logger 绑定到一起，一次调用即输出到多个终端或文件，并且可以通过日志等级按需输出，真的是特别细致啊！ // create logger with 2 targets with different log levels and formats. // the console will show only warnings or errors, while the file will log all. void multi_sink_example() &#123; auto console_sink = std::make_shared&lt;spdlog::sinks::stdout_color_sink_mt&gt;(); console_sink-&gt;set_level(spdlog::level::warn); console_sink-&gt;set_pattern(&quot;[multi_sink_example] [%^%l%$] %v&quot;); auto file_sink = std::make_shared&lt;spdlog::sinks::basic_file_sink_mt&gt;(&quot;logs/multisink.txt&quot;, true); file_sink-&gt;set_level(spdlog::level::trace); spdlog::logger logger(&quot;multi_sink&quot;, &#123;console_sink, file_sink&#125;); logger.set_level(spdlog::level::debug); logger.warn(&quot;this should appear in both console and file&quot;); logger.info(&quot;this message should not appear in the console, only in the file&quot;); &#125; 不过在我的项目中，我还是没有采用这种方式，原因是我其实并没有输出不同等级日志的需求，它提供的服务反而对我来说有点复杂了😂 我想要的所以我自己封装了两个函数，如下。initSpdLogger() 用于在程序启动时初始化日志框架，包括初始化两个 logger 和设置了我想要的日志格式，像这样：[2021-05-25 19:05:07.441] [784] Welcome to spdlog! ，分别是时间、线程和日志内容；printLog() 用于打印日志， save 参数默认为 true ，即只需将要打印的内容作为参数传入即可，默认同时输出到终端和文件，也可以指定 save 为 false ，即仅打印到终端而不写入文件。 #include &lt;QString&gt; #include &lt;QDate&gt; #include &lt;spdlog/spdlog.h&gt; #include &lt;spdlog/sinks/stdout_color_sinks.h&gt; #include &lt;spdlog/sinks/basic_file_sink.h&gt; std::shared_ptr&lt;spdlog::logger&gt; file_logger; std::shared_ptr&lt;spdlog::logger&gt; console_logger; bool initSpdLogger() &#123; try &#123; spdlog::set_pattern(&quot;[%Y-%m-%d %H:%M:%S.%e] [%t] %v&quot;); QString date = QDate::currentDate().toString(&quot;yyyy-MM-dd&quot;); std::string log_file = &quot;log/&quot; + date.toLocal8Bit() + &quot;.log&quot;; file_logger = spdlog::basic_logger_mt(&quot;file_logger&quot;, log_file); console_logger = spdlog::stdout_color_mt(&quot;console_logger&quot;); &#125; catch (const spdlog::spdlog_ex &amp;ex) &#123; std::cout &lt;&lt; &quot;Log init failed: &quot; &lt;&lt; ex.what() &lt;&lt; std::endl; return false; &#125; return true; &#125; void printLog(const QString &amp;log, bool save=true) &#123; console_logger-&gt;info(log.toLocal8Bit().toStdString()); if (save) &#123; file_logger-&gt;info(log.toUtf8().toStdString()); &#125; &#125; void printLog(const std::string &amp;log, bool save=true) &#123; console_logger-&gt;info(log); if (save) &#123; file_logger-&gt;info(log); &#125; &#125; 官方文档提供了关于格式化输出的详细介绍：https://github.com/gabime/spdlog/wiki/3.-Custom-formatting 。 由于我项目主要是 Qt 写的，上述代码中也用到了 Qt 的相关函数，中文字符的打印一定是很多人的疑惑，字符编码真的是很麻烦事情。关于 spdlog 支持的字符串类型我没有找到相关说明，大概是 std::string 和 char * 是支持的，所有 QString 需要做转换，如果是中文，通常统一使用 log.toLocal8Bit().toStdString() 是没有问题的，终端一般默认都是 GBK 编码，一定要这么转才能正常显示；打印到文件则可以使用兼容性更好一些的 UTF-8 编码，即 log.toUtf8().toStdString() ，都可以正常显示。 刷新机制需要注意以下 spdlog 的刷新机制，输出到终端的日志应该是立即就刷新了，但输出到文件的日志会在程序正常关闭的时候才刷写到日志文件中，也就是说如果程序没有正常关闭，比如卡死了，那么日志就会丢失。 官方文档专门对刷新策略进行了介绍：https://github.com/gabime/spdlog/wiki/7.-Flush-policy 一是手动调用 flush() 函数刷新，如果要确保每条日志都立即刷新，那么就在输出一条日之后立即调用该函数。 console_logger-&gt;info(log); console_logger-&gt;flush(); 二是设置某种等级的日志就刷新，相当于对日志等级加了一个判断，如果是某个等级的日志就刷新。 my_logger-&gt;flush_on(spdlog::level::err); 还有一种方法是设置刷新间隔时间，每隔一定时间就刷新一次，例如每 5s 刷新一次。 spdlog::flush_every(std::chrono::seconds(5)); 结语本文并没有深入介绍 spdlog ，因为我觉得它的使用真的很简单，基本没有上手难度啊！ spdlog 是可以支撑服务端快速打印大量日志的，简言之就是它的能力很强，而我的小程序对日志打印的速度并没有太高的要求😉 最后，开源的世界真好 (≧∇≦)ﾉ 感谢开发者们！","categories":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"解决 LeanCloud '因流控原因，通过定时任务唤醒体验版实例失败' 的问题","date":"2021-03-19","updated":"2022-03-23","path":"2021031924011/","text":"简述从我的博客搭建起来我就选用了简洁大方 Valine 作为评论系统，又用 Valine-Admin 做了服务端部署在 LeanCloud 上，两年了基本上运行还是比较稳定的，最近一段时间 LeanCloud 云引擎总是报错：“因流控原因，通过定时任务唤醒体验版实例失败”，了解了下，大概原因就是 LeanCloud 方面做了一些限制，虽然不绝对，但目前极大概率的会遇到这个问题。 LeanCloud 限制的只是容器的定时任务唤醒，而外部访问依然会激活容器！网上的各种解决方案应该都是基于这一点的。 具体说解决办法就是登录云引擎的后台，以 Valine-Admin 来说就是登录评论的后台管理系统，应该说只要手动登陆一下，云函数就能正常运行了，但也不太可能每天去登陆一下后台啊~ 所以这里可以借助各种外部工具来定时访问云引擎后台，特别需要注意的是，所有这些解决方案所指的对 LeanCloud 的访问都是访问云引擎域名，不是博客地址！ 这里进一步再提醒一下，国内版 LeanCloud 必须绑定域名，且绑定域名需要备案，国外版无需备案。如果不能备案的话只能使用国外版！ LeanCloud 休眠策略这里需要进一步了解 LeanCloud 的休眠策略，这是诸多问题的关键： 标准实例不会休眠。 体验实例会执行休眠策略： 如果应用最近一段时间（半小时）没有任何外部请求，则休眠。 休眠后如果有新的外部请求实例则马上启动。访问者的体验是第一个请求响应时间是 5 ~ 30 秒（视实例启动时间而定），后续访问响应速度恢复正常。 强制休眠：如果最近 24 小时内累计运行超过 18 小时，则强制休眠。此时新的请求会收到 503 的错误响应码，该错误可在 云引擎 &gt; 统计 中查看。 标准实例显然是最佳方案，但劝退价😂而使用体验示例就要精打细算了，基于上述休眠策略，可以简单算一下，云引擎每天最多能运行18个小时，也就是必须休眠6个小时，显然让它晚上和我们一起睡6个小时更合适一些，当然你也可以选择让它在别的时间睡。 关于 Valine-Admin ，有两个定时任务，一个是每天早晨执行一次的重发漏发邮件的函数，另一个则是每天间隔一段时间执行一次的避免云引擎休眠的唤醒函数，可以看到各种教程都将运行周期设置为 0 */20 7-23 * * ?， 即每天 7:00 到 23:59 期间每 20 分钟执行一次，也就是云引擎至少会在 7:00 到 23:59 持续运行17个小时。 可能你会发现还剩一个小时可以运行，是的，这剩余的一个小时可运行时间留在夜间，即便是有外部请求也能保证云引擎可以被唤醒。甚至保险起见，还可以再多预留一些时间到夜间。 网上的各种方案遇到这个问题我也是在网上找解决办法，这期间看到了各种方案，大概总结如下： Github Action (WakeLeanCloud)：解决LeanCLoud定时唤醒失败的流控问题 （产生太多 commit ，个人不建议） Github Action (leancloud-self-wake)：Gtihub Action｜一行命令解决 LeanCloud 流控问题 腾讯云函数：使用云函数解决leancloud流控问题 阿里云站点监控：LeanCloud因流控原因的解决办法 Cloudflare cron-job：使用cron-job解决Valine-admin因流控原因自动唤醒失败的问题 我使用过 Github Action 和腾讯云函数两种方案，亲测可行，最终保留了腾讯云函数这种方案。 解决问题1）Github Action - WakeLeanCloud 2）使用腾讯云函数解决 LeanCloud 流控问题（点这里🤣）","categories":[],"tags":[{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://mxy493.xyz/tags/LeanCloud/"}]},{"title":"使用腾讯云函数解决 LeanCloud 流控问题","date":"2021-03-19","updated":"2022-03-23","path":"2021031963302/","text":"简述建议阅读：解决 LeanCloud ‘因流控原因，通过定时任务唤醒体验版实例失败’ 的问题 参考：使用云函数解决leancloud流控问题 我个人在此之前没有使用过云函数，所以也是看着别人写的一步一步来的，但关于本文要解决的问题，网上博客介绍的都比较简略，所以本文面向小白，希望能写一篇正儿八经能看着傻瓜式操作的教程。 需要注意解决流控问题，本质是唤醒 LeanCloud 云引擎，而不是触发 Valine-Admin 的两个云函数，所以我个人认为不需要过多的访问云引擎域名，只需要早晨通过外部访问一次云引擎域名，后续 Valine-Admin 的 self_wake 函数就可以自我唤醒了。 傻瓜式教程首先打开腾讯云云函数网站，登录控制台，点击左侧 函数服务 ，然后点击 新建 。 选择 自定义创建 ，函数名自己取一个，例如 wakeup_leancloud ，运行环境选择 Python3.6 ，如图： 接下来编写代码，用你的 云引擎域名 替换 your URL，将下面的代码粘贴进去即可： # -*- coding: utf8 -*- import urllib.request def main_handler(event, context): url=&quot;your URL&quot; req=urllib.request.Request(url) resp=urllib.request.urlopen(req) print(&quot;外部访问运行完成！&quot;) 如图： 往下滑，点击 触发器配置 ，选择 自定义创建 ，根据我们的需求选择 定时触发 ，定时任务名称自己取一个，例如 wakeup_every_morning ，触发周期选择 自定义触发周期 。 Cron 表达式自己根据需求设置，我个人认为只需要每天早晨触发一次唤醒 LeanCloud 云引擎即可，后续 LeanCloud 的定时任务就可以自我唤醒了，所以我将触发周期设置为每天早晨 7:00 到 7:59 每10分钟触发一次（会触发6次，避免失败），即 0 */10 7 * * * * 。最后点击底部 完成 。 随后云函数将自动部署，到这里就算搞定了。可以自行测试一下函数是否执行成功，以及云引擎是否成功唤醒。 其它Cron 表达式并不复杂，不难发现通过设置 Cron 表达式可以实现各种定时触发，这里就没啥好说的了。 回到 函数服务 页面，可以看到刚才创建好的云函数： 点击函数名进入函数管理，可以进一步修改代码以及做一些其它设置。 点击左侧的 日志查询 可以查看函数的日志，是否按时运行以及是否执行成功，如图：","categories":[],"tags":[{"name":"LeanCloud","slug":"LeanCloud","permalink":"https://mxy493.xyz/tags/LeanCloud/"}]},{"title":"C++ 在各种字符串类型之间相互转换","date":"2021-03-02","updated":"2022-03-23","path":"2021030220973/","text":"简述最近在写 MFC 程序的过程中经常遇到不同字符串类型间的转换，也是在查资料的过程中意外发现了微软的一篇文档：如何：在各种字符串类型之间进行转换。介绍的相当全面，即便是没有提及的基本也可以通过多次转换得到，本文将比较常用的一些转换提炼成代码片段，以便以后查阅☠ 多字节 &lt;==&gt; 宽字符1. MultiByteToWideChar官方文档：MultiByteToWideChar function (stringapiset.h) int MultiByteToWideChar( UINT CodePage, DWORD dwFlags, _In_NLS_string_(cbMultiByte)LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar ); 宽字符字符串（wchar_t * or wstring）转多字节字符串（string） std::string wc2mb(const wchar_t* buffer, int len) &#123; int nChars = WideCharToMultiByte(CP_UTF8, 0, buffer, len, NULL, 0, NULL, NULL); if (nChars == 0) return &quot;&quot;; std::string str; str.resize(nChars); WideCharToMultiByte(CP_UTF8, 0, buffer, len, const_cast&lt;char*&gt;(str.c_str()), nChars, NULL, NULL); return str; &#125; std::string wc2mb(const std::wstring&amp; str) &#123; return wc2mb(str.c_str(), (int)str.size()); &#125; 2. WideCharToMultiByte官方文档：WideCharToMultiByte function (stringapiset.h) int WideCharToMultiByte( UINT CodePage, DWORD dwFlags, _In_NLS_string_(cchWideChar)LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar ); 多字节字符串（char *）转宽字符字符串（wchar_t *） wchar_t* mb2wc(char * chs) &#123; int bufSize = MultiByteToWideChar(CP_UTF8, 0, chs, -1, NULL, 0); wchar_t* wcs = new wchar_t[bufSize]; MultiByteToWideChar(CP_UTF8, 0, chs, -1, wcs, bufSize); return wcs; &#125; 从 char * 转换1. To wchar_t *char *orig = &quot;Hello, World!&quot;; size_t newsize = strlen(orig) + 1; // 14 wchar_t * wcstring = new wchar_t[newsize]; size_t convertedChars = 0; mbstowcs_s(&amp;convertedChars, wcstring, newsize, orig, _TRUNCATE); // Required &lt;stdlib.h&gt; 2. To _bstr_tchar *orig = &quot;Hello, World!&quot;; _bstr_t bstrt(orig); 3. To CComBSTRchar *orig = &quot;Hello, World!&quot;; CComBSTR ccombstr(orig); CW2A printstr(ccombstr); cout &lt;&lt; printstr &lt;&lt; endl; 4. To CStringAchar *orig = &quot;Hello, World!&quot;; CStringA cstringa(orig); 5. To CStringWchar *orig = &quot;Hello, World!&quot;; CStringW cstring(orig); 6. To stringchar *orig = &quot;Hello, World!&quot;; string basicstring(orig); 7. To System::Stringchar *orig = &quot;Hello, World!&quot;; String ^systemstring = gcnew String(orig); delete systemstring; 从 wchar_t * 转换1. To char *wchar_t *orig = _T(&quot;Hello, World!&quot;); size_t origsize = wcslen(orig) + 1; // 14 size_t newsize = origsize * 2; // 28, 宽字符占2个字节 char *nstring = new char[origsize]; size_t convertedChars = 0; wcstombs_s(&amp;convertedChars, nstring, newsize, orig, _TRUNCATE); // Put a copy of the converted string into nstring _mbscat_s((unsigned char*)nstring, newsize, (unsigned char*)strConcat); // append the type of string to the new string. 2. To _bstr_twchar_t *orig = _T(&quot;Hello, World!&quot;); _bstr_t bstrt(orig); 3. To CComBSTRwchar_t *orig = _T(&quot;Hello, World!&quot;); CComBSTR ccombstr(orig); CW2A printstr(ccombstr); cout &lt;&lt; printstr &lt;&lt; endl; wcout &lt;&lt; (LPCTSTR) ccombstr &lt;&lt; endl; // 更简单 4. To CStringAwchar_t *orig = _T(&quot;Hello, World!&quot;); CStringA cstringa(orig); 5. To CStringWwchar_t *orig = _T(&quot;Hello, World!&quot;); CStringW cstring(orig); 6. To wstringwchar_t *orig = _T(&quot;Hello, World!&quot;); wstring basicstring(orig); 7. To System::Stringwchar_t *orig = _T(&quot;Hello, World!&quot;); String ^systemstring = gcnew String(orig); delete systemstring; 从 CString 转换1. CStringA to char *CStringA origa(&quot;Hello, World!&quot;); const size_t newsizea = (origa.GetLength() + 1); char *nstringa = new char[newsizea]; strcpy_s(nstringa, newsizea, origa); 2. CStringW to char *CStringW origw(&quot;Hello, World!&quot;); const size_t newsizew = (origw.GetLength() + 1) * 2; char *nstringw = new char[newsizew]; size_t convertedCharsw = 0; wcstombs_s(&amp;convertedCharsw, nstringw, newsizew, origw, _TRUNCATE ); 3. CStringA to wchar_t *CStringA origa(&quot;Hello, World!&quot;); const size_t newsizea = (origa.GetLength() + 1); size_t convertedCharsa = 0; wchar_t *wcstring = new wchar_t[newsizea]; mbstowcs_s(&amp;convertedCharsa, wcstring, newsizea, origa, _TRUNCATE); 4. CStringW to wchar_t *CStringW origw(&quot;Hello, World!&quot;); const size_t newsizew = (origw.GetLength() + 1) * 2; wchar_t *n2stringw = new wchar_t[newsizew]; wcscpy_s( n2stringw, newsizew, origw ); 5. CStringA to _bstr_tCStringA origa(&quot;Hello, World!&quot;); _bstr_t bstrt(origa); 6. CStringW to _bstr_tCStringW origw(&quot;Hello, World!&quot;); bstr_t bstrtw(origw); 7. CStringA to CComBSTRCStringA origa(&quot;Hello, World!&quot;); CComBSTR ccombstr(origa); CW2A printstr(ccombstr); cout &lt;&lt; printstr &lt;&lt; endl; 8. CStringW to CComBSTRCStringW origw(&quot;Hello, World!&quot;); CComBSTR ccombstrw(origw); CW2A printstrw(ccombstrw); wcout &lt;&lt; printstrw &lt;&lt; endl; 9. CStringA to stringCStringA origa(&quot;Hello, World!&quot;); string basicstring(origa); 10. CStringW to wstringCStringW origw(&quot;Hello, World!&quot;); wstring basicstringw(origw); 11. CStringA to System::StringCStringA origa(&quot;Hello, World!&quot;); String ^systemstring = gcnew String(origa); delete systemstring; 12. CStringA to System::StringCStringW origw(&quot;Hello, World!&quot;); String ^systemstringw = gcnew String(origw); delete systemstringw; 从 basic_string 转换1. string to char *string orig(&quot;Hello, World!&quot;); const size_t newsize = (strlen(orig.c_str()) + 1)*2; char *nstring = new char[newsize]; strcpy_s(nstring, newsize, orig.c_str()); 2. string to wchar_t *string orig(&quot;Hello, World!&quot;); const size_t newsizew = strlen(orig.c_str()) + 1; size_t convertedChars = 0; wchar_t *wcstring = new wchar_t[newsizew]; mbstowcs_s(&amp;convertedChars, wcstring, newsizew, orig.c_str(), _TRUNCATE); 3. wstring to wchar_t *wstring origw(L&quot;Hello, World!&quot;); wchar_t *wcstring = origw.c_str(); 4. string to _bstr_tstring orig(&quot;Hello, World!&quot;); _bstr_t bstrt(orig.c_str()); 5. string to CComBSTRstring orig(&quot;Hello, World!&quot;); CComBSTR ccombstr(orig.c_str()); CW2A printstr(ccombstr); cout &lt;&lt; printstr &lt;&lt; endl; 6. string to CStringAstring orig(&quot;Hello, World!&quot;); CStringA cstring(orig.c_str()); 7. string to CStringWstring orig(&quot;Hello, World!&quot;); CStringW cstringw(orig.c_str()); 8. string to System::Stringstring orig(&quot;Hello, World!&quot;); String ^systemstring = gcnew String(orig.c_str()); delete systemstring; 参考文档 如何：在各种字符串类型之间进行转换 MultiByteToWideChar function (stringapiset.h) WideCharToMultiByte function (stringapiset.h)","categories":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"C++ 包管理器 vcpkg 的安装使用","date":"2021-02-25","updated":"2022-03-23","path":"202102252517/","text":"简述Vcpkg 是适用于 C 和 C++ 库的跨平台命令行包管理器。我个人的理解就类似于 Python 的 pip ，可以很方便的下载安装一些第三方的库。 本文仅简要记录我个人在 Windows 平台下的安装使用过程，更多内容请查阅官方文档：https://docs.microsoft.com/zh-cn/cpp/build/vcpkg?view=msvc-160 安装首先确保 Windows 系统已安装 Git ，将 vcpkg 仓库克隆到本地，并执行根目录下的 bootstrap-vcpkg.bat 脚本。 git clone https://github.com/microsoft/vcpkg .\\vcpkg\\bootstrap-vcpkg.bat 这就安装好了，但一般在 Windows 上都是使用 Visual Studio 进行开发，这里需要注意 Visual Studio 一定要安装英文语言包！ 为了更好的搭配 Visual Studio 使用，还需要执行以下命令（需要管理员权限）： .\\vcpkg\\vcpkg integrate install .\\vcpkg\\vcpkg integrate remove # 上一行的逆操作 到这里，就可以很无痛的通过 vcpkg 安装第三方库并直接在 Visual Studio 中 #include 相关的库，可以说真的超级方便！ 进一步可以将 vcpkg 的路径添加到环境变量中，这样就可以在任意位置直接执行 vcpkg 指令了~ 常用命令1. 已安装的库vcpkg list 2. 搜索库vcpkg search [search term] 3. 安装库vcpkg install [packages to install] 安装库可以指定目标平台：x86-windows、x64-linux.cmake 或 x64-osx.cmake。例如： vcpkg install boost:x86-windows 通过 vcpkg 安装库会自动安装依赖的库，所以无需担心依赖问题。 通过以下命令可以查看当前支持的目标平台： vcpkg help triplet 4. 更新/升级库要更新本地库首先需要拉取最新的版本信息文件： git pull 然后通过以下命令查看本地库是否过期： vcpkg update 更新库： vcpkg upgrade --no-dry-run 升级选项： --no-dry-run：执行升级；若未指定，该命令将仅列出过期的包。 --keep-going：继续安装包（即使某项失败）。 --triplet &lt;t&gt;：为非限定的包设置默认的三元组。 --vcpkg-root &lt;path&gt;：指定要使用的 vcpkg 目录，而不是使用当前目录或工具目录。 5. 删除库vcpkg remove [packages to remove] 如果有其他库依赖它，系统会提示你使用 --recurse 重新运行命令；重新运行会导致下游的所有库都被删除。 常见问题1. 下载速度慢或无法下载下载速度慢的原因是可想而知的，如果条件允许的话可以通过对 Power Shell 设置代理解决。 这里提供临时代理的方法（个人认为设置永久代理不是很必要），在 Power Shell 中执行以下两行命令（注意美元符合也是命令的一部分）立即生效，关闭终端后失效。 $env:HTTP_PROXY=&quot;localhost:[port]&quot; $env:HTTPS_PROXY=&quot;localhost:[port]&quot; 2. 是否可以删除 downloads 和 buildtrees 文件夹？首先为什么要删除这两个目录，因为没啥用还特别占空间，比如我装 TensorFlow 的时候，buildtrees 目录下的 tensorflow-cc 文件夹直接占用了超过 60G 的空间😅 至于可不可以删除，答案是：可以放心的删！ 参考 GitHub 的回答：https://github.com/microsoft/vcpkg/issues/2538 downloads 目录是用来保存下载的包的，比如说第一次安装某个包失败了，但它已经下载到 downloads 目录下，所以重新安装的时候就不用再下载一次了。 而 buildtrees 主要是编译过程中产生的一些文件，以 GitHub 的回答来说这两个目录的作用就是调试找问题，因此当某个包已经成功安装后，这两个目录就可以放心的删除了。 不难发现，安装的包最终都位于 installed 目录下！","categories":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"},{"name":"vcpkg","slug":"vcpkg","permalink":"https://mxy493.xyz/tags/vcpkg/"}]},{"title":"C++保存文件为UTF8编码格式","date":"2021-02-25","updated":"2022-03-23","path":"2021022519518/","text":"简述目前在做毕业设计，用 MFC 做一个 OCR 文字识别的客户端程序，其中就涉及到了将数据导出，源码中最常用的字符串类型大概就是 CString ，最主要的原因是它支持中文吧，严格说是支持 Unicode 字符。 关于导出数据这一块，其实就是用 ofstream 来将数据写到文件，CString 也是支持直接写到文件中的，但大概是由于 Visual Studio 的原因默认的编码格式似乎是 GB… 编码，我更想将文件保存为 UTF8 格式，这样就避免了由于字符编码引起的乱码问题~ 解决这个问题也就是解决 CString 转 UTF8 ，这里描述的不是很合理（CString 不是编码格式的一种），但能说清楚问题，就不多纠结用词了。 网上有很多关于这个的回答，我自己也是从网上找的，这里就不细说了，轮子直接拿来用即可。 核心函数就一个：WideCharToMultiByte() 代码标准代码模板如下，两个函数任意调用一个即可： std::string to_utf8(const wchar_t* buffer, int len) &#123; int nChars = ::WideCharToMultiByte( CP_UTF8, 0, buffer, len, NULL, 0, NULL, NULL); if (nChars == 0) return &quot;&quot;; std::string str; str.resize(nChars); ::WideCharToMultiByte( CP_UTF8, 0, buffer, len, const_cast&lt;char*&gt;(str.c_str()), nChars, NULL, NULL); return str; &#125; std::string to_utf8(const std::wstring&amp; str) &#123; return to_utf8(str.c_str(), (int)str.size()); &#125; 调用方法： CString s0 = _T(&quot;就很棒&quot;); std::string s1 = to_utf8(s0.GetString());","categories":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1576. 替换所有的问号【C++】","date":"2021-02-23","updated":"2022-03-23","path":"2021022323341/","text":"地址：https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/ 题目给你一个仅包含小写英文字母和 &#39;?&#39; 字符的字符串 s，请你将所有的 &#39;?&#39; 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。 注意：你 不能 修改非 &#39;?&#39; 字符。 题目测试用例保证 除 &#39;?&#39; 字符 之外，不存在连续重复的字符。 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。 示例 1： 输入：s = &quot;?zs&quot; 输出：&quot;azs&quot; 解释：该示例共有 25 种解决方案，从 &quot;azs&quot; 到 &quot;yzs&quot; 都是符合题目要求的。只有 &quot;z&quot; 是无效的修改，因为字符串 &quot;zzs&quot; 中有连续重复的两个 &#x27;z&#x27; 。 示例 2： 输入：s = &quot;ubv?w&quot; 输出：&quot;ubvaw&quot; 解释：该示例共有 24 种解决方案，只有替换成 &quot;v&quot; 和 &quot;w&quot; 不符合题目要求。因为 &quot;ubvvw&quot; 和 &quot;ubvww&quot; 都包含连续重复的字符。 示例 3： 输入：s = &quot;j?qg??b&quot; 输出：&quot;jaqgacb&quot; 示例 4： 输入：s = &quot;??yw?ipkj?&quot; 输出：&quot;acywaipkja&quot; 提示： 1 &lt;= s.length &lt;= 100 s 仅包含小写英文字母和 &#39;?&#39; 字符 解题思路思路很简单，就是遍历字符串，遇到 &#39;?&#39; 就找个合适的字符替换掉就可以了~ 我认为核心在于判断是否 连续重复 ，也就是从 26 个字母中找一个既不和前一个字符相同，也不和后一个字符相同的，替换掉当前位置的 &#39;?&#39; ，实际上只需要一个判断就能完成这个工作，例如在我的代码中为：if ((i == 0 || (i &gt; 0 &amp;&amp; tmp != s[i - 1])) &amp;&amp; (i == s.length() - 1 || (i &lt; s.length() - 1 &amp;&amp; tmp != s[i + 1]))) 代码class Solution &#123; public: string modifyString(string s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (s[i] == &#x27;?&#x27;) &#123; for (int j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; j++) &#123; char tmp = j; // 既不和前一个字符相同，也不和后一个字符相同 if ((i == 0 || (i &gt; 0 &amp;&amp; tmp != s[i - 1])) &amp;&amp; (i == s.length() - 1 || (i &lt; s.length() - 1 &amp;&amp; tmp != s[i + 1]))) &#123; s.erase(s.begin() + i); // 删除&#x27;?&#x27; s.insert(i, 1, tmp); // 在原位置插入新字符 break; &#125; &#125; &#125; &#125; return s; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1370. 上升下降字符串【C++】","date":"2021-02-20","updated":"2022-03-23","path":"202102204296/","text":"地址：https://leetcode-cn.com/problems/increasing-decreasing-string/ 题目给你一个字符串 s ，请你根据下面的算法重新构造字符串： 从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。 重复步骤 2 ，直到你没法从 s 中选择字符。 从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。 从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。 重复步骤 5 ，直到你没法从 s 中选择字符。 重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。 在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。 请你返回将 s 中字符重新排序后的 结果字符串 。 示例 1： 输入：s = &quot;aaaabbbbcccc&quot; 输出：&quot;abccbaabccba&quot; 解释：第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot; 第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot; 第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1 第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot; 第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot; 示例 2： 输入：s = &quot;rat&quot; 输出：&quot;art&quot; 解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot; 示例 3： 输入：s = &quot;leetcode&quot; 输出：&quot;cdelotee&quot; 示例 4： 输入：s = &quot;ggggggg&quot; 输出：&quot;ggggggg&quot; 示例 5： 输入：s = &quot;spo&quot; 输出：&quot;ops&quot; 提示： 1 &lt;= s.length &lt;= 500 s 只包含小写英文字母。 解题思路很明显是一个排序的问题，所以第一步就是把字符串按字符排序。 然后就是并不复杂的反复从小到大和从大到小取字符附加到结果字符串对的末尾，直到原字符串的所有字符都已经添加到结果字符串中。 在我的代码中我每添加一个字符到结果字符串，就将该字符从原字符串中删除，直到原字符串为空~ 代码class Solution &#123; public: string sortString(string s) &#123; sort(s.begin(), s.end()); // 将字符串排序 string str = &quot;&quot;; // 结果字符串 // 将最小字符添加到结果字符串末尾 // 避免循环内部对特殊情况的判断 str += s[0]; s.erase(s.begin()); bool up = true; // 用于辨别处于上升阶段还是下降阶段 int i = 0; while (s != &quot;&quot;) &#123; // 上升阶段 if (up) &#123; if (i == s.length() - 1) &#123; str += s.back(); s.pop_back(); up = false; i = s.length() - 1; &#125; else if (s[i] &gt; str.back()) &#123; str += s[i]; s.erase(s.begin() + i); &#125; else i++; &#125; // 下降阶段 else &#123; if (i == 0) &#123; str += s[0]; s.erase(s.begin()); up = true; &#125; else if (s[i] &lt; str.back()) &#123; str += s[i]; s.erase(s.begin() + i); i--; &#125; else i--; &#125; &#125; return str; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 459. 重复的子字符串【C++】","date":"2021-02-19","updated":"2022-03-23","path":"2021021921318/","text":"地址：https://leetcode-cn.com/problems/repeated-substring-pattern/ 题目给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 示例 1: 输入: &quot;abab&quot; 输出: True 解释: 可由子字符串 &quot;ab&quot; 重复两次构成。 示例 2: 输入: &quot;aba&quot; 输出: False 示例 3: 输入: &quot;abcabcabcabc&quot; 输出: True 解释: 可由子字符串 &quot;abc&quot; 重复四次构成。 (或者子字符串 &quot;abcabc&quot; 重复两次构成。) 解题思路看了题目之后我个人大概两个方向的思路，一是从最短的子串（一个字符的子串）开始判断，如果长度为 l 的子串不满足题目要求，则继续判断长度为 l + 1 的子串；另一个思路是先将原字符串等分为多个长度相等的子串，再判断各个子串是否相同。 综合来看，第二种思路过滤掉了长度不合适的子串，应该更理想一些，我也正是采用了这种思路解题。 首先要将长度为 len 的字符串划分为多个子串，可能的最少个数为 2 ，最多个数则一定是 len ，所以外层循环从 2 到 len 遍历并在循环体内判断是否可以等分字符串，如果可以则进一步判断等分的 i 个子串是否相同，一旦遇到各子串均相同的情况则返回 true ，否则遍历完所有可能的情况后返回 false 。 代码class Solution &#123; public: bool repeatedSubstringPattern(string s) &#123; int len = s.length(); //先判断是否可以分为i个长度相等的子串，再判断各子串是否相同 for (int i = 2; i &lt;= len; i++) &#123; if (len % i == 0) &#123; int l = len / i; //子串长度 string st = s.substr(0, l); //将后续子串与第一个子串比较 bool find = true; for (int j = 1; j &lt; i; j++) &#123; if (st != s.substr(l * j, l)) &#123; find = false; break; &#125; &#125; if (find) return true; &#125; &#125; return false; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 665. 非递减数列【C++】","date":"2021-02-19","updated":"2022-03-23","path":"202102194843/","text":"地址：https://leetcode-cn.com/problems/non-decreasing-array/ 题目给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。 示例 1： 输入: nums = [4,2,3] 输出: true 解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。 示例 2： 输入: nums = [4,2,1] 输出: false 解释: 你不能在只改变一个元素的情况下将其变为非递减数列。 提示： 1 &lt;= n &lt;= 10 ^ 4 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 解题思路自己做没想出来好的方法，最后看了官方题解~ 思路就是找 nums[i] &gt; nums[i + 1] 出现的次数，但需要注意 nums[i + 1] &lt; nums[i - 1] 的情况，例如一组数 3, 4, 2 ，此时 4 &gt; 2 ，默认我们认为 4 是需要修改的数，应将其修改为 &lt;=2 的数，但如果这么做就会发现修改后 3 大于后续的两个数，不符合非递减的要求，所以正确的操作是将后一个数 2 修改为 &gt;=4 的数，保险的做法正是将其修改为 4 。 继续往后遍历查找 nums[i] &gt; nums[i + 1] 的情况，如果第二次发现这样的情况则说明通过一次修改不能使该数组成为非递减数列，直接返回 false ，否则遍历结束后返回默认值 true 。 代码class Solution &#123; public: bool checkPossibility(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0; for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; cnt++; if (cnt &gt; 1) return false; if (i &gt; 0 &amp;&amp; nums[i + 1] &lt; nums[i - 1]) &#123; nums[i + 1] = nums[i]; &#125; &#125; &#125; return true; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"使用Qt for Python实现加载动画","date":"2020-12-03","updated":"2022-03-23","path":"2020120331732/","text":"简述之前用 Qt 做程序界面的时候，有一个小问题就是有的操作可能比较耗时，比如说点击一个按钮，程序需要一段时间来处理，然后这时候界面也卡住不能操作了，需要等待处理完成，我自己也是使用软件的，很显然这样用户体验极差。很常见的做法就是添加一个加载动画，加载完之后再自动关闭加载动画，体验就一下子上来了🤪 不过说归说，这事情却一直没有做，今天恰好有时间就查资料，把这事给解决了~ 思路首先还是简要说下思路。在开始做之前，甚至开始查资料之前，我理想的状态就是这个动画应该独立于窗口之外，背景应该是透明的，应该有显示动画和关闭动画的接口。 第一点，独立于窗口之外，很容易想到动画应该放到一个单独的窗口中，比如用单独的 QWidget 放动画，这样就可以在需要的时候将这个窗口弹出或关闭。 第二点，也是比较关键的一点，背景应该透明。默认的窗口首先背景就不是透明的，并且还有标题栏，必须要去掉或者隐藏掉标题栏，透明背景应该有接口可以很容易实现。 以上是想法，实际上确实也很容易，上述两点的核心代码就是这样： self.setAttribute(Qt.WA_TranslucentBackground) # 透明效果 self.setWindowFlags(Qt.FramelessWindowHint | Qt.BypassWindowManagerHint | Qt.Tool | Qt.WindowStaysOnTopHint) # 无边框, 随主窗口关闭, 置顶 代码最后留一个演示代码~ # -*- coding: utf-8 -*- &quot;&quot;&quot; Author: mxy Email: mxy493@qq.com Date: 2020/12/3 Desc: Qt实现圆形加载动画 &quot;&quot;&quot; import sys from PySide2.QtCore import QTimer from PySide2.QtGui import QColor, QPainter, Qt from PySide2.QtWidgets import QMainWindow, QApplication, QPushButton, QWidget, QVBoxLayout class CircleLoadingAnimation(QWidget): &quot;&quot;&quot;加载动画 progress = CircleProgressBar(600) progress.start() # 开始显示加载动画 # do something ... progress.stop() # 停止显示 &quot;&quot;&quot; def __init__(self, size=100, color=QColor(24, 189, 155), clockwise=True): super().__init__() self.setAttribute(Qt.WA_TranslucentBackground) # 透明效果 self.setWindowFlags(Qt.FramelessWindowHint # 无边框 | Qt.BypassWindowManagerHint | Qt.Tool # 随父窗口关闭 | Qt.WindowStaysOnTopHint) # 置顶 self.setFixedSize(size, size) self.angle = 0 self.clockwise = clockwise # 顺时针方向 self.Color = color # 圆圈颜色 self.delta = 36 self._timer = QTimer(self, timeout=self.update) # 计时器，定时刷新界面 def start(self): self._timer.start(100) # 0.1s更新刷新一次界面 self.show() # 显示动画窗口 def stop(self): self._timer.stop() # 停止计时器 self.close() # 关闭动画窗口 def paintEvent(self, event): qp = QPainter(self) qp.setRenderHint(QPainter.Antialiasing) qp.translate(self.width() / 2, self.height() / 2) side = min(self.width(), self.height()) qp.scale(side / 100.0, side / 100.0) qp.rotate(self.angle) qp.save() qp.setPen(Qt.NoPen) color = self.Color.toRgb() for i in range(11): color.setAlphaF(1.0 * i / 10) qp.setBrush(color) qp.drawEllipse(30, -10, 20, 20) qp.rotate(36) qp.restore() self.angle += self.delta if self.clockwise else -self.delta self.angle %= 360 class MainWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(&#x27;加载动画Demo&#x27;) self.setFixedSize(400, 400) self.progress = CircleLoadingAnimation() # 实例化一个加载动画 self.btn = QPushButton(&#x27;开始/结束 显示加载动画&#x27;) self.btn.clicked.connect(self.show_animation) vbox = QVBoxLayout() vbox.addWidget(self.btn) widget = QWidget() widget.setLayout(vbox) self.setCentralWidget(widget) def show_animation(self): if self.progress.isVisible(): self.progress.stop() else: self.progress.start() if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) window = MainWindow() window.show() sys.exit(app.exec_()) Demo","categories":[{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/categories/Qt/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"},{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/tags/Qt/"}]},{"title":"我的 Python 笔记","date":"2020-11-16","updated":"2022-03-23","path":"2020111660580/","text":"一些实际开发中总结的 Python 经验~ 获取字典的值d = &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125; 一般我们会直接用 d[&#39;a&#39;] 获取字典的值，但是如果不小心写了 d[&#39;c&#39;] ，字典中并没有 &#39;c&#39; 的键，就会报错。 更好的方法是使用 get() 方法~ a = d.get(&#x27;a&#x27;) # a = 1 c = d.get(&#x27;c&#x27;) # 不存在键&#x27;c&#x27;, c = None d = d.get(&#x27;d&#x27;, 0) # 不存在键&#x27;d&#x27;, d = 0, 第二个参数为当键不存在的时候的默认返回值 读、写或删除文件、文件夹读、写或删除文件、文件夹前先判断其是否存在！ import os p = &#x27;test.txt&#x27; if os.path.exist(p): os.remove(p) # 删除该文件 os.path 官方文档：https://docs.python.org/zh-cn/3.8/library/os.path.html 几个常用的接口： # os库 os.path.exist(p) # 判断文件或文件夹p是否存在 os.path.isfile(p) # p是文件? os.path.isdir(p) # p是文件夹? os.path.abspath(p) # 将相对路径p转为绝对路径 os.remove(p) # 删除文件p, 不能用于删除文件夹 os.rmdir(p) # 删除文件夹p, 文件夹必须为空 # shutil库 shutil.rmtree(p) # p为文件夹，递归地删除p及其内部所有文件 尽量处理可能发生的异常处理异常当然是应该的，否则一旦程序运行中出现异常就会导致程序无法继续运行~ 几点经验： 尽量用 if 判断替代异常处理。尽可能避免异常的出现； 尽可能小范围的捕获异常。尽量避免使用 BaseException ； 如果捕获了异常，建议将错误信息打印出来方便调试。 重试机制times = 3 while times &gt; 0: # do something times -= 1 超时机制超时处理应该是比较常用的一种逻辑，比如重试机制。 t = time.time() while True: # do something if time.time() - t &gt; 3: break # 超时3s则跳出循环 单例模式class MyClass: _instance = None # 唯一实例 def __new__(cls, *args, **kw): if cls._instance is None: cls._instance = object.__new__(cls) return cls._instance 多线程Python 中多线程一般使用 threading 库，官方文档：https://docs.python.org/zh-cn/3/library/threading.html。 具体使用方法就不细说了，这里主要说一下用装饰器来封装一个多线程方法，如下，然后后续任何需要多线程执行的方法都只需要在定义前加上 @thread_runner 即可，非常方便~ def thread_runner(func): def wrapper(*args, **kw): threading.Thread(target=func, args=args, kwargs=kw).start() return wrapper 使用： @thread_runner def new_thread(): while True: # do something 线程之间的通信在 Python 中多线程之间的通信我了解并使用了两种~ 使用线程安全的队列类 queue 以较常用的先进先出队列类 queue.Queue 为例，只要在作用于范围内，不同线程之间都可以正常的入队和出队。 import queue pipe = queue.Queue() # 先进先出的队列 pipe.push(obj) # 将obj存到队列尾 pipe.get() # 获取队列首部的对象 在类的某个线程方法中使用类的属性 我常使用此方法来终止线程~ class MyThread: def __init__(): self.run = False @thread_runner def run_thread(self): self.run = True while self.run: # do something def stop(self): self.run = False if __name__ == &#x27;__main__&#x27;: thread = MyThread() thread.run_thread() # 启动线程 # do something thread.stop() # 停止线程 字符串格式化字符串拼接的方法很多，比如说使用 + 运算符，或者使用 format(value[, format_spec]) 函数，但我个人认为最方便好用的是 f-string ，只需要在普通字符串前加一个 f ，在需要插入变量值的地方用大括号 &#123;&#125; 包裹变量即可，甚至都不需要使用 str() 将变量转为字符串。示例： d = 3.14 string = f&#x27;PI is approximately equal to &#123;d&#125;.&#x27;","categories":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"}]},{"title":"我的 Qt for Python 笔记","date":"2020-11-12","updated":"2022-03-23","path":"2020111210053/","text":"盒子布局官方文档：https://doc.qt.io/qtforpython/PySide2/QtWidgets/QGridLayout.html grid = QGridLayout() # 实例化一个格子布局 比较常用的几个函数： def addLayout (arg__1, row, column, rowSpan, columnSpan[, alignment=Qt.Alignment()]) def addLayout (arg__1, row, column[, alignment=Qt.Alignment()]) def addWidget (arg__1, row, column, rowSpan, columnSpan[, alignment=Qt.Alignment()]) def addWidget (arg__1, row, column[, alignment=Qt.Alignment()]) 实际使用中一般是这样： grid.addLayout(hbox, 0, 0) # 第一行第一列，占一个单元格 grid.addWidget(w1, 0, 1) # 第一行第二列，占一个单元格 grid.addWidget(w2, 1, 0, 1, 2) # 第二行第一列，占一行两列 上面的代码，实际构造出来的 grid 就是一个两行两列的格子，只不过第二行的两列是合并为了一个单元格。 还有两个很重要的函数： def setColumnStretch (column, stretch) def setRowStretch (row, stretch) 用于设置某一行（列）的宽（高）度占比，如果使用这个函数理论上就应该为每一行（列）进行设置，否则默认的占比为 0 ，就可能导致某一行（列）无法显示。例如上述二行二列的格子： grid.setColumnStretch(0, 1) # 第一列占比1/3 grid.setColumnStretch(1, 2) # 第一列占比2/3 删除组件事实上删除组件是不支持的~Qt没有任何有关删除某个组件的接口函数！ 但组件是可以显示或隐藏的，想想其实隐藏可能也更好一些~ widget.setVisiable(b) # 传入bool量用于显示或隐藏 实际开发中，一个组件隐藏后只是看不见，但它还是占空间的。之所以想要删除组件其实也是为了让它不再占用空间，不过虽然没有删除组件的功能，但仍然可以通过隐藏实现同样的效果。 这就需要借助横向盒子布局或者纵向盒子布局（格子布局理论上也是可以的，但需要限制其独占一行或一列），不管是哪种布局，默认的拉伸因子都是 0 ，以如下代码为例： hbox = QHBoxLayout() hbox.addWidget(w1, 1) # 添加组件w1，拉伸因子为1 hbox.addWidget(w2, 1) # 添加组件w2，拉伸因子为1 也可以通过以下函数设置某一组件或子布局的拉伸因子： PySide2.QtWidgets.QBoxLayout.setStretchFactor(l, stretch) # 设置子布局的拉伸因子 PySide2.QtWidgets.QBoxLayout.setStretchFactor(w, stretch) # 设置组件的拉伸因子 如果需要隐藏某组件并使其不再占据空间，只需要两步，以 w1 为例： w1.setVisiable(False) # 隐藏组件w1 hbox.setStretchFactor(w1, 0) # 设置w1所在的盒子占比为0 多线程 QThread在我使用 Qt for Python 编程的过程中需要用到多线程，在 Python 中是使用 threading 库，使用起来还是很简单的，但最初自以为 Qt 也一样，但发现其实不想，没有作用甚至会报错，简单说就是与 Qt 相关的代码要使用多线程都应该使用 Qt 提供的多线程类 QThread 。 class MyThread(QThread): def __init__(self): self.running = False def run(self): self.running = True while self.running: # do something def stop(self): self.running = False 框架如上，首先自定义一个线程类并继承自 QThread ，然后我定义了一个属性 running 用于控制线程的终止，run() 方法是重写的 QThread 中的方法，实际线程中的逻辑应该放到 run() 方法中去执行 。启动线程需要先实例化一个线程对象，然后调用 QThread 的 start() 接口函数即可启动线程。示例： thread = MyThread() # 实例化线程对象 thread.start() # 启动线程 # do something thread.stop() # 终止线程 窗口大小自适应虽然当前的电脑都在往着屏幕更大、分辨率更高的方向发展，但一款软件开发出来也难免可能会在一些老旧低分辨率的电脑上使用，所以如见如果可以自适应不同大小的屏幕，用户体验会更好。 以下代码独特之处在于对于小屏幕，窗口将默认最大化显示，且窗口大小不可调整。这样设置的目的是为了在小屏幕上尽可能完整的显示软件界面，否则软件界面超出了屏幕的可视范围或者被任务栏遮挡，用户体验就会很差~ class MainWindow(QMainWindow): def __init__(self): super().__init__() # 此处省略一万字... screen = QDesktopWidget().screenGeometry(self) # 获取整个屏幕的大小 available = QDesktopWidget().availableGeometry(self) # 除去任务栏的区域大小 title_height = self.style().pixelMetric(QStyle.PM_TitleBarHeight) # 窗口顶栏高度 # 如果屏幕太小则默认窗口最大化且不可改变大小 if screen.width() &lt; 1280 or screen.height() &lt; 768: self.setWindowState(Qt.WindowMaximized) # 窗口最大化显示 self.setFixedSize(available.width(), available.height() - title_height) # 固定窗口大小 # 否则设置一个最小宽高，窗口大小可调整 else: self.setMinimumSize(QSize(1000, 800)) # 最小宽高 self.show() # 显示窗口 Qt 其实是有让窗口全屏的函数的，例如上述代码中的 show() 函数是显示窗口，如果设置了窗口大小则按设置的大小显示，事实上 Qt 提供了以下一些显示窗口的函数： def show() # 显示方式取决于WindowState等其它一些因素 def showFullScreen() # 全屏显示，会遮挡任务栏 def showMaximized() # 最大化显示，但直接使用用户仍然可以将窗口调小 def showMinimized() # 最小化显示 def showNormal() # 正常显示 自定义信号Qt for Python 中自定义信号首先需要注意一点，PyQt5 和 PySide2 中定义信号的类名不一样！ 在 PySide2 中应该使用 Signal() ，而在 PyQt5 中应使用 pyqtSignal() ，用法上其实没什么区别。 以下示例代码采用 PySide2 方式： class MainWindow(QMainWindow): # 自定义信号 signal1 = Signal() # 无参的信号 signal2 = Signal(int) # 传递一个int型参数的信号 signal3 = Signal(int, str) # 传递一个int型参数和一个str型字符串的信号 def __init__(self): super().__init__() # 绑定信号与槽 self.signal1.connect(self.slot1) self.signal2.connect(self.slot2) self.signal3.connect(self.slot3) # 定义槽函数 def slot1(self): # do something pass def slot2(self, num): # do something pass def slot3(self, num, string): # do something pass def test(self): # 触发信号 self.signal1.emit() self.signal2.emit(123) self.signal3.emit(123, &#x27;123&#x27;) 使用信号与槽还应特别注意它们的作用域以及生命周期。一般需要将信号定义为 Qt 对象的属性，槽函数定义为 Qt 对象的方法，也就是说信号与槽的生命周期将跟随对象的生命周期（可能是必须这样做，暂时没找到相关资料）~ QSpinBox 限制用户输入QSpinBox 有好几个分类，这里以一般的 QSpinBox 为例，首先简要列举几个常用的接口函数： def setPrefix(prefix) # 设置前缀，例如￥ def setRange(min, max) # 设置范围 def setSingleStep(val) # 设置单步不长 def setSuffix(suffix) # 设置后缀，例如m def value() # 获取当前的值 def setValue(val) # 槽函数，设置值为val def valueChanged(arg__1) # 信号，值改变触发 使用上述的接口函数已经满足了大部分的需求，但假如我想创建一个 QSpinBox ，范围为 0 ~ 10 ，步长为 2 ，也就是 0 ~ 10 内的偶数，很容易，只需要： self.spin = QSpinBox() self.spin.setRange(0, 10) self.spin.setSingleStep(2) 实际上，用户点击增减的按钮确实是没问题的，但如果用户手动输入，仍然可输入 0 ~ 10 范围内的奇数，就很尴尬~ 不过稍微处理一下也是可以解决的，办法就是利用信号与槽，当值改变为奇数的时候，就自动将其修改为临近的值。 # 绑定信号与槽 self.spin.valueChanged.connect(self.standardization) # 定义槽函数 def standardization(self): val = self.spin.value() if val % 2 == 1: self.spin.setValue(val - 1) # 如果是奇数就-1 使用 paintEvent 绘制我目前所了解到的要在 Qt 界面上动态绘制图案，就应该重写 paintEvent() 函数，在其内部编写具体的绘制逻辑，实际上 paintEvent() 是一个槽函数，触发的方式包括窗口大小、位置的改变，以及主动的调用 update() 或 repaint() 接口。 repaint() 会在调用的时候立即刷新界面，及时性比较好，但考虑界面并没有什么变化却又一直在刷新的情况，就会产生很大的消耗，严重的情况下会导致界面卡死； update() 是官方也推荐使用的刷新方法，区别是 update() 不会立即刷新界面，而是等到界面真正有变动的时候才刷新一次，可能实时性略差一些，但也满足绝大部分的需求了。 def paintEvent(self, event): qp = QPainter() qp.begin(self) self.draw(qp) # 绘制的具体逻辑 qp.end() 处理关闭事件程序关闭前一般需要做一些处理，比如未结束的线程应当先结束，或者说需要保存一些参数，这些工作就可以放到 closeEvent() 参函数中进行处理~ def closeEvent(self, event): if self.thread.is_running(): self.thread.stop() # 停止未结束的线程 self.save_data() # 保存一些数据 # 自定义的用于控制程序是否可关闭的bool量 if self.can_close: event.accept() # 关闭程序 else: event.ignore() # 拒绝关闭程序 使用自定义字体注意字体文件的路径就可以了！ QFontDatabase.addApplicationFont(&#x27;font/SourceCodePro-Regular.ttf&#x27;) # 自定义字体 self.log_widget.setStyleSheet(&#x27;font: 14px Source Code Pro&#x27;) # 设置某组件要使用的字体","categories":[{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/categories/Qt/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"},{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/tags/Qt/"}]},{"title":"OpenCV 获取摄像头数量","date":"2020-11-06","updated":"2022-03-23","path":"2020110641390/","text":"简述最近使用 opencv-python ，主要需要打开摄像头显示画面，但是就遇到个很尴尬得问题，当一台电脑有多个摄像头的时候，怎么选择打开对应的某一个摄像头呢？ 一般我们回想既然 OpenCV 提供了打开某一个摄像头的接口，那应该也会有查看多有摄像头设备的接口函数可以直接调用吧~至少我是这么想的，但事实上，查了一圈，似乎并没有相关的接口可以调用。 网上也有一些解决方案，思路很简单。 OpenCV 打开摄像头的接口函数是这样的： retval = cv.VideoCapture.open(index[, apiPreference]) 使用起来很简单，传入一个摄像头序号 index （ 0 为系统默认摄像头），打开对应序号的摄像头，打开成功的话返回 true ，否则 false 。 注意：通过 open() 或者直接调用构造函数打开的摄像头，一定要记得使用 release() 函数关闭！ 方案一所以很容易想到，从 0 开始一个一个试看能打开多少个摄像头，不久知道能使用的摄像头数量了嘛，确实是这样的，那上代码~ def get_camera_quantity() -&gt; int: &quot;&quot;&quot;获取可用摄像头数量&quot;&quot;&quot; quantity = 0 cap = cv2.VideoCapture() # 视频流对象 index = 0 # 一般一台电脑连接的摄像头数量不会超过5个 # 普遍情况下最多两个 while index &lt; 5: ret = cap.open(index) if ret: quantity += 1 # 可用摄像头数量+1 cap.release() # 释放打开的摄像头 index += 1 # 索引+1 else: break # 一旦遇到打开失败的序号，则没有更多的摄像头了 return quantity 是吧，很容易的~ 但是，但是，但是，我在写这个代码之前就想到过一个问题，调用 open() 函数打开摄像头是会真正打开摄像头的，而这个过程相对来说是很耗时间的。实际上面代码我也测试过，我手上两个摄像头，一个就普通一米长的线，另一个奇葩的怕是有10米长的线……多次测试前者打开基本在 0.5s 内，而后者则是反人类的 8s 有余……换言之，上面的代码会尝试打开这两个摄像头，至少要耗时 8s 才能返回结果，我认为是无法接受的龟速！ 事实上也是在上面测试的过程中，发现后续 3 个无法打开的索引，其实返回结果是相对很快的，基本就是 1ms 。 补一个测试时间： 8.240961074829102 0.05086374282836914 0.002992391586303711 调用三次，第一次成功打开线变态长的摄像头，耗时超 8s ，第二次耗时 50ms 打开了另一个摄像头，第三次打开失败仅耗时 3ms 。 方案二那就对了，换个方向反着来岂不是好太多了，先尝试打开较大的序号，因为一般情况下摄像头数量不会超过 3 个，这里设置对 5 个索引进行试探已经算是考虑了比较特殊的情况了。 于是写出来下面的代码： def get_camera_quantity() -&gt; int: &quot;&quot;&quot;获取可用摄像头数量&quot;&quot;&quot; quantity = 0 cap = cv2.VideoCapture() # 视频流对象 index = 4 while index &gt;= 0: t0 = time.time() ret = cap.open(index) print(time.time() - t0) if ret: quantity = index + 1 cap.release() break index -= 1 return quantity 还是以我的两个摄像头为例，从 4 到 0 一个一个试探，显然后面三个序号都会打开失败，但耗时很少，下面某一次实测的 open() 函数的调用耗时： 0.0069806575775146484 0.000997781753540039 0.0019943714141845703 0.16755270957946777 首先可以看到， open() 函数仅调用 4 次，也就是说遇到第一个能打开的摄像头之后就跳出循环了，并不会尝试打开所有可用的摄像头。而且前面也说了，我两个摄像头，一个打开很快，另一个基本上要 8s 以上才能打开，所以从上面的测试结果也可以看到，运气比较好，索引为 1 的摄像头恰好是打开比较快的那个，只用了 0.16s 就打开成功了，第一次调用尽管耗时相对多一些也仅仅是 7ms ，另外两次打开失败都是 1~2ms ，相比起方案一中 8s 起步的耗时是不是就友好太多了！ 最后的最后最后的最后呢，可能会有这样的疑惑，因为我有，就是前面代码中通过 open() 打开的摄像头都要通过 release() 关闭，否则会占用摄像头导致其它应用无法使用这个摄像头，那么针对本文讨论的获取摄像头的数量，如果摄像头已经被别的应用打开了，那调用 open() 函数还能成功打开摄像头并返回 true 吗？ 实验是检验真理的唯一标准，我测试过了，答案是可以的！ 测试方法很简单嘛，虽然找个别的软件把摄像头打开，再执行上面的函数，完全没问题，会返回正确的结果。不过还是别认为这个摄像头就可用了，尝试使用 read() 函数获取帧的话，是获取不到的~ 到现在，至少我们的目的达到了，成功获取到了摄像头的数量~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://mxy493.xyz/tags/OpenCV/"}]},{"title":"使用 opencv-python 实现视频录制","date":"2020-11-05","updated":"2022-03-23","path":"2020110560199/","text":"代码实现先直接上代码吧~ OpenCV 在 Python 中的库名叫 opencv-python ，另外导入的时候是导入 cv2 。 # -*- coding: utf-8 -*- import cv2 # 导入opencv-python库 cap = cv2.VideoCapture(0) # 打开系统默认摄像头 fourcc = cv2.VideoWriter_fourcc(&#x27;X&#x27;, &#x27;V&#x27;, &#x27;I&#x27;, &#x27;D&#x27;) # XVID MPEG-4 out = cv2.VideoWriter() # 写入器，打开摄像头后再初始化 while True: ret, frame = cap.read() # 读取一帧画面 if ret: if not out.isOpened(): h, w, _ = frame.shape # 读取到的帧的宽高 out.open(filename=&#x27;record.avi&#x27;, fourcc=fourcc, fps=30, # 大约33ms一帧 frameSize=(w, h)) # 初始化写入器 else: out.write(frame) cv2.imshow(&quot;frame&quot;, frame) # 显示画面 if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;): break time.sleep(0.033) # 等待33ms再读写一帧画面 out.release() # 释放视频写入器 cap.release() # 释放摄像头 cv2.destroyAllWindows() # 关闭窗口 读取帧OpenCV 中用于处理视频流有两个类：cv::VideoCapture 和 cv::VideoWriter ，前者用于获取已有的视频数据，后者用于写入。 详细接口说明请参考官方文档：https://docs.opencv.org/master/dd/de7/group__videoio.html 首先录制视频肯定要先把摄像头打开，所以第一步需要先实例化一个 cv::VideoCapture 类的对象，在 Python 中有如下几种方式： &lt;VideoCapture object&gt; = cv.VideoCapture() &lt;VideoCapture object&gt; = cv.VideoCapture(filename[, apiPreference]) &lt;VideoCapture object&gt; = cv.VideoCapture(index[, apiPreference]) 简单说就是你可以先不带参数实例化一个捕获对象，也可以传入本地的视频文件名用以初始化捕获对象，还可以使用摄像头的索引（0 为系统的默认摄像头）来实例化捕获对象，例如上面代码中由于只需要打开默认摄像头，所以直接使用 0 初始化了捕获器。 除了第一种方式外，其它两种方式在初始化的同时也把捕获器打开或者说是激活了，而如果使用了第一种方式实例化捕获器对象，后续也是可以使用 open() 函数打开相应的视频流的。 retval = cv.VideoCapture.open(filename[, apiPreference]) # 传入视频文件名，打开视频文件 retval = cv.VideoCapture.open(index[, apiPreference]) # 传入摄像头索引，打开摄像头 在程序一次运行中需要切换视频源的情况下，通常会使用这种先实例化对象，后打开视频源的方式。 下一步显然就是最核心的读取帧。读取帧相关的接口有以下3个，实际使用中一般只用 read() ： retval = cv.VideoCapture.grab() # 抓取帧，并未解码 retval, image = cv.VideoCapture.read([, image]) # grab() 和 retrieve() 的结合，抓取、解码并返回 retval, image = cv.VideoCapture.retrieve([, image[, flag]]) # 解码并返回已抓取的帧 通常在使用 read() 抓取一帧画面后，我们会通过 if retval: 判断是否抓取到了一帧画面，然后再对抓取到的 image 作进一步的处理。返回的 image 是一个三维数组，可以通过 shape 属性获取该帧的宽、高、位深度，RGB的图片位深度一般为 3 ，即对应的RGB三个通道的值，有时候会遇到位深度为 4 的情况，则第四维为透明度，也就是 alpha 通道。 h, w, d = image.shape # (480, 640, 3) 分别为帧的高度、宽度、深度 获取到帧后，更多的就是自定义的操作了，比如对于一个视频而言，光读取一帧肯定是没有太大意义的，要快速重复的读取帧并显示出来，才能是我们能看到的视频，否则就只是一张图片，这里就可以加一个循环用于重复的读取帧。如果是读取的视频文件，还需要根据视频文件的帧率，间隔合适的的时间再重复读取一帧，否则看到的画面速度将会非常快。 当然最后使用结束后还需要释放捕获器，否则在程序退出之前会一直占用该资源，比如说打开的摄像头，如果没有释放，则除非关闭程序后系统自动收回资源，在程序运行期间其它的应用程序是无法使用该摄像头的。 None = cv.VideoCapture.release() 到这里，是不是简单改改上面的代码就可以实现打开摄像头并显示画面了，只不过还不能将视频画面录制保存下来。 录制类似上述捕获器的流程，要将一帧帧画面保存为视频首先也需要实例化一个写入器对象。 &lt;VideoWriter object&gt; = cv.VideoWriter() &lt;VideoWriter object&gt; = cv.VideoWriter(filename, fourcc, fps, frameSize[, isColor]) &lt;VideoWriter object&gt; = cv.VideoWriter(filename, apiPreference, fourcc, fps, frameSize[, isColor]) &lt;VideoWriter object&gt; = cv.VideoWriter(filename, fourcc, fps, frameSize, params) &lt;VideoWriter object&gt; = cv.VideoWriter(filename, apiPreference, fourcc, fps, frameSize, params) 参数说明： filename：文件名，录制的视频文件名，会自动创建； fourcc：格式； fps：帧率，大于30一般认为人眼就看不出来了； frameSize：帧大小，视频画面的宽高。 首先要谈到的是 fourcc 这个参数，我个人完全谈不上明白，简言之就是视频的格式吧，比如说我们常见的视频格式有 .mp4 、 .avi 等，可设置的值很多，可以查阅 fourcc 官网：https://www.fourcc.org/codecs.php 。需要注意并不是所有格式都可用，使用的时候可以自己根据情况查询使用哪种格式。 retval = cv.VideoWriter_fourcc(c1, c2, c3, c4) # 传入对应的4个字符 可以看到参数中需要传入 frameSize ，这正是我之所以在前面代码中并没有直接实例化并初始化一个写入器对象，而是先实例化一个空对象，后续获取到一帧画面后，再根据获取到的帧的宽高设置写入器要写入的帧大小。 接下来就只需要将获取到的帧写入到视频文件了，使用 write() 接口即可。 None = cv.VideoWriter.write(image) 这里不得不再提一下 fps 这个参数，可以看到最终视频的帧率是我们一开始初始化写入器时设置的，可以发现实际上最终视频的时长将取决于我们设置的帧率和实际写入的帧数，而这也就表明了一个问题，我们通过摄像头录制的视频很可能会速度不匹配。 例如上面的代码，如果将循环内部最后一行注释掉，读取一帧可能只需要 1ms ，而我们设置的 fps=30 表明最终的视频会大约 33ms 播放一帧画面，显而易见最终的视频文件将会是慢动作一样🤣 最理想的情况是读取的帧率和写入的帧率一致，这样视频时长才会一致，同时尽可能提高帧率，画面也就越流畅。 所以这一行的作用就是，每读取和写入一帧都需要在这里等待 33ms ，这样情况就好太多了。但最终你会发现，视频时长还是有些不一致，原因主要就是读取和写入的耗时了，虽然这两步操作可能分别都只需要 1ms ，但对于一个时长 1 分钟的视频，就会存在明显的时长不一致。 进一步的降低误差，还可以将读写操作分离，分别放到两个线程中处理。或者简单的在等待时长的基础上减去读写操作的消耗，也能一定程度上降低误差~","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"https://mxy493.xyz/tags/OpenCV/"}]},{"title":"Leetcode 925. 长按键入【C++】","date":"2020-10-21","updated":"2022-03-23","path":"2020102136991/","text":"地址：https://leetcode-cn.com/problems/long-pressed-name/ 题目你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。 你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。 示例 1： 输入：name = &quot;alex&quot;, typed = &quot;aaleex&quot; 输出：true 解释：&#x27;alex&#x27; 中的 &#x27;a&#x27; 和 &#x27;e&#x27; 被长按。 示例 2： 输入：name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot; 输出：false 解释：&#x27;e&#x27; 一定需要被键入两次，但在 typed 的输出中不是这样。 示例 3： 输入：name = &quot;leelee&quot;, typed = &quot;lleeelee&quot; 输出：true 示例 4： 输入：name = &quot;laiden&quot;, typed = &quot;laiden&quot; 输出：true 解释：长按名字中的字符并不是必要的。 提示： name.length &lt;= 1000 typed.length &lt;= 1000 name 和 typed 的字符都是小写字母。 解题思路很明显的双指针问题，思路倒是很简单，倒是提交了好几次没通过，总是没除了好一些特殊情况。 是的，这个题我认为能把所有特殊情况处理好比双指针解题这个思路更难一些，比如判断字符串 typed 中的字符是长按输入的还是正常输入的，两个字符串的末尾的处理，需要注意不能简单遍历完 name 就结束，当 name 遍历完且所有字符都匹配后不一定就符合题意了，如果 typed 末尾还存在未遍历到且和 name 最后一个字符不相同的字符，事实上是不符合的，例如 name = &quot;adc&quot;, typed = &quot;abccd&quot; 这种情况。同样也不能遍历完了 typed 而没有遍历完 name 。 关于双指针的解题思路请参考官方题解。 代码class Solution &#123; public: bool isLongPressedName(string name, string typed) &#123; int i = 0, j = 0; while (j &lt; typed.length()) &#123; // 注意此处需要判断i的范围 if (i &lt; name.length() &amp;&amp; name[i] == typed[j]) &#123; i++; j++; &#125; // 注意typed首字符的特殊情况 else if (j &gt; 0 &amp;&amp; typed[j] == typed[j - 1]) &#123; j++; &#125; else &#123; return false; &#125; &#125; return i == name.length(); &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 844. 比较含退格的字符串【C++】","date":"2020-10-19","updated":"2020-10-19","path":"202010199862/","text":"地址：https://leetcode-cn.com/problems/backspace-string-compare/ 题目给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。 注意：如果对空文本输入退格字符，文本继续为空。 示例 1： 输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot; 输出：true 解释：S 和 T 都会变成 “ac”。 示例 2： 输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot; 输出：true 解释：S 和 T 都会变成 “”。 示例 3： 输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot; 输出：true 解释：S 和 T 都会变成 “c”。 示例 4： 输入：S = &quot;a#c&quot;, T = &quot;b&quot; 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示： 1 &lt;= S.length &lt;= 200 1 &lt;= T.length &lt;= 200 S 和 T 只含有小写字母以及字符 &#39;#&#39;。 进阶： 你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？ 解题思路起初也没想到什么新颖的思路，就直接模拟真实删除操作把对应字符删除掉再比较两个字符串，很容易就写出来了~ 但总觉得应该有什么更好的方法，又想不到，所以取 Leetcode 的题解，官方题解给出了两种方法，第一种其实原理相同，只不过使用了栈，这一点确实比删除字符更好一些，下面的代码虽然没有用栈，但也相当于模拟了一个栈的结构。 另一种方法则是双指针，起初我也有想到过同时遍历两个字符串来进行比较，但感觉并不是很好处理，即便是看了官方题解之后我也没打算将本题使用双指针来求解，我个人认为双指针求解逻辑复杂了不少，代码也更加难以看懂，所以我觉得并不是很必要。 代码class Solution &#123; public: string process(const string&amp; str) &#123; string s = &quot;&quot;; int count = 0; for (int i = str.length() - 1; i &gt;= 0; i--) &#123; if (str[i] == &#x27;#&#x27;) &#123; count++; &#125; else if (count &gt; 0) &#123; count--; &#125; else &#123; s = str[i] + s; &#125; &#125; return s; &#125; bool backspaceCompare(string S, string T) &#123; return process(S) == process(T); &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"KMP字符串匹配算法之C++实现","date":"2020-10-17","updated":"2020-10-17","path":"2020101714621/","text":"简述如标题所言，KMP 是一种字符串匹配算法，我也是偶然了解到的。 关于这个算法更详细的内容请参考阮一峰的博文：字符串匹配的KMP算法 要说字符串匹配，在不知道什么算法的情况下，很容易想到写一个两层循环来遍历，思路很简单，也很容易实现，不过效率却不怎么样。 很巧的是，这个题我真就在一次笔试还是面试中遇到了，当时我隐约记得有一个字符串匹配算法之前有看过，但又想不起来，最后还是无赖两层循环暴力解…… 所以现在来重新好好理一理这个 KMP 算法~ C++实现关于算法的内容此处不赘述了，建议阅读阮一峰大大的博文，讲的非常清楚！ 在我的实现中，我将整个 KMP 算法分为了两部分，一部分是生成要匹配的子串的部分匹配表，另一部分则是根据部分匹配表进行匹配。 同时我将所有匹配到的位置用一个 vector&lt;int&gt; 类型的数组保存并返回。如果只需要匹配第一个即可，那么可以在匹配到一个字串之后就跳出循环并返回结果。 // 对KMP算法的C++实现 // KMP算法：http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; using namespace std; // 获取字符串的部分匹配表 unique_ptr&lt;int[]&gt; GenPartialMatchTable(string&amp; str) &#123; size_t len = str.length(); unique_ptr&lt;int[]&gt; table(new int[len]); // 申请动态数组，元素未定义 size_t i, j; for (i = 0; i &lt; len; i++) &#123; table[i] = 0; // 初始化动态数组的元素 for (j = 1; j &lt;= i; j++) &#123; if (str.substr(0, j) == str.substr(i - j + 1, j)) &#123; table[i] = j; // 更新部分匹配值使其取较大值 &#125; &#125; &#125; return table; &#125; // 查找字符串匹配的位置 vector&lt;int&gt; kmp(string&amp; str, string&amp; sstr) &#123; vector&lt;int&gt; vec; // 返回所有匹配到的子串的位置 unique_ptr&lt;int[]&gt; table = GenPartialMatchTable(str); // 函数结束后自动销毁。移动构造函数，接管源对象 size_t i = 0, j = 0; for (i; i &lt; sstr.length(); i++) &#123; for (j; j &lt; str.length(); j++) &#123; if (sstr[i + j] != str[j]) &#123; if (j != 0) &#123; int step = j - table[j - 1]; // 移动位数 = 已匹配的字符数 - 对应的部分匹配值 i += step - 1; // 移动j位，外循环还会+1 j = table[j - 1]; &#125; break; &#125; &#125; // 当且仅当字符串完全匹配后 j 与要匹配的字符串的长度相等 if (j == str.length()) &#123; vec.push_back(i); j = 0; // 重新初始化为0 &#125; &#125; return vec; &#125; int main() &#123; string str = &quot;ABCDABD&quot;; // 要匹配的子串 string sstr = &quot;BBC ABCDAB ABCDABDABDE&quot;; // 用于匹配子串的字符串 vector&lt;int&gt; vec = kmp(str, sstr); for (size_t i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; endl; &#125; return 0; &#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://mxy493.xyz/tags/%E7%AE%97%E6%B3%95/"},{"name":"KMP","slug":"KMP","permalink":"https://mxy493.xyz/tags/KMP/"}]},{"title":"小米一面 - 编程题: 字符串变形","date":"2020-10-16","updated":"2020-10-16","path":"2020101629465/","text":"字符串变形 限定语言：Python、C++、Javascript、C#、Java 对于一个给定的字符串，我们需要在线性（也就是O(n)）的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像”Hello World”一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如 “Hello World” 变形后就变成了 “wORLD hELLO” 。 输入描述 给定一个字符串s以及它的长度n(1≤n≤500) 输出描述 请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。 示例1 输入： &quot;This is a sample&quot;,16 输出： &quot;SAMPLE A IS tHIS&quot; 解题思路面试官给了14分钟的时间，一开始有点慌，也不知道14分钟能写成什么样，事实上看了题目之后，感觉这题应该是做过~ 也没时间多想什么比较好的解题思路，就开始动手写了，其实主要就涉及两个操作，一个是字母大小写之间的转换，一个是单词之间的划分。 实际面试的过程中，我一开始还没想好怎么把单词划分出来并逆序，但是想着大小写转换这一步总是没影响的，就直接遍历字符串，遇到字母就转换一下。很尴尬的是我竟然没记起大小写字母之间的差值是多少，稀里糊涂写了个33（其实是32），最后面试官也问到了，我说我没记起来，他就问，那有没有办法可以得到这个值呢？一点就通，&#39;a&#39; - &#39;A&#39; 不就可以了嘛，当然这是在不知道的情况下确实可以这么做，但知道的情况下直接写32当然最好了。 然后是提取单词并逆序的问题，面试中我定义了一个 vector&lt;string&gt; 用来保存提取的每一个单词，最后再合并，确实是可行的，但事实上面试结束后我再看这个题目，题目要求在“线性”的时间里完成，也就是不能再写一个循环了。 最终的代码修改为了下面这样，用两个索引分别标志单词的开始和结束，遍历的过程中每当遇到空格，就表明提取到了一个单词，在输入的字符串末尾附加一个空格以避免对最后一个单词进行特殊处理，同样在构造逆序的字符串的过程中也不对第一个单词做特殊处理，逆序完成后再删除末尾多余的一个空格即可。 代码#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() &#123; string str; // 输入的字符串 getline(cin, str); // 输入一行 int n; // 输入的字符串长度 cin &gt;&gt; n; str += &quot; &quot;; // 末尾添加一个空格以避免对最后一个单词做特殊处理 string rev = &quot;&quot;; // 转换后的字符串 size_t i = 0, j = 0; for (i; i &lt;= n; i++) &#123; if (str[i] &gt;= &#x27;A&#x27; &amp;&amp; str[i] &lt;= &#x27;Z&#x27;) &#123; str[i] += 32; &#125; else if (str[i] &gt;= &#x27;a&#x27; &amp;&amp; str[i] &lt;= &#x27;z&#x27;) &#123; str[i] -= 32; &#125; else &#123; rev = str.substr(j, i - j) + &quot; &quot; + rev; j = i + 1; // +1位空格 &#125; &#125; rev.erase(rev.end()); // 删除第一个单词多添加的空格 cout &lt;&lt; rev &lt;&lt; endl; return 0; &#125;","categories":[],"tags":[]},{"title":"C++ 数组作为函数参数","date":"2020-10-14","updated":"2022-03-23","path":"202010144968/","text":"简述把数组作为函数参数其实是个很常见也比较基础的问题，但初学的话肯定很头疼，长时间没用可能也会忘掉~ 首先需要明确一点：下标运算符 [] 的优先级高于解引用运算符 * 。 关于运算符的优先级，可以参考这里：https://zh.cppreference.com/w/cpp/language/operator_precedence 分析两种传递方式方式一以下是分别将一维、二维、三维数组将作为函数参数传递第一种方式，即声明相同大小的数组类型： #include &lt;iostream&gt; using namespace std; // 一维数组作为参数 void array1d(int arr1[2]) &#123; cout &lt;&lt; typeid(arr1).name() &lt;&lt; endl; // 输出：int * __ptr64 &#125; // 二维数组作为参数 void array2d(int arr2[2][3]) &#123; cout &lt;&lt; typeid(arr2).name() &lt;&lt; endl; // 输出：int (* __ptr64)[3] &#125; // 三维数组作为参数 void array3d(int arr3[2][3][2]) &#123; cout &lt;&lt; typeid(arr3).name() &lt;&lt; endl; // 输出：int (* __ptr64)[3][2] &#125; int main() &#123; int arr1[2] = &#123; 1, 2 &#125;; array1d(arr1); int arr2[2][3] = &#123; &#123;1,2,3&#125;,&#123;3,4,5&#125; &#125;; array2d(arr2); int arr3[2][3][2] = &#123; &#123;&#123;1, 2&#125;, &#123;2, 3&#125;, &#123;3, 4&#125;&#125;,&#123;&#123;5, 6&#125;, &#123;6, 7&#125;, &#123;7, 8&#125;&#125; &#125;; array3d(arr3); return 0; &#125; 了解数组的初始化的话我们还可以省略多维数组第一维的大小，将二维、三维数组的形式参数写成如下形式，编译器会根据实际传入的数组大小确定第一维的大小： void array2d(int arr2[][3], int r, int n); void array3d(int arr3[][3][2], int r, int c, int a); 调试观察一下，可以知道上述数组定义并初始化后，一维数组 arr1 的类型为 int[2] ，二维数组 arr2 的类型为 int[2][3] ，三维数组 arr3 的类型为 int[2][3][2] 。 但传递到函数中后，形式参数的类型却分别变为了 int* 、 int[3] * 和 int[3][2] * 。 实际上也并不难理解，我们知道数组名其实就是指向数组第一个元素的指针，因此上面指针类型的形参其实就分别是： int* 指向 int 类型的指针，这里实际指向的是 int 型的一维数组； int[3] * 指向长度为3的 int 型数组的指针。虽然传入的是二维数组，但不变的是传入的是数组第一个元素的地址，对于一个二维数组即第一维的第一个数组的地址； int[3][2] * 指向数组中第一个元素，即3行2列的二维数组的指针。 更多维的情况也同理~ 方式二根据上述方式一调试分析的结论，我们既然知道了形参的实际类型，因此可以直接把形参声明为该类型： void array1d(int *arr1); // 一维 void array2d(int (*arr2)[3]); // 二维 void array3d(int (*arr3)[3][2]); // 三维 这种方式实际与方式一并没有什么区别，笔经数据类型都是完全一致的。 这里需要注意，不能把 int (*arr2)[3] 写成 int *arr2[3] ，原因就在于简述中谈到的运算符优先级的问题，这两种写法之间是有本质区别的，即指针数组和指向数组的指针之间的区别： int (*arr2)[3] 是指向数组的指针，本质上是指针，只不过指向的是一个长度为3的 int 型数组； int *arr2[3] 是指针数组，本质是数组，存储的是3个 int 型的指针。 关于指针数组和指向数组的指针的更多内容可以自行查阅相关资料，这里就不多说啦🥱 更多一些思考 该部分更新于：2020 年 10 月 18 日 根据上面所讨论的，其实有一点是可以明确的，只要将数组作为参数传递，接收到的就一定是一个指针。 显然对于一个指针，它自身是没有维度的，只有它所指向的对象才可能有维度，这也就可以解释为什么一个二维数组作为参数，接收到的是一个指向一维数组的指针，因为这个指针自身唯有维度，它指向原二维数组的第一个元素，而原二维数组的第一个元素即一个一维数组。 也正因为指针没有维度，我们是不是可以这么理解：数组作为参数传递之后，就丢失了原数组第一个维度的信息。 至少我觉得这样理解是比较合理的，也因此，实际编程中，在传递一个数组的同时传递其维数，程序的可读性将更强。 例如，可以将上述方式二中的函数声明修改为如下所示： void array1d(int *arr1, int d); // 一维 void array2d(int (*arr2)[3], int r, int c); // 二维 void array3d(int (*arr3)[3][2], int a, int b, int c); // 三维 最后呢，其实本文所讨论的均为一般的数组，如果说使用标准库类型 vector 数组其实就没这些必要了，另外也可以使用智能指针，以使函数可以接受任意维度的数组，具体的实现就不讨论了~","categories":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Clash for Windows 使用指北","date":"2020-10-10","updated":"2022-03-23","path":"2020101017609/","text":"一、简述学习计算机不得不说科学上网是刚需了，很多专业上的东西还得谷歌才能解决~ 最近了解到 Clash ，大概就是当前来说比较主流的科学上网方式吧，然后我就从 SSR 换到了 Clash 。 以我个人的理解，像 SS、SSR、v2ray、clash 这些应该都属于协议，只不过作为这方面的小白，我们一般接触到的都是实际应用了这些协议的软件，所以很容易理所当然的认为这些名词是指不同的科学上网软件。 本文仅包含我个人使用 Clash 的一些记录，不提供任何科学上网相关途径，也不介绍具体原理（好吧，其实我自己也不懂🤣）。 首先，我主要是在 Windows 平台上使用 Clash ，前面已经提到 Clash 是一种协议、规则，其在不同的平台上都有相应实现的应用软件。 以 Windows 平台为例，其在 Windows 上的软件为 Clash for Windows 。 Clash for Windows：https://github.com/Fndroid/clash_for_windows_pkg 二、上手大概是出现不算太久的新东西，所以目前 Clash 核心以及对应的这些应用软件都在频繁的更新，直接下载最新版本安装即可，也比较推荐安装新版本~ 此时此刻的最新版本是 0.12.1 ，主界面如图： 首先第一步需要导入规则，也就是上图左侧的 Profiles 栏，点击后可以看到只有一个默认的 config.yaml ，当然这个配置文件也并没有什么内容，仅仅是直连或者拒绝连接；我们需要做的是导入自己的配置文件，一般都会有订阅链接，将订阅链接粘贴到上方编辑框中，然后点击右侧的 Download 按钮即可下载并导入配置文件，或者也可以点击 Import 按钮手动导入下载好的配置文件。 可以看到每一个配置文件都有几个可以点击的按钮，是的，进一步的可以修改配置文件、修改策略、修改规则等，没特殊需求的话也没必要去改。并不是添加后的每一个配置文件都会使用到，只有一个配置文件会以不同的颜色显示，表示这个配置文件为当前正在使用的配置。 添加了配置文件后，就可以选择节点进行使用了，点击左侧的 Proxies ，即可选择不同的代理节点，有几个默认项需要明确： Global 即全局代理，所有的连接不加判断都走代理； Rule 即按规则走代理，这大概也是 Clash 最大的亮点，当然也更加进阶一些； Direct 即直连，不走代理； Script 也属于进阶操作，可以实现更加复杂的功能。 比较常用的是 Rule ，按规则走代理，也就是国内的网站没必要走代理，针对性的有需要的网站才走代理。 选择好代理节点后，还需要回到常规设置中开启系统代理，即打开 System Proxy ，没啥意外的话这就已经可以用了~ 三、更进一步这里简单说几个略微进阶的设置： 1、重度使用当然把跟随系统启动打开好啦，打开常规设置中的 Start with Windows ； 2、打开常规设置中的 Allow LAN 可以开启透明代理，也就是开启后局域网内的设备都可以使用代理，比如连接同一个 WiFi 的手机只需要在 WiFi 设置中设置代理服务器即可。如下图所示，笔记本电脑一般是 WLAN 所对应的 IP 地址（如图192.168.0.104），端口默认为7890； 3、在我实际的使用中，开启代理后国内的一些网站反而打不开了，比如我学校的官网，具体原因我并不是很明白，总之关掉系统代理就可以了。当然还有一个一劳永逸的办法就是设置绕过系统代理，点击左侧的 Settings 项，找到 Bypass Domain/IPNet 点击右侧 Edit ，照葫芦画瓢地添加自己需要绕过代理的 IP 或域名即可，支持使用通配符 * ，比如将所有 .cn 的域名绕过代理就可以设置 - &quot;*.cn&quot; 。（还有更好的办法请参考最后一个板块） 四、自定义规则刚开始使用 Clash 的时候，挺不适应的，主要一点就是开启代理后似乎很多国内网站都不能访问，添加 Bypass 虽然能解决问题，但一方面很麻烦，另一方面像有些软件，不知道 IP 或者域名就没法添加到 Bypass 中，也就只能临时关闭系统代理了，体验并不太好。 而实际上此前一直使用的 SSR 有一个功能就是自动更新 PAC 规则，使用起来基本上就是很无感，开启后就不再需要设置什么了，挺好用的，说实话我确实好奇过 Clash 应该也有类似的东西吧？ 两天前我就在网上搜了一下“Clash 规则”，然后就搜到了这个东西👉 Clash Premium 规则集：https://github.com/Loyalsoldier/clash-rules 点进去看了看，大概就是自己需要的东西了，先上手试试再说~ 说实话起初还真不知道该怎么玩，说明文档有些地方对我这种小白还是有点不太友好的样子，好在是折腾了一天总算是用上了。 确实解决了前面所说的问题，国内网站基本可以按规则不走代理了，并且规则集可以自动更新，设置之后基本就不用再管它了。 首先需要注意的是，使用这个规则集必须确保使用 Clash for Windows 0.12.1 或以上版本，是的，涉及到了新添加的功能，前面我也说到了建议用最新版本，因为 Clash 核心以及应用软件都在频繁的更新中。 具体在 Windows 上的配置步骤基本参考说明文档没问题，简单说就是在软件的配置文件中添加 rule-providers 和 rules 。 软件的配置文件可以在常规设置中找到 General YAML ，点击右侧的 Text Mode Edit 进行编辑，未经修改的默认内容大致如下： mixed-port: 7890 allow-lan: false log-level: info external-controller: &#x27;127.0.0.1:9090&#x27; secret: &#x27;&#x27; ipv6: false # Will be ignored after profile selection proxies: - name: Debug type: socks5 server: 127.0.0.1 port: 1080 proxy-groups: - name: Proxy type: select proxies: - Debug rules: - MATCH,DIRECT 具体添加步骤参考说明文档：https://github.com/Loyalsoldier/clash-rules/blob/master/README.md 这里简单说几个小白可能看起来比较头疼的地方： 直接复制添加 rule-providers 和 rules ，默认配置已经有 rules 项，把其中的内容替换掉； 删除所有带 PROCESS-NAME 的行，在 Clash for Windows 中无效； 默认配置中没有 PROXY 项，说明文档中让自行在 proxies 或 proxy-groups 中配置一个 name 为 PROXY 的 policy ，其实我不太懂怎么配置，考虑到默认的 Proxy 项并没有使用，所以我的解决办法就是直接把原有的 Proxy 修改为 PROXY 即可。 最终的配置文件将会是这样的： mixed-port: 7890 allow-lan: false log-level: info external-controller: &#x27;127.0.0.1:9090&#x27; secret: &#x27;&#x27; ipv6: false rule-providers: reject: type: http behavior: domain url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/reject.txt&quot; path: ./ruleset/reject.yaml interval: 86400 icloud: type: http behavior: domain url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/icloud.txt&quot; path: ./ruleset/icloud.yaml interval: 86400 apple: type: http behavior: domain url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/apple.txt&quot; path: ./ruleset/apple.yaml interval: 86400 google: type: http behavior: domain url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/google.txt&quot; path: ./ruleset/google.yaml interval: 86400 proxy: type: http behavior: domain url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/proxy.txt&quot; path: ./ruleset/proxy.yaml interval: 86400 direct: type: http behavior: domain url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/direct.txt&quot; path: ./ruleset/direct.yaml interval: 86400 cncidr: type: http behavior: ipcidr url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/cncidr.txt&quot; path: ./ruleset/cncidr.yaml interval: 86400 lancidr: type: http behavior: ipcidr url: &quot;https://raw.githubusercontent.com/Loyalsoldier/clash-rules/release/lancidr.txt&quot; path: ./ruleset/lancidr.yaml interval: 86400 # Will be ignored after profile selection proxies: - name: Debug type: socks5 server: 127.0.0.1 port: 1080 proxy-groups: - name: PROXY type: select proxies: - Debug rules: - RULE-SET,reject,REJECT - RULE-SET,icloud,DIRECT - RULE-SET,apple,DIRECT - RULE-SET,google,DIRECT - RULE-SET,proxy,PROXY - RULE-SET,direct,DIRECT - RULE-SET,lancidr,DIRECT,no-resolve - RULE-SET,cncidr,DIRECT,no-resolve - MATCH,PROXY 保存后软件会自动加载设置，不出意外的话软件会自动下载 rule-providers 中配置的规则文件，保存在配置文件根目录下的 ruleset 文件夹中，这里可以自行验证一下，在常规设置中找到 Home Directory ，点击右侧 Open Folder 可以直接打开配置文件根目录。成功下载规则文件将会是下图这样： 如果没能下载下来，可以尝试替换链接，规则集的说明文档中有相关说明。 大概就已经可以正常使用了，可以自行测试一下。这里很尴尬的一点是，有没有配置成功似乎只能实际去访问一些网站试试，软件本身不会有任何提示…… 接下来，就没有接下来了，愉快的使用吧ヾ(≧ ▽ ≦)ゝ 五、懂哥Clash for Windows 默认为英文，也不支持修改语言，英文不太好或者非相关专业的同学可能很多地方都看不懂，不过有开发者特意开发了中文汉化补丁~ Clash_Chinese_Patch：https://github.com/BoyceLig/Clash_Chinese_Patch 下载对应版本并替换就好了，操作起来没什么难度就不细说了！","categories":[],"tags":[]},{"title":"记录QGridLayout踩坑经历","date":"2020-09-30","updated":"2022-03-23","path":"2020093015531/","text":"简述QGridLayout 官方文档：https://doc.qt.io/qtforpython/PySide2/QtWidgets/QGridLayout.html 最近在使用 Qt for Python 开发程序的过程中，被一个 QGridLayout 布局问题给搞得怀疑人生，好在是折腾了很久之后总算是解决了~ 首先看一下解决问题后正常的界面是这样的： 主要是主界面的部分我使用 QGridLayout布局，希望左右两侧按比例 1:1 布局，左侧是一个 QWidget ，没有指定其大小，因为我是希望它能根据格子的大小自适应的调整其大小，也就是说如果格子能小到宽高均为0的话，它是可以不显示的。 艰难的过程于是我写出了如下代码： grid = QGridLayout() grid.addWidget(self.widget_radar, 0, 0, 3, 1) # 3行1列 grid.addLayout(vbox_btns, 0, 1) # 右上侧的4个按钮 grid.addWidget(self.log_edit, 1, 1) # 右下侧的QTextEdit grid.addLayout(self.hbox_debug, 2, 1) # 这是隐藏掉的一部分 # 这三行是必要的，并不是造成我问题的原因，简单说就是不能直接给QMainWindow设置Layout，这里就不细说啦 central_widget = QWidget(parent=self) central_widget.setLayout(grid) self.setCentralWidget(central_widget) 实际运行后的效果如图所示： 是的，左侧的雷达界面没有显示出来。严格说是显示出来了，仔细观察可以看到左边边距相对于右边宽一点，宽的部分也就是看不到的雷达界面，更准确地说应该是格子布局的间距。 我真的折腾了好久不知道怎么解决，其实很快我就定位到左侧雷达界面并不是没有显示出来，找问题的过程中为了验证这个想法，我指定了雷达界面的大小为 400 * 400 。 self.widget_radar.setFixedSize(400, 400) 然后运行，如图： 是吧，确实是能显示出来的。但是也不太可能说这么去指定大小啊，我既然选择使用格子布局就是为了让它自适应调整大小~ 继续找解决办法，说实话我查遍了文档也没找到相关的说明，一开始以为是这样： grid = QGridLayout() grid.addWidget(self.widget_radar, 0, 0, 3, 1) # 3行1列 grid.addLayout(vbox_btns, 0, 1, 1, 1) # 指定第三个和第四个参数，即指定其跨度为1行1列 grid.addWidget(self.log_edit, 1, 1, 1, 1) grid.addLayout(self.hbox_debug, 2, 1, 1, 1) 上面代码中 addLayout() 和 addWidget() 第三个和第四个参数分别是行跨度和列跨度，以我最初的理解，我认为指定了第一列列跨度为1，第二列列跨度也为1，那么它们就应该宽度相等。但实际上并没有用，也说明其实不指定这两个参数的话默认就是一行一列。 解决问题其实我只是抱着试一试的心态，试了下官方文档中的这个函数： PySide2.QtWidgets.QGridLayout.setColumnStretch(column, stretch) 成功解决问题🎉🎉🎉 最终的代码如下： grid = QGridLayout() grid.addWidget(self.widget_radar, 0, 0, 3, 1) # 3行1列 grid.addLayout(vbox_btns, 0, 1) grid.addWidget(self.log_edit, 1, 1) grid.addLayout(self.hbox_debug, 2, 1) grid.setColumnStretch(0, 1) # 不指定比例的话第二列会撑展到第一列不能显示，造成不显示的根本原因 grid.setColumnStretch(1, 1) # 需要同时为第二列指定，两列才会始终以1:1的宽度排列 这个函数是这么用的，第一个参数指定哪一列，列数从0开始，第二个参数为拉伸因子，也就是所占的比例吧。 上面代码中同时为两列指定了拉伸因子均为1，即两列的宽度将按1:1的比例排列。 只指定一列是达不到这个效果的，例如如果不为第二列指定，那么雷达界面这部分因为指定了拉伸银子1，所以会显示出来，但由于没有为第二列指定，所以第一列会撑展开，使第二列的宽度压缩到最小，如图： 相反如果只指定第二列的话，其实不难想到就会是前面雷达界面没有显示出来的样子了~ 另外，同样也可以为行设置拉伸因子，方法都是一样的，用这个函数就可以了: PySide2.QtWidgets.QGridLayout.setRowStretch(row, stretch) 真的卡了好久，真尴尬……不过以后就知道该怎么做了🥴","categories":[{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/categories/Qt/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"},{"name":"Qt","slug":"Qt","permalink":"https://mxy493.xyz/tags/Qt/"}]},{"title":"新华三笔试题 - 求最中间的因数","date":"2020-09-25","updated":"2022-03-23","path":"2020092551823/","text":"题目 时间限制： C/C++1秒，其他语言2秒 空间限制： C/C++ 262144K，其他语言 524288K 64bit IO Format: %lld 请完成最中间因数函数 MidFactor，寻找一个整数的所有因数中最中间的那个数。 举例： 16有5个因数，分别是1，2，4，8，16，最中间的是4 12有6个因数，分别是1，2，3，4，6，12.最中间的是3 long long MidFactor(long long llVal) &#123; &#125; int main (int argc, char *argvD) &#123; long long llVal =0; if (argc &lt; 2) &#123; return 1; &#125; llVal= (long long)atol(argv[1); printf(&quot;%ll&quot;, MidFactor(llVal); return 0; &#125; []$ ./a.out 16 4 []$ ./a.out 12 3 示例1 输入 16 输出 4 解题思路这个题做得挺快的，暴力解的话遍历就可以，主要需要注意遍历的边界。 首先，要找到一个数的所有因数，一下就能想到的就是从 1 开始遍历，能整除的就是其因数，代码大概是这样： for (int i = 1; i &lt; num; i++)&#123; if(num % i) &#123; // i是num的因数 &#125; &#125; 然后进一步的不难发现，任意的一个因数 i 都和 num / i 对应是一组因数，也就是说上面的 if 语句内部得到了因数 i 的同时还得到了另一个与之对应的因数 num / i 。 再回到这个题里面来，这种要找中间的值的问题，往往我们会考虑把所有可能的值找出来后，再去找位于中间的那一个。但正如前面所说，因数总是一一对应的，这就意味着我们从 1 开始遍历，i 变大的同时，与之对应的 num / i 在逐渐变小，以 16 为例： 1 - 16 2 - 8 4 - 4 // 最中间的因数 8 - 2 16 - 1 i 逐渐增大，会在过了某个临界值（如上4）之后大于 num / i ，而这个临界值其实就是最中间的因数。 因此，只需要把遍历的边界设置为 i 从 1 开始且 i * i &lt;= num 即可，初始化最中间的因数 mid 为 1 ，每新找到一个更大的因数就更新 mid 的值，当 i 越过边界跳出循环后，mid 的值即为 num 所有因数中最中间的哪一个。 代码class Solution &#123; public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * 求 一个数 最中间的因素 * @param llVal long长整型 正整数 * @return long长整型 */ long long MidFactor(long long llVal) &#123; // write code here long long mid = 1; for (long long i = 1; i * i &lt;= llVal; i++) &#123; if (llVal % i == 0) &#123; mid = i; &#125; &#125; return mid; &#125; &#125;;","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"Leetcode 1143. 最长公共子序列","date":"2020-09-20","updated":"2022-03-23","path":"2020092011556/","text":"地址：https://leetcode-cn.com/problems/longest-common-subsequence 题目给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 若这两个字符串没有公共子序列，则返回 0。 示例 1: 输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; 输出：3 解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。 示例 2: 输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot; 输出：3 解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。 示例 3: 输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot; 输出：0 解释：两个字符串没有公共子序列，返回 0。 提示: 1 &lt;= text1.length &lt;= 1000 1 &lt;= text2.length &lt;= 1000 输入的字符串只含有小写英文字符。 解题思路这个题并不是我自己做的，是我在学习动态规划的过程中看到的 Leetcode 官方的一篇关于动态规划的文章：算法萌新如何学好动态规划（2），觉得这个题目的解题思路很有意思，所以记录一下~ 关于具体的解题思路以及状态转移方程这里不做过多描述了，可以参考原文解题思路。 我觉得很有意思的一个地方是，请看下方代码，按理说我们一般会用一个 n × m 的矩阵用于存储 f[i][j] 的值，即第一个串的前 i 个字符与第二个串的前 j 个字符的最长公共子序列长度，而代码第 5 行却初始化了一个全零的 n+1 × m+1 矩阵，至少我看到这里的时候是有疑惑的，而我最初想到的原因也只是为了理解上更加直观，当然这可以说是一个原因，但事实上这不是最主要的原因。 继续看代码，到第 8 行就明白了，涉及到了对索引 i - 1 、 j - 1 的取值，由于 0 行 0 列根本用不到，而 i 、 j 的初始值均为 1 ，也就是说我们无需再对边界值进行特殊处理，并且将矩阵初始化为全 0 也是有意义的，例如 f[1][1] 就可以直接由 max(f[0][1], f[1][0]) 得到。简言之，对于我们想要得到的这个 n × m 的矩阵，就不需要处理任何的特殊情况了，实在是很方便~ 当然上面这些更多的是“取巧”，这个题最核心的部分还是怎么得到它的状态转移方程。 代码class Solution &#123; public: int longestCommonSubsequence(string text1, string text2) &#123; int n = text1.length(), m = text2.length(); vector&lt;vector&lt;int&gt; &gt; f(n+1, vector&lt;int&gt;(m+1, 0)); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; f[i][j] = max(f[i-1][j], f[i][j-1]); if(text1[i-1] == text2[j-1]) f[i][j] = max(f[i][j], f[i-1][j-1]+1); &#125; &#125; return f[n][m]; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"}]},{"title":"使用NSIS制作安装程序","date":"2020-09-10","updated":"2022-03-23","path":"2020091060302/","text":"一、简述最近实习的过程中，要将 Python 编写的程序打包发布，最初了解到了 PyInstaller ，可以用于将 Python 代码打包为可执行程序，但是要么直接打包为单文件的可执行程序（运行慢），要么打包为一个包含可执行程序的文件夹（运行快），如果要发给别人使用的话只能将整个文件夹压缩后再发过去。 然后前些天搜索了一下了解到了制作安装程序的 NSIS ，本文将根据我的个人经历，简要介绍使用 NSIS 根据 PyInstaller 生成的含可执行程序的文件夹制作安装程序。 NSIS 官方网站：https://nsis.sourceforge.io/Main_Page NSIS 中文论坛：https://www.nsisfans.com （内含国内开发者修改的集成增强版，可用于学习使用） 二、下载安装下载地址：https://nsis.sourceforge.io/Download 如果刚接触的话可以使用上方中文论坛中提供的集成增强版，需要的东西都已经安装好了直接用就可以，而且其内置了 VNISEdit 可以使用向导很方便的创建 nsi 脚本，但注意通过向导生成的脚本比较简略，也可能存在一些比较细节的问题，所以一般后续还需要手动进行一些修改。 官方版仅支持编译，需要手动编写好脚本后导入进行编译。 当前 NSIS 的官方最新版本是 3.06.1 ，一般安装最新版即可。 安装过程很简单，只需要选择合适的安装路径（默认为 C:\\Program Files (x86)\\NSIS），其它一般默认即可。 三、使用 VNISEdit 向导生成脚本其实这个 VNISEdit 官方版本叫 HM NIS EDIT ，这个 VNISEdit 应该是国内开发者修改过的版本。 HM NIS EDIT 官方网站：http://hmne.sourceforge.net 如果 NSIS 是安装的官方版本，那么如果要使用 HM NIS EDIT 就需要额外下载安装，如果是使用国内开发者修改过的集成安装版则均已安装好了，直接运行即可。 这里我以集成增强版为例进行简要说明，官方版本差别并不大，不同版本功能有细微的差别也不用太在意，VNISEdit 仅仅是用来帮助创建 nsi 脚本，如前面所说，生成的脚本一般都是需要后续手动修改的。 （1）继承增强版程序主界面如下图所示，这个界面其实是一个主菜单，第一个 MakeNSISW 是编译工具，向其中导入编写好的脚本就可以编译生成安装程序，第二个 HM VNISEdit 就是现在要介绍的帮助创建 nsi 脚本的程序，第三个 NotePad2 是一个文本编辑器。 （2）打开 HM VNISEdit ，界面如下，这个软件主要是用来编写 nsi 脚本的，但也集成了编译的功能。 （3）点击左上角“文件”，可以看到多种创建脚本的方法，这里我们使用向导进行创建，因为只需要一步一步按照向导的提示设置相关项即可，傻瓜式操作，对新手很友好🤣 （4）一般需要设置程序名和版本号，其它信息如果不需要的话选中删除即可，下一步。 （5）设置【安装程序的图标】，注意并不是【程序的图标】，设置安装程序的名字，默认为 Setup.exe ，虽然可以但是建议改一下，之前在某个地方有看到说这个名字系统有可能报错。其它项一般不需要设置，感兴趣自行查阅相关资料。 （6）呃，这一页，算了，下一步，花里胡哨…… （7）设置默认的安装目录，$PROGRAMFILES 指系统的默认程序安装文件夹（一般不需要修改，但需要注意程序运行可能需要管理员权限），一般为 C:\\Program Files (x86) ，具体运行的时候会自动检测；下面的授权文件如果没有的话删掉编辑框中内容即可。下一步。 （8）删除下图的默认的两行，这里假设程序已经打包到一个文件夹里，点击 “AddDirTree” 按钮直接添加整个程序文件夹。 （9）选择程序的目录，以我的 D:\\mxy\\Desktop\\Duang 为例，选择后会自动加上 *.* ，指添加该路径下的所有文件；目的目录保持默认的 $INSTDIR ，即程序的安装目录，取决于用户安装程序时选择的安装位置，如果不修改则为第（7）步默认的 C:\\Program Files (x86)\\Duang ；注意勾选左下方的“包含子目录”项。其它按需自行修改，确定。 （10）建议点击 “添加文件” 按钮将程序的可执行文件单独添加到列表中，后一步会有用到，添加后的结构如下图所示。下一步。 （11）上一步如果没有单独添加可执行程序的话，这一步就不会有下图框中的两项，当然应该也可以自行添加，只是相对麻烦一些。参考下图的设置，安装程序会在开始菜单中创建一个名叫 “Duang” 的文件夹，然后在这个文件夹中创建程序的快捷方式以及卸载程序的快捷方式，还会创建一个桌面快捷方式。下一步。 （12）设置程序安装完后要做什么，下图为安装完后启动应用程序。下一步。 （13）关于卸载程序的一些设置，自行设置后下一步。 （14）建议保存脚本并转换文件路径到相对路径，方便重复使用该脚本。完成。 （15）此时可以看到 HM VNISEdit 的主界面已经加载了根据刚才的设置生成的脚本，看不懂，先不管脚本了，傻瓜式的点击菜单栏的 “NSIS” ，然后 “编译并运行” 即可。 （16）这时候耐心等待就好了，生成的安装程序会存放在上一步保存的脚本文件所在的目录下。 （17）这就不需要教了ᓚᘏᗢ 四、自定义 NSIS 脚本显然前面向导生成的脚本可以自定义的地方是有限的，而且实际操作中可能还有些问题，例如我遇到的卸载程序不能将程序完全卸载掉的问题，所有这些问题都可以通过修改脚本文件来解决。 注意：特别需要注意以下 NSIS 脚本的编码问题，好像是官方版本不支持 Unicode 编码，反正我个人使用官方 NSIS 3.06.1 过程中 GBK 编码没有问题，UTF-8 编码会报错，但 UTF-8 with BOM 是可用的。 （1）使用 VScode 编辑脚本这里首先推荐使用 VScode 编辑脚本，因为 VScode 有 NSIS 的插件可以高亮显示代码，甚至简单配置了 NSIS 编译器路径后还可以直接在 VScode 中一键编译，非常方便。 简单介绍一下吧，NSIS 插件自行搜索安装就好了，安装好后配置 NSIS 插件。 主要需要配置 NSIS 编译器的路径，如图所示。 NSIS 安装目录下的 makensis.exe 即 NSIS 编译器。 完毕后打开先前生成的脚本文件看看，真香 :-) 脚本编辑完毕后，点击右上角按钮即可编译生成安装程序。 （2）正儿八经的编写脚本以我的脚本为例来一步一步说，也就是前面向导生成的没有修改过的脚本。 a. ; 为 NSIS 脚本的注释符，用法类似 C++ 的 // 或者 Python 的 # ，!define 用于定义常量，后接自定义的常量名和该常量的值。强烈建议将各种自定义的量在脚本的开头定义为常量，后续使用常量即可，这么做的目的是程序升级时方便简单修改一些常量的值即可重复使用该脚本。常量的使用如下方代码第 7 行所示即 $&#123;变量名&#125; 即可。 ; 安装程序初始定义常量 !define PRODUCT_NAME &quot;Duang&quot; ; 程序名 !define PRODUCT_VERSION &quot;1.0&quot; ; 版本号 !define PRODUCT_PUBLISHER &quot;mxy&quot; ; 作者 !define PRODUCT_PATH &quot;D:\\mxy\\Desktop\\Duang&quot; ; 新增定义源程序路径 !define PRODUCT_WEB_SITE &quot;https://mxy.cool&quot; ; 网址 !define PRODUCT_DIR_REGKEY &quot;Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Duang.exe&quot; ; 注册表相关 !define PRODUCT_UNINST_KEY &quot;Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$&#123;PRODUCT_NAME&#125;&quot; !define PRODUCT_UNINST_ROOT_KEY &quot;HKLM&quot; b. 使用的压缩算法，按需修改即可 SetCompressor lzma c. MUI 界面相关的一些东西，进阶操作请查阅官方文档。 ; ------ MUI 现代界面定义 ------ !include &quot;MUI.nsh&quot; ; 当前已经新出了MUI2，自行了解 ; MUI 预定义常量 !define MUI_ABORTWARNING !define MUI_ICON &quot;$&#123;PRODUCT_PATH&#125;\\img\\mh64.ico&quot; ; 安装程序的图标 ; !define MUI_UNICON &quot;$&#123;NSISDIR&#125;\\Contrib\\Graphics\\Icons\\modern-uninstall.ico&quot; ; 卸载程序的图标 !define MUI_UNICON &quot;$&#123;MUI_ICON&#125;&quot; ; 修改为使用安装程序一样的图标 ; 欢迎页面 !insertmacro MUI_PAGE_WELCOME ; 安装目录选择页面 !insertmacro MUI_PAGE_DIRECTORY ; 安装过程页面 !insertmacro MUI_PAGE_INSTFILES ; 安装完成页面 ; !define MUI_FINISHPAGE_RUN &quot;$INSTDIR\\Duang.exe&quot; ; 安装结束后运行程序 !define MUI_FINISHPAGE_RUN &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.exe&quot; ; 修改为引用常量 !insertmacro MUI_PAGE_FINISH ; 安装卸载过程页面 !insertmacro MUI_UNPAGE_INSTFILES ; 安装界面包含的语言设置 !insertmacro MUI_LANGUAGE &quot;SimpChinese&quot; ; 安装预释放文件 !insertmacro MUI_RESERVEFILE_INSTALLOPTIONS ; ------ MUI 现代界面定义结束 ------ d. 一些设置项。 Name &quot;$&#123;PRODUCT_NAME&#125; $&#123;PRODUCT_VERSION&#125;&quot; ; OutFile &quot;DuangSetup.exe&quot; OutFile &quot;$&#123;PRODUCT_NAME&#125;Setup.exe&quot; ; 修改为引用常量 ; InstallDir &quot;$PROGRAMFILES\\Duang&quot; InstallDir &quot;$PROGRAMFILES\\$&#123;PRODUCT_NAME&#125;&quot; ; 修改为引用常量 InstallDirRegKey HKLM &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;UninstallString&quot; ShowInstDetails show ; 显示安装细节 ShowUnInstDetails show ; 显示卸载细节 ; BrandingText &quot;Duang&quot; ; 安装程序的下方的一段文字 BrandingText &quot;$&#123;PRODUCT_NAME&#125;&quot; ; 修改为引用常量 e. 创建快捷方式，已默认修改为引用常量。 Section &quot;MainSection&quot; SEC01 SetOutPath &quot;$INSTDIR&quot; SetOverwrite ifnewer ; 更新覆盖 File /r &quot;*.*&quot; ; 路径下的所有文件 CreateDirectory &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;&quot; ; 创建开始菜单目录并命名为程序名 ; 在上一行创建的开始菜单目录下创建程序快捷方式 CreateShortCut &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\$&#123;PRODUCT_NAME&#125;.lnk&quot; &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.exe&quot; CreateShortCut &quot;$DESKTOP\\$&#123;PRODUCT_NAME&#125;.lnk&quot; &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.exe&quot; ; 创建桌面快捷方式 File &quot;$&#123;PRODUCT_PATH&#125;\\$&#123;PRODUCT_NAME&#125;.exe&quot; ; 源可执行程序的路径 SectionEnd f. 写注册表相关的设置，已默认修改为引用常量。 Section -Post WriteUninstaller &quot;$INSTDIR\\uninst.exe&quot; ; 写入卸载程序 WriteRegStr HKLM &quot;$&#123;PRODUCT_DIR_REGKEY&#125;&quot; &quot;&quot; &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.exe&quot; WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;DisplayName&quot; &quot;$(^Name)&quot; WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;UninstallString&quot; &quot;$INSTDIR\\uninst.exe&quot; WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;DisplayIcon&quot; &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.exe&quot; WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;DisplayVersion&quot; &quot;$&#123;PRODUCT_VERSION&#125;&quot; WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;URLInfoAbout&quot; &quot;$&#123;PRODUCT_WEB_SITE&#125;&quot; WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; &quot;Publisher&quot; &quot;$&#123;PRODUCT_PUBLISHER&#125;&quot; SectionEnd g. 创建网站快捷方式和卸载程序快捷方式。 Section -AdditionalIcons WriteIniStr &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.url&quot; &quot;InternetShortcut&quot; &quot;URL&quot; &quot;$&#123;PRODUCT_WEB_SITE&#125;&quot; CreateShortCut &quot;$SMPROGRAMS\\Duang\\Website.lnk&quot; &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.url&quot; CreateShortCut &quot;$SMPROGRAMS\\Duang\\Uninstall.lnk&quot; &quot;$INSTDIR\\uninst.exe&quot; SectionEnd h. 卸载程序相关的设置，已默认修改为引用常量。 Section Uninstall ; 删除快捷方式 Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\Uninstall.lnk&quot; Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\Website.lnk&quot; Delete &quot;$DESKTOP\\$&#123;PRODUCT_NAME&#125;.lnk&quot; Delete &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;\\$&#123;PRODUCT_NAME&#125;.lnk&quot; ; 删除开始菜单文件夹 RMDir &quot;$SMPROGRAMS\\$&#123;PRODUCT_NAME&#125;&quot; ; Delete &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.url&quot; ; Delete &quot;$INSTDIR\\uninst.exe&quot; ; Delete &quot;$INSTDIR\\$&#123;PRODUCT_NAME&#125;.exe&quot; ; RMDir /r &quot;$INSTDIR\\tk&quot; ; RMDir /r &quot;$INSTDIR\\tcl&quot; ; RMDir /r &quot;$INSTDIR\\lib2to3&quot; ; RMDir /r &quot;$INSTDIR\\Include&quot; ; RMDir /r &quot;$INSTDIR\\img&quot; ; RMDir &quot;$INSTDIR&quot; RMDir /r &quot;$INSTDIR&quot; ; 直接删除整个文件夹，前面所说的卸载不干净的问题就是这里造成的 ; 删除注册表信息 DeleteRegKey $&#123;PRODUCT_UNINST_ROOT_KEY&#125; &quot;$&#123;PRODUCT_UNINST_KEY&#125;&quot; DeleteRegKey HKLM &quot;$&#123;PRODUCT_DIR_REGKEY&#125;&quot; SetAutoClose true ; 卸载完毕自动关闭窗口 SectionEnd i. 执行卸载程序的两个函数 ; 卸载程序启动时执行 Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 &quot;您确实要完全移除 $(^Name) ，及其所有的组件？&quot; IDYES +2 Abort FunctionEnd ; 卸载成功时执行 Function un.onUninstSuccess HideWindow MessageBox MB_ICONINFORMATION|MB_OK &quot;$(^Name) 已成功地从您的计算机移除。&quot; FunctionEnd （3）编译试试如果编译成功将看到输出结构如下的信息。编译生成的安装程序将和脚本文件存放在一起，可以安装测试一下功能是否正常。 如果编译失败，会输出具体哪一行出现了错误，容易出错的地方就是路径问题，并不复杂，稍微细心一点就好了。 五、进阶操作进阶操作我也不会什么了，建议查阅 NSIS 官方文档：https://nsis.sourceforge.io/Docs 关于安装程序的界面的设置需要查阅 MUI 的相关文档：https://nsis.sourceforge.io/Docs/Modern UI 2/Readme.html 例如，以下两项分别可以设置安装程序欢迎界面的图片和文字。 ; Bitmap for the Welcome page and the Finish page (recommended size: 164x314 pixels). ; Default: $&#123;NSISDIR&#125;\\Contrib\\Graphics\\Wizard\\win.bmp MUI_WELCOMEFINISHPAGE_BITMAP bmp_file ; Text to display on the page. MUI_WELCOMEPAGE_TEXT text 六、在 Python 中编译（1）在 Python 中编译其实在 Python 中编译本质上就是调用 NSIS 编译程序 “makensis.exe” 。 首先要做的时将 NSIS 编译器所在的目录添加到系统环境变量，如图所示。 环境变量设置好后可以在命令行中输入命令 makensis 测试一下，如果输出如下信息，则说明配置成功了。 在 Python 中使用就很简单了，直接上代码： import subprocess # 使用NSIS制作安装包，等同于在命令行中执行 &#x27;makensis radar.nsi&#x27; p2 = subprocess.Popen(&#x27;makensis radar.nsi&#x27;, shell=True, encoding=&quot;utf-8&quot;) # pyinstaller 打包 p2.communicate() （2）高端操作其实在单纯在 Python 中调用编译器并没有省多少事，但真正的目的是配合 PyInstaller 一键更新 spec 文件和 NSIS 脚本，然后自动打包并制作安装程序，你就说它香不香🤣 关于 PyInstaller 打包 Python 应用程序可以参考我的另一篇文章：使用PyInstaller打包Python应用程序 最后附上 全自动操作的代码框架： import subprocess def run(): clean() # 更新 spec 文件 update_spec() # 更新 NSIS 脚本 update_nsis() # PyInstaller 打包 p1 = subprocess.Popen(&#x27;pyinstaller radar.spec --clean&#x27;, shell=True, encoding=&quot;utf-8&quot;) p1.communicate() # 使用NSIS制作安装包 p2 = subprocess.Popen(&#x27;makensis radar.nsi&#x27;, shell=True, encoding=&quot;utf-8&quot;) p2.communicate() 试想一下你的程序每次更新仅需要更改版本号或者修改一下路径，然后剩下的工作全都自动化完成那得多舒服😋 七、结语嗯，全篇完结，真难搞，写这篇文章足足花了一整晚🤣 不过这次关于 PyInstaller 和 NSIS 的探索体验可以说是非常的舒服了φ(゜▽゜*)♪","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"},{"name":"NSIS","slug":"NSIS","permalink":"https://mxy493.xyz/tags/NSIS/"}]},{"title":"使用PyInstaller打包Python应用程序","date":"2020-09-09","updated":"2022-03-23","path":"20200909134/","text":"一、简述PyInstaller 官网：https://www.pyinstaller.org PyInstaller 可以将 Python 程序及其依赖的包打包为一个可执行程序方便安装使用。 PyInstaller 可以将 Python 程序打包为一个独立的可执行程序或者一个包含可执行程序的文件夹，区别在于单文件的程序运行较慢，而文件夹的程序运行较快。 如果要打包为一个包含可执行程序的文件夹，需要注意将附加的文件添加进来，PyInstaller 指挥根据 Python 脚本搜索依赖的包，但不会自动包含参数配置文件之类的文件。同时如果需要将程序发布出来供他人使用，则需要将打包后的文件夹制作成压缩包用于分发，或者额外制作安装程序（例如可以使用 NSIS 制作安装包）。 二、安装建议：使用 virtualenv 将依赖的包安装到虚拟环境中。 使用 pip 安装和升级 PyInstaller。 # 安装 pip install pyinstaller # 升级 pip install --upgrade pyinstaller 可选安装最新开发版。 pip install https://github.com/pyinstaller/pyinstaller/archive/develop.tar.gz 三、使用（1）命令行方式1. 基本命令注意：推荐使用另外两种方式，但它们的使用方法也都基于命令行选项。 基本语法结构如下： pyinstaller [options] script [script …] | specfile In the most simple case, set the current directory to the location of your program myscript.py and execute: 最简单的情况是，在 Python 程序 myscript.py 目录下直接执行： pyinstaller myscript.py PyInstaller 会分析 myscript.py 并: 在当前目录下创建 myscript.spec 脚本； 创建 build 和 dist 文件夹； 在 build 文件夹中创建一些日志或工作文件； 在 dist 文件夹中创建 myscript 文件夹，内含可执行的应用程序。 使用 .spec 的脚本文件可以避免每次都要输入很长的参数，后面会讲到。 2. 参数设置仅列举了较常用的一些选项，更多信息请查阅官方文档：https://pyinstaller.readthedocs.io/en/latest/usage.html#options 当使用较多选项时命令会很长，可以将命令写到脚本文件中备用。 1. 常规设置 –distpath DIR 存放生成的程序的路径。 (default: ./dist) –workpath WORKPATH 存放一些 PyInstaller 工作生成的文件，.log, .pyz 和 etc 。 (default: ./build) -y, –noconfirm 如果程序文件夹存在的话直接替换不需要确认。 (default: SPECPATH/dist/SPECNAME) –upx-dir UPX_DIR UPX 程序的路径。 (default: search the execution path) 简单说 UPX （官方网站）的作用就是压缩。UPX 需要额外下载安装，下载后解压缩即可。 要使用 UPX 的话可以直接将 UPX 程序（upx.exe）放到虚拟环境的 ./venv/Scripts 目录下即可，无需设置该选项。 –clean Build 之前先清理 PyInstaller 缓存和临时文件。 2. 生成什么 -D, –onedir 默认选项，创建一个包含可执行程序的文件夹，运行速度较快。 -F, –onefile 创建一个单文件的可执行程序，运行速度较慢。 –specpath DIR 指定存放 .spec 脚本的路径，默认为当前文件夹。 -n NAME, –name NAME 指定 spec 文件和要生成的程序的文件名。 (default: first script’s basename) 3. 打包那些东西以及去哪里找 –add-data &lt;SRC;DEST or SRC:DEST&gt; 附加的非二进制文件或文件夹，例如保存参数设置的 config.json 文件。分隔符在 Windows 系统中一般为 ; ，在大多 UNIX 系统中一般为 : 。该参数可多次重复使用以添加多个附加文件。 –add-binary &lt;SRC;DEST or SRC:DEST&gt; 附加的二进制文件。使用方式同 --add-data 选项。 -p DIR, –paths DIR 搜索依赖的包的路径，可以使用 : 添加多条路径，或者多次使用该选项。 –hidden-import MODULENAME, –hiddenimport MODULENAME 列举在 Python 脚本中不可见的导入，不能搜索到的包。该选项可多次使用。 4. 怎么生成 -d &lt;all,imports,bootloader,noarchive&gt;, –debug &lt;all,imports,bootloader,noarchive&gt; 用于调试，具体说明请查阅官方文档。 –noupx 即使 UPX 可用也不使用，如果使用 UPX 后程序无法正常运行可以使用该选项。 –upx-exclude FILE 指定不需要压缩的二进制文件，防止 UPX 在压缩过程中破坏了一些二进制文件。 5. Windows 和 Mac OS 特定选项 -c, –console, –nowindowed 打开一个命令行窗口用于标准 I/O (default)。在 Windows 上，如果第一个脚本是 .pyw 文件，则此选项无效。 -w, –windowed, –noconsole 不打开命令行窗口用于标准 I/O 。 -i &lt;FILE.ico or FILE.exe,ID or FILE.icns&gt;, –icon &lt;FILE.ico or FILE.exe,ID or FILE.icns&gt; 设置程序的图标。FILE.ico: apply that icon to a Windows executable. FILE.exe,ID, extract the icon with ID from an exe. FILE.icns: apply the icon to the .app bundle on Mac OS X. 6. Windows 特定选项 –uac-admin 程序运行时请求提升权限。 （2）使用 spec 文件实际上不管使用哪种方式都会生成一个 spec 文件，里面包含了大多数设置的参数。 可以使用以下命令创建 spec 文件： pyi-makespec [options] name.py [other scripts ...] 当创建并根据需要修改了 spec 文件后，就可以简单的通过以下命令运行： pyinstaller [options] name.spec spec 文件结构如下： # -*- mode: python ; coding: utf-8 -*- block_cipher = None a = Analysis([&#x27;../main.py&#x27;], # 指定主程序脚本 pathex=[&#x27;D:/path/to/project&#x27;], # 设置项目路径 binaries=[], # 指定要添加的二进制文件 datas=[(&#x27;../settings.json&#x27;, &#x27;.&#x27;), (&#x27;../version.txt&#x27;, &#x27;.&#x27;), (&#x27;../img&#x27;, &#x27;img&#x27;), (&#x27;../font&#x27;, &#x27;font&#x27;)], # 指定要添加的非二进制文件或文件夹 hiddenimports=[], hookspath=[], runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher, noarchive=False) pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher) exe = EXE(pyz, a.scripts, [], exclude_binaries=True, name=&#x27;Radar0.0.12&#x27;, debug=False, bootloader_ignore_signals=False, strip=False, upx=False, # 是否使用UPX压缩 console=False , icon=&#x27;../img/logo64.ico&#x27;) # 程序图标 coll = COLLECT(exe, a.binaries, a.zipfiles, a.datas, strip=False, upx=False, upx_exclude=[&#x27;vcruntime140.dll&#x27;], name=&#x27;Radar0.0.12&#x27;) （3）在 Python 中运行1. 使用 PyInstaller 内置的 run() 函数传入参数列表即可 import PyInstaller.__main__ parameters = [ &#x27;../main.py&#x27;, f&#x27;--name=&#123;program_name&#125;&#x27;, &#x27;--distpath=./dist&#x27;, &#x27;--workpath=./build&#x27;, &#x27;--clean&#x27;, &#x27;-D&#x27;, &#x27;-w&#x27;, &#x27;-i=../img/logo64.ico&#x27;, &#x27;--add-data=../settings.json;.&#x27;, &#x27;--add-data=../version.txt;.&#x27;, &#x27;--add-data=../img;img&#x27;, &#x27;--add-data=../font;font&#x27;, &#x27;--noupx&#x27;, ] PyInstaller.__main__.run(parameters) # RUN 2. 在 Python 中执行命令等同于在终端中执行命令，但可以通过 Python 执行更多的定制化的操作。 import subprocess p = subprocess.Popen(&#x27;pyinstaller radar.spec --clean&#x27;, shell=True) p.communicate() 四、 其它说明嗯，好像没啥好说明的了，遇到问题搜索一下还是比较容易解决的。 UPX 压缩极有可能会有问题，用不了就干脆不用了，也没能压缩太多，我测试的程序不压缩 80 MB，压缩后 62 MB，个人认为不压缩也是可以接受的。 另外推荐使用 NSIS 制作安装程序ฅʕ•̫͡•ʔฅ","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"https://mxy493.xyz/tags/Python/"}]},{"title":"新网银行笔试题 - 分苹果","date":"2020-09-06","updated":"2022-03-23","path":"2020090662371/","text":"题目小朱有 n 个苹果要卖，他有两张桌子 S1，S2 ，要将所有 n 个苹果分别放在两张桌子上，使 S1 上最重的苹果和 S2 上最轻的苹果之差最小。 输入说明： 输入数据的组数 t （1行）； 第 i 组数据的苹果数量 n （1行 × t）； 第 i 组 n 个苹果的重量 n 个整数（1行 × t）； 输出说明： t 行，t 组数据的最小值。 输入示例： 5 5 9 9 5 4 8 2 5 9 4 7 2 3 3 4 2 1 8 4 5 1 2 1 3 1 输出示例： 0 4 0 1 0 解题思路这个题在笔试题里面确实算是简单的，当然可能有更好的解法~ 仔细思考一下，其实就是找最小的重量差。翻译为数学问题，任意一组数，只要找到最小差的两个数 a ， b （a &lt;= b），就可以把所有其它小于等于 a 的数分为一组，剩余的大于等于 b 的数分为一组，此时也就满足了一组数的最大值（a）和另一组数的最小值（b）之差最小。 以下代码为一边输入一边就将各组输入数据的结果输出，如果需要计算完所有数据后统一输出，可以将结果暂存到一个列表中。 代码t = int(input()) # 数据组数 for i in range(t): n = int(input()) # 第i组数据的苹果数量n weights = [int(item) for item in input().split(&#x27; &#x27;)] # 第i组数据n个苹果的重量 weights.sort() # 先排序，效率高很多 m = abs(weights[1] - weights[0]) # 初始化m为任意两苹果的重量差 for j in range(n - 1): tmp = abs(weights[j + 1] - weights[j]) m = tmp if tmp &lt; m else m # 更新最小重量差 if m == 0: break # 0为可能的最小值 print(m)","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"YOLOv5快速上手使用【WIN】","date":"2020-08-30","updated":"2022-03-23","path":"2020083032973/","text":"简述最近实习中接触到 YOLO ，实时目标检测，我也没学过深度学习，对 YOLO 的原理并不太懂，不过它的能力确实是惊到我了，很短的时间内就可以将图片中的目标准确的识别出来。YOLO 简单说是一个目标检测的算法，特点就是快，一张图片只扫描一次，YOLO 面世也没几年的时间，现在已经第五版了，简单记录一下 YOLOv5 的上手使用过程！ YOLOv5 官方地址：https://github.com/ultralytics/yolov5 一、测试环境 系统：Windows 显卡：GeForce MX250 软件：PyCharm Python：3.8.5 PyTorch：1.6.0 二、下载 YOLOv5下载 YOLOv5 源码以及训练好的权重文件，当前最新版为 v3.0 ，一般下载最新版就可以了，或者直接 clone 。 上面4个 .pt 文件时 YOLOv5 训练好的权重文件，越小速度越快，但精度越低，这里先 yolov5s.pt 用于测试，另外3个也可以自行下载下来试一试。 解压缩源码，将权重文件 yolov5s.pt 拷贝到源码根目录下的 weights 文件夹下。 三、安装依赖（1）配置虚拟环境（非必需）用 PyCharm 打开项目文件夹（我个人使用 PyCharm 比较习惯了）~ 首先配置虚拟环境，点击文件 -&gt; 设置 -&gt; Python解释器 -&gt; 添加。 选择 Virtualenv 环境，选择新环境，基本解释器选择 Python3.8 以上的版本（官方说是需要3.8及以上版本），选择好后点击“确定”即可，PyCharm 会自动创建虚拟环境，稍微等一下。 虚拟环境配置好后打开终端，确保路径前面有 (venv) ，即进入了虚拟环境。 （2）安装依赖的包可以试一下直接终端中执行以下命令，安装所需要的依赖，我个人经历是安装失败的，主要是 torch 和 torchvision 这两个包没有满足要求的版本。（这里 pip 安装包如果很慢的话建议自行百度配置一下 pip 的国内源） pip install -r requirements.txt 解决办法就是直接去 PyTorch 的官网上下载：https://download.pytorch.org/whl/torch_stable.html 当前的最新版就是1.6.0，直接搜一下 torch-1.6.0 可以帮助快速查找： cu102 是指 CUDA 版本，当前最新版是10.2对应102，如果电脑没有 GPU 则下载 cpu 开头的版本； torch-1.6.0 即对应的 torch 版本，大于 YOLOv5 要求的1.6即可； cp38 是指Python版本，使用 Python3.8 所以选择 cp38 的版本； 我是 Windows 系统所以选择 win 的版本，点击下载即可。 另外还要下载 torchvision ，同上一样的方法找到后下载下来。 下载完毕后，将两个 .whl 的文件拷贝到项目根目录下备用。 回到终端中手动安装这两个包，分别执行以下命令即可。 pip install torch-1.6.0-cp38-cp38-win_amd64.whl pip install torchvision-0.7.0-cp38-cp38-win_amd64.whl 然后重新执行以下命令安装需要的包，应该就没有什么问题了。 pip install -r requirements.txt （3）是否支持 CUDA安装完毕后打开Python控制台，输入以下命令测试是否支持 CUDA 。 import torch torch.cuda.is_available() 如果返回 True 则说明系统支持 CUDA 可以继续往下了。 四、运行接下来回到终端，直接执行如下命令即可测试YOLOv5了~ python detect.py --weights weights/yolov5s.pt 支持的参数还有很多，不输入则使用默认参数： (venv) D:\\Downloads\\yolov5-3.0&gt;python detect.py -h usage: detect.py [-h] [--weights WEIGHTS [WEIGHTS ...]] [--source SOURCE] [--output OUTPUT] [--img-size IMG_SIZE] [--conf-thres CONF_THRES] [--iou-thres IOU_THRES] [--device DEVICE] [--view-img] [--save-txt] [--classes CLASSES [CLASSES ...]] [--agnostic-nms] [--augment] [--update] optional arguments: -h, --help show this help message and exit --weights WEIGHTS [WEIGHTS ...] model.pt path(s) --source SOURCE source --output OUTPUT output folder --img-size IMG_SIZE inference size (pixels) --conf-thres CONF_THRES object confidence threshold --iou-thres IOU_THRES IOU threshold for NMS --device DEVICE cuda device, i.e. 0 or 0,1,2,3 or cpu --view-img display results --save-txt save results to *.txt --classes CLASSES [CLASSES ...] filter by class: --class 0, or --class 0 2 3 --agnostic-nms class-agnostic NMS --augment augmented inference --update update all models 稍微解释一下一些参数： -h。如上，查看帮助文档； –weights WEIGHTS。指定权重文件（.pt），不使用的话默认参数为 &#39;yolov5s.pt&#39; ； –source SOURCE。指定输入源，可以是图片（或带图片的文件夹）、视频文件、也可以是摄像头或网络视频； –output OUTPUT。指定检测结果的保存路径； –img-size IMG_SIZE。指定图片用于检测的大小，必须是32的倍数（一般为320、416、640），传入任意大小的图片后首先会 resize 为该大小的正方形再用于目标检测，越小越快，精度越低； –conf-thres CONF_THRES。指定置信度阈值，保留高于该阈值的目标； –device DEVICE。指定要使用的 GPU ，不使用GPU的话则指定为 &#39;cpu&#39; 即可； –view-img。目标检测到后显示图片； –save-txt。将目标检测结果保存到文本文件中，记录了目标的分类、位置和宽高； 项目自带了两张用于测试的图片存储在 inference/images 文件夹下，成功运行将看到下图所示的信息，打印了默认的参数和手动设置的 weights 参数，使用了 GPU ，两张图片的检测分别耗时 0.072s 和 0.029 秒。 如果执行以上命令成功后，标注了目标的图片将会保存到 inference/output 文件夹下，效果如图所示。 进一步的探索不再深入，本文目的仅在于将YOLOv5运行起来。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"https://mxy493.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"YOLO","slug":"YOLO","permalink":"https://mxy493.xyz/tags/YOLO/"}]},{"title":"京东2021校园招聘-测试开发笔试题：逆序五进制","date":"2020-08-30","updated":"2022-03-23","path":"2020083024215/","text":"题目：逆序五进制 时间限制： 3000MS 内存限制： 589824KB 题目描述：编写一个程序，首先将一个十进制正整数逆序【需要去掉前导0】，然后转换成五进制正整数，最后输出该五进制正整数。 输入描述 单组输入。 每组测试数据的输入占一行，输入一个十进制正整数n。 （n&lt;=100000） 输出描述每组测试数据的输出占一行，输出转换后所得的五进制正整数。 样例1： 输入： 1000 输出： 1 样例2： 输入： 77267 输出： 4420102 解题思路这个题思路其实很简单的，就正常逻辑先逆序，然后十进制转五进制就可以了。 选用了Python来解这个题，因为Python将字符串逆序就是一行代码，而在Python中整数和字符串之间的转换也是很容易的。代码在下面，没什么难度。虽然题目是让求五进制整数，代码中我是用的字符串，是完全没什么影响的。 源码hexadecimal = &#x27;&#x27; num = input() # 输入的是字符串 num = num[::-1] # 逆序 num = num.lstrip(&#x27;0&#x27;) # 去掉左侧的&#x27;0&#x27; num = int(num) # 字符串转整数 while num &gt; 0: hexadecimal = str(num % 5) + hexadecimal num //= 5 print(hexadecimal)","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"Leetcode 64. 最小路径和【C++】","date":"2020-08-29","updated":"2022-03-23","path":"2020082918380/","text":"地址：https://leetcode-cn.com/problems/minimum-path-sum/ 题目给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 解题思路动态规划问题。 状态：从左上角到 grid[i][j] 的最小路径和； 转移方程：F[i][j] = grid[i][j] + min(F[i - 1][j], F[i][j - 1]) 。 源码class Solution &#123; public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int r = grid.size(); // 行 int c = grid[0].size(); // 列 for(int i = 0; i &lt; r; i++)&#123; for(int j = 0; j &lt; c; j++)&#123; if(i == 0 &amp;&amp; j == 0) continue; int m = 2147483647; //最大正整数 if(i &gt; 0) m = min(m, grid[i - 1][j]); if(j &gt; 0) m = min(m, grid[i][j - 1]); grid[i][j] += m; //把每一个格子的值修改为从左上角到该格子的最小路径和 &#125; &#125; return grid[r - 1][c - 1]; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题 08.01. 三步问题【C++】","date":"2020-08-29","updated":"2022-03-23","path":"2020082942609/","text":"地址：https://leetcode-cn.com/problems/three-steps-problem-lcci/ 题目三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。 示例1: 输入：n = 3 输出：4 说明: 有四种走法 示例2: 输入：n = 5 输出：13 提示: n范围在[1, 1000000]之间 解题思路动态规划问题，满足【最优子结构】和【无后效性】，找【状态】，找【转移方程】。 状态：i个台阶有多少种上楼梯方式； 转移方程：F[i] = (F[i - 1] + F[i - 2] + F[i - 3]) % 1000000007。 只考虑最后一步，要上到第i阶楼梯可能的方法有最后一步分别上了1阶、2阶、3阶，对应3种，而对应第i阶可能的方法F[i]则为前三种情况的方法数的总和。 需要注意由于方法数太多可能越界，因此虽然转移方程逻辑上是没问题的，但在代码中最好逐项相加后立即求余，然后再继续加。 源码class Solution &#123; public: int waysToStep(int n) &#123; int mod = 1000000007; int f1 = 1; //1、2、3阶楼梯的方法很容易得出 int f2 = 2; int f3 = 4; if(n == 1) return f1; else if(n == 2) return f2; else if(n == 3) return f3; int fi; //大于3阶的楼梯数 for(int i = 4; i &lt;= n; i++)&#123; fi = ((f1 + f2) % mod + f3) % mod; // 需要先求余后再相加，否则可能溢出 f1 = f2; f2 = f3; f3 = fi; &#125; return fi; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 647. 回文子串【C++】","date":"2020-08-20","updated":"2022-03-23","path":"2020082054347/","text":"回文子串给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1：输入：&quot;abc&quot; 输出：3 解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot; 示例 2：输入：&quot;aaa&quot; 输出：6 解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot; 提示：输入的字符串长度不会超过 1000 。 解题思路很容易知道单个字符也是回文串，所以任意长度的字符串至少有 s.length() 个回文子串，问题就可以转化为求长度大于1回文子串的个数。 回文串有两种情况，一种长度为奇数，一种长度为偶数，区别就在于正中心是单个字符（例如 &#39;aba&#39; ）还是两个相同的字符（例如 &#39;abba&#39; ），所以只要把这两种情况区别开来，然后以其为中心不断往两边扩展，实际上只要判断两侧对应位置上的字符是否相同即可，每多找到一个就+1，一旦遇到不相等字符则不可能有更大的回文子串了，所以跳出循环。 源码class Solution &#123; public: int countSubstrings(string s) &#123; int len = s.length(); // 字符串长度 int count = len; for (int i = 0; i &lt; len - 1; i++) &#123; int c = 1; // 用于往两边扩展判断 //偶数回文串。下一个字符和当前字符相等 if (s[i] == s[i + 1]) &#123; count++; // 回文子串&#x27;aa&#x27; // 往两边扩展判断 while (i - c &gt;= 0 &amp;&amp; i + c + 1 &lt; len) &#123; if (s[i - c] == s[i + c + 1]) count++; else break; c++; &#125; &#125; c = 1; //奇数回文串 while (i - c &gt;= 0 &amp;&amp; i + c &lt; len) &#123; if (s[i - c] == s[i + c]) count++; else break; c++; &#125; &#125; return count; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"美团笔试题 - 不一样的逆序数","date":"2020-08-15","updated":"2022-03-23","path":"2020081564434/","text":"题目：不一样的逆序数时间限制： 3000MS 内存限制： 589824KB 题目描述小团最近对逆序数（将一个数字逐位逆序，例如1234的逆序数为4321）特别感兴趣，但是又觉得普通的逆序数问题有点太乏味了。于是他想出了一个新的定义：如果一个数的4倍恰好是它的逆序数，那么称这两个数是新定义下的逆序对。接下来给定一正整数n，问：不超过n的正整数中有多少对新定义下的逆序对？ 输入描述单组输入。 输入一个正整数n，n&lt;1e7。 输出描述第一行输出在不超过n的前提下有多少对逆序数，接下来每一行输出一对逆序数，以空格分隔。如果有多组逆序数，按照第一个数升序输出。 如果没有一对逆序数则直接输出0即可。 样例输入10000 样例输出1 2178 8712 提示在本题目的情景中我们认为：1234的逆序数为4321，1100的逆序数为11 解题思路其实这种题，思路并不难，暴力解遍历加判断就可以解决！ 但也显然的，这题为的就是让我们剔除大多数的无用数据，以更高的效率解题，直接遍历会超时的~ 很遗憾我笔试过程中真就没想出来怎么去剔除无用数据，不过笔试结束后仔细想了想，还是发现了一些规律。我们学过数学有点基础都知道，乘法运算末位数直接关系到结果的末位数，就从这一点入手，列表观察一下： 以x结尾的数: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 4*x的末位数: 0, 4, 8, 2, 6, 0, 4, 8, 2, 6 这时候再考虑一下题目要找的是 4*x 和 x 的逆序数相等这个 x ，那我们现在根据上面的规律再观察一下逆序数呢~ 以x结尾的数: 0xx0, 4xx1, 8xx2, 2xx3, 6xx4, 0xx5, 4xx6, 8xx7, 2xx8, 6xx9 4*x的末位数: 0xx0, 1xx4, 2xx8, 3xx2, 4xx6, 5xx0, 6xx4, 7xx8, 8xx2, 9xx6 看到这儿，是不是有头绪了，我们来分析一下： 以0结尾的数必然以0开头，但是怎么可能有以0开头的正整数呢，所以可以直接排除所有以0结尾的数； 再来看以1结尾的数，乘以4倍后必然以4结尾，如果这个数满足条件，那么它肯定以4开头，问题就来了，正整数4xx1乘了4倍以后怎么可能得到相同位数的比它自身小的1xx4，所以所有以1结尾的数也可以直接排除； 再看以3结尾的数，同上可知原数必然是2xx3的形式，而它的逆序数必然是3xx2，虽然不再小于原数，但是它们位数相等的情况下，2xx3乘以4以后至少也大于8xx2啊，所以所有以3结尾的数也可以直接排除； 其实同样的方法分析之后可以知道，第一种类型的有[0, 5]，第二种类型的有[1, 2, 4, 7]，第三种类型的有[3, 6, 9]； 只有以8结尾的数是可能找到符合条件的数的，只有2xx8乘以4可能得到8xx2。 都分析到这一步了就太简单了，只需要在遍历的时候只遍历以8结尾的数即可，以python为例可以这样 for n in range(8, num + 1, 10) ，不过还可以再过滤掉一些，因为有了以上的基础，可以很容易得到第一个符合条件的正整数是 2178 ，也就是说2178之前的数也是没必要遍历的，如果输入的正整数 n &lt; 2178 ，那么按照题意直接打印 &#39;0&#39; 即可。 注：写到这里，我发现自己竟然遗漏了一些东西，其实根据上面的分析，可能的数据必然是2xx8的形式，所以还应该筛选一下以2开头的数，只需要做一点小小的更改就可以了，改进后的代码也放在后面源码二中了。 源码一def inverse_number(): num = int(input()) # 不存在小于8的符合条件的正整数 if num &lt; 8: print(0) return exist = False # 是否存在符合条件的逆序数 # 影响性能最关键的一步，从8开始，到num结束，步长为10 for n in range(2178, num + 1, 10): rev = int(str(n)[::-1]) # n的逆序数 n4 = 4 * n # n的4倍 if n4 == rev: exist = True print(str(n) + &#x27; &#x27; + str(rev)) if not exist: print(0) if __name__ == &#x27;__main__&#x27;: inverse_number() 源码二def inverse_number(): num = int(input()) # 不存在小于8的符合条件的正整数 if num &lt; 8: print(0) return exist = False # 是否存在符合条件的逆序数 digits = 3 # 位数 # 影响性能最关键的一步，从8开始，到num结束，步长为10 n = 2178 # 从2178开始，第一个符合条件的数 while n &lt; num + 1: # 过滤掉非2开头的数 if n &gt; 3 * pow(10, digits): digits += 1 n = 2 * pow(10, digits) + 8 # 保持以2开头以8结尾 continue rev = int(str(n)[::-1]) # n的逆序数 n4 = 4 * n # n的4倍 if n4 == rev: exist = True print(str(n) + &#x27; &#x27; + str(rev)) n += 10 if not exist: print(0) if __name__ == &#x27;__main__&#x27;: inverse_number()","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"美团笔试题 - 小团的旅行线路","date":"2020-08-15","updated":"2022-03-23","path":"202008152656/","text":"题目：小团的旅行线路时间限制： 1000MS 内存限制： 65536KB 题目描述小团是一个旅游爱好者，快要过春节了，他想统计一下，在过去的一年中他进行过几次旅行，于是他打开了美团app的订单记录，记录显示了他的购买车票的记录。记录是按时间顺序给出的，已知一次旅行的线路一定是一个闭环，即起点和终点是同一个地点。因此当每找到一段闭合的行程，即认为完成了一次旅行。数据保证不会出现不在闭环路径中的数据。请你在小团的购票记录中统计出他全年共进行了多少次旅行？ 输入描述输入第一行包含一个正整数n，表示小团的购票记录数量。(1&lt;=n&lt;=10000) 接下来有n行，每行是两个长度不超过10的仅由小写字母组成的字符串S_a，S_b，表示购买了一张从S_a到S_b的车票。 输出描述输出仅包含一个整数，表示小团的旅行次数。 样例输入6 beijing nanjing nanjing guangzhou guangzhou shanghai shanghai beijing fuzhou beijing beijing fuzhou 样例输出2 解题思路需要注意的是，题目指明了两个重要信息，第一，记录是按时间顺序给出的；第二，不存在不在闭环中的数据。 也就是说从一个地方出发，总会在后续某一个行程中回到这个地方，那么问题就好解决了，只需要记录小团出发的城市，并且每添加一条数据我们就可以判断当前行程的到达城市是否之前的某个出发城市，如果是那么就找到了一个闭环，将旅行次数+1即可。 源码#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; int times = 0; // 次数 int n; // 数量 cin &gt;&gt; n; vector&lt;string&gt; vec; // 出发城市列表 for (int i = 0; i &lt; n; i++) &#123; string str1, str2; cin &gt;&gt; str1 &gt;&gt; str2; vec.push_back(str1); //添加当前出发地到出发城市列表 for (int j = 0; j &lt; vec.size(); j++) &#123; // 遍历出发城市列表判断当前行程的到大城市是否是之前的出发城市 // 如果是，则找到一个闭环，旅行次数+1，并将该城市从列表中删除 if (vec[j] == str2) &#123; vec.erase(vec.begin() + j); times++; &#125; &#125; &#125; cout &lt;&lt; times &lt;&lt; endl; return 0; &#125;","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"Hexo博客使用插件hexo-abbrlink生成永久短链接","date":"2020-07-04","updated":"2022-03-23","path":"2020070417822/","text":"一、简述使用Hexo搭建博客已经有很长一段时间了，文章的链接也一直是使用的默认格式，文章的链接格式可以在博客根目录下的 _config.yml 文件中修改，默认的配置如下所示，最终生成的链接大概是这样的：https://mxy493.xyz/2020/07/04/title 。 url: https://mxy493.xyz root: / permalink: :year/:month/:day/:title/ permalink_defaults: 更多关于永久链接的配置可以参考Hexo的官方文档：永久链接（Permalinks） 如果说文章的标题是英文，那么生成的链接还是比较简洁的，但如果是是中文的标题，比如2020年7月1日的标题为“成都有计算机方向岗位的互联网公司”的文章生成的文章链接将是这样的：http://mxy493.xyz/2020/07/01/%E6%88%90%E9%83%BD%E6%9C%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E5%90%91%E5%B2%97%E4%BD%8D%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E5%85%AC%E5%8F%B8/ 可以看到，默认配置下中文标题的文章链接是很复杂的类似于乱码的状态，而同样的中文标题，本文要达到的效果将是这样的：https://mxy493.xyz/2020070151339/ 二、使用 hexo-abbrlink 生成短链接使用生成短链接的插件 hexo-abbrlink 。 hexo-abbrlink：https://github.com/rozbo/hexo-abbrlink 在博客根目录下，使用如下命令安装插件： npm install hexo-abbrlink --save 安装好后，修改博客根目录下的 _config.yml 配置文件： permalink: :year:month:day:abbrlink/ # 具体配置参考Hexo文档https://hexo.io/zh-cn/docs/permalinks 注意：末尾必须要有 / ，否则点击某博文的时候将进行下载操作而不是跳转到该博文！ 另外还需要添加如下的对该插件的配置项： # abbrlink config abbrlink: alg: crc16 #support crc16(default) and crc32 rep: dec #support dec(default) and hex drafts: false #(true)Process draft,(false)Do not process draft # Generate categories from directory-tree # depth: the max_depth of directory-tree you want to generate, should &gt; 0 auto_category: enable: false depth: 注意：必须完整添加上述所有配置（可能是bug，当前版本为2.1.5，也许后续会修复），否则会生成失败！ 不同参数的效果如下所示： crc16 &amp; hex https://post.zz173.com/posts/66c8.html crc16 &amp; dec https://post.zz173.com/posts/65535.html crc32 &amp; hex https://post.zz173.com/posts/8ddf18fb.html crc32 &amp; dec https://post.zz173.com/posts/1690090958.html 最后，感谢开发者开发的这么好用的插件(╹ڡ╹ )","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"成都有计算机方向岗位的互联网公司","date":"2020-07-01","updated":"2022-03-23","path":"2020070151339/","text":"腾讯 阿里巴巴 字节跳动 美团点评 中国领先的生活服务电子商务平台，公司拥有美团、大众点评、美团外卖等消费者熟知的App，服务涵盖餐饮、外卖、打车、共享单车、酒店旅游、电影、休闲娱乐等200多个品类，业务覆盖全国2800个县区市。 OPPO 华为 汇顶科技 汇顶科技（SH：603160）是一家基于芯片设计和软件开发的整体应用解决方案提供商，目前主要面向智能终端、物联网及汽车电子领域提供领先的半导体软硬件解决方案。 育碧 tap4fun 成都创人所爱科技股份有限公司（tap4fun）成立于2008年，是致力于制作全球顶尖手游产品的游戏开发商，具备领先的自主研发和运营实力。 完美世界 完美世界控股集团是国际化的文娱产业集团，拥有A股上市公司完美世界股份有限公司（002624）。 西山居游戏 龙渊游戏 中国联通 招银网络科技 招商银行 中国邮政储蓄银行 四川新网银行 四川新网银行是全国三家互联网银行之一，于2016年12月28日正式开业。新网银行注册资本30亿元，由新希望集团、小米、红旗连锁等股东发起设立，是银监会批准成立的全国第七家民营银行，也是四川省首家民营银行。 京东 百词斩 奇安信 奇安信科技集团股份有限公司（以下简称奇安信）成立于2014年，专门为政府、企业，教育、金融等机构和组织提供企业级网络安全技术、产品和服务，相关产品和服务已覆盖大多数中央政府部门、中央企业和大型银行。 知道创宇 知道创宇是国内较早提出云监测与云防御理念的网络安全公司之一，经过多年的积累，利用在云计算及大数据处理方面的行业先进能力，可为客户提供具备国际先进安全技术标准的可视化解决方案，提升客户网络安全监测、预警及防御能力。 ThoughtWorks ThoughtWorks是一家创办于1993年的全球性软件及咨询公司，致力于用科技驱动商业变革。针对全球客户数字化业务提供专业组织转型咨询、创新软件交付、用户体验设计、产品及一体化解决方案等服务。客户遍及全球汽车、金融保险、医疗、旅游、运输、零售、电商、能源、公共事业等领域。 安恒信息 杭州安恒信息技术股份有限公司（简称：安恒信息）成立于2007年，科创板股票代码：688023 主营业务为网络信息安全产品的研发、生产及销售，并为客户提供专业的网络信息安全服务。 产品及服务涉及应用安全、大数据安全、云安全、物联网安全、工业控制安全及工业互联网安全等领域。 亚信科技 亚信科技控股有限公司（简称：亚信科技，股票代码：01675.HK）始于1993年，是领先的软件产品、解决方案和服务提供商，致力于成为大型企业数字化转型的使能者。 亚信安全 亚信安全是中国网络安全行业领跑者，以安全数字世界为愿景，旨在护航产业互联网。亚信安全在云安全、身份安全、端点安全、安全管理、高级威胁治理、威胁情报6大核心技术领域拥有国际领先技术，同时引领5G安全和工业互联网安全的创新。 四川中锐信息技术有限公司 四川中锐信息技术有限公司，成立于2006年，是中国工程物理研究院计算机应用研究所孵化建立的全资IT技术企业，军民融合发展平台。 移花互动 为出行用户提供全方位的移动互联网信息服务及移动电子商务服务。 成都正欣德信息技术有限公司 成都正欣德信息技术有限公司是一家面向欧美市场的互联网软件公司。公司自主研发并销售的系统优化和安全类软件，现已成为欧美最流行的系统软件产品。 宇信科技 北京宇信科技集团股份有限公司[股票代码：300674]（以下简称“宇信科技”或“公司”）是国内领先的金融科技赋能者，为金融机构提供IT咨询规划、软件产品、解决方案和实施、运维与测试、系统集成、业务运营等形态丰富的金融科技服务和产品，全面满足客户数字化转型的不同需要。 一汽大众 经纬恒润 北京经纬恒润科技有限公司（HiRain Technologies）是一家持续快速发展的高新技术企业，从事汽车（智能驾驶、车联网）领域的电子产品研发生产、解决方案咨询服务、研发工具服务以及特定场景自动驾驶运维等业务。 迈普通信 迈普通信技术股份有限公司（简称迈普）创立于1993年，是中国领先的网络产品及解决方案供应商，同时也是工信部重点支持的四大国产网络设备厂商之一。 成都柯尼特科技有限公司 成都柯尼特科技有限公司位于成都市高新西区，成立十余年来，现今已成为西南地区领先的集生产、研发、贸易为一体的医学检验领域的高科技型企业；有着优良产品研发和高端产品代理优势，主要服务于全国各地临床检验中心、疾病控制中心、科研院所、中心血站等生物检测实验室，并拥有专业的智能化物流系统、优质的专家团队和良好的医学转化合作建设平台，是一家立足西南、辐射全国的医学实验室综合服务商。 蚂蚁金服 思而科软件有限公司 思而科是一家提供全方位服务的电子商务资源公司，公司在中国的成都、上海、香港，美国的洛杉矶和纽约均设有机构。 成都晓多科技有限公司 基于深度学习技术，善于理解复杂语言的智能问答机器人、自动回复机器人。 ZDNS互联网域名系统国家地方联合工程研究中心 互联网域名系统北京市工程研究中心有限公司（ 简称：ZDNS ）是北京市发展和改革委员会认定的首批工程研究中心之一，并经国家发展改革委批准，升级为国家地方联合工程研究中心，且根据工业和信息化部批复，正式获批设立域名根服务器（ L 根镜像服务器 ）及域名根服务器运行机构。 臻识科技 臻识科技Vision-Zenith成立于2009年，是一家专注于边缘计算技术和智能硬件产品设计的AI公司，凭借创造性研发的智能ISP算法及嵌入式系统部署能力，基于深度学习方法的智能感知算法，正面向智能交通、智能安防、智慧商业等领域。 鲁大师（成都奇鲁科技有限公司） 国内外知名的系统评测工具品牌，旗下产品线包括PC端及移动端工具软件，如PC端鲁大师、移动端鲁大师及Dual Space等等。 咕咚运动 智能运动的倡导者和先行者，致力于成为全球领先的运动大数据和服务平台。 成都迅博科技 成都迅博科技有限公司（以下简称”迅博科技”）是领先的指挥体系解决方案提供商，致力于以业务沟通平台帮助政务行业客户提升工作效率。迅博科技多年的积累具备强大的自主研发与创新实力，拥有视音频编解码、多系统融合控制、业务数据处理等核心技术，拥有多项新型实用专利和多项产品著作权利，拥有自主注册商标，已全面形成以市场应用为导向、以客户需求为创新的业务产品体系，可提供融合指挥调度平台、视讯综合应用系统、应急值守管理系统等整体解决方案。 锐捷网络 锐捷自主研发的产品涵盖了 交换、 无线和 物联网、 云桌面、 路由器、 安全、 出口网关、 IT运维管理、 智慧教室、 智慧校园软件、 认证计费10条产品线。 中地数码 武汉中地数码科技有限公司是专业从事地理信息系统（GIS）研究、开发、应用和服务的云GIS软件平台和解决方案提供商。 傲梅科技 傲梅科技是一家致力于数据安全领域的IT公司，专注于数据备份产品的打造。所谓数据无价，傲梅科技以“永保全球数据更安全”为使命。 成都方位导向 成都方位导向科技开发有限公司是一家从事“ 数字城市”开发的高科技企业， 公司主要从事基于地理信息系统（GIS）、全球定位系统（GPS）、遥感（RS） 技术的面向城规、国土、环保、交通、旅游等行业的空间信息的分析、处理、 研发和集成。 戴尔科技 上海易宝软件有限公司 上海易宝软件有限公司成立于1985年，集团总部位于香港，是一家全球领先的软件和IT外包供应商，专长于软件开发、信息技术和个性化、专业化服务。业务遍布全国十几个城市和地区。 爱奇艺 咪咕音乐 咪咕文化科技有限公司（简称“咪咕公司”）是中国移动面向移动互联网领域设立的，负责数字内容领域产品提供、运营、服务的一体化专业子公司，是中国移动旗下音乐、视频、阅读、游戏、动漫数字业务板块的唯一运营实体，下设咪咕音乐、咪咕视讯、咪咕数媒、咪咕互娱、咪咕动漫五个子公司。 三七互娱 三七互娱（股票代码：002555），中国互联网百强企业，商务部2019-2020年度国家文化出口重点企业。公司涵盖游戏、在线教育等业务板块，同时积极布局影视、音乐、艺人经纪、动漫、泛文娱媒体、VR/AR、文化健康、社交等文化创意领域。 极米科技 成都极米科技股份有限公司（简称极米）成立于2013年11月，是一家专注于激光电视和智能投影的设计、研发和制造的高科技公司。 Camera360（成都品果科技有限公司） 成都品果科技有限公司是一家以移动影像服务为核心业务的科技创新企业，公司总部位于中国四川省成都市，成立于2010年10月。 四川迅游网络科技股份有限公司 迅游是四川迅游网络科技股份有限公司推出的专门针对网络游戏的加速产品。 成都数维通信技术有限公司 成都数维通信技术有限公司成立于2008年，在全国各地均设有办事处，是一家专注于网络通信设备研发、生产、制造的高新技术企业，为电信增值业务、网络信息安全、移动信令监测等领域提供专业的网络数据可视化管控解决方案。 成都海说科技有限公司 海说软件围绕「定制开发+最敏捷AI项目管理平台+视频/直播转码处理」提供SaaS服务。 Tower（成都彩程软件设计有限公司） 一家专注用户体验研究、专业从事互联网产品设计与研发的互联网公司。 成都中云天下科技有限公司 TestBird（成都中云天下科技有限公司）成立于2013年，专注于移动互联网，产品包括移动广告、移动产品、移动测试，涵盖手游、电商、广告、营销等行业，覆盖港澳台、东南亚、日韩、欧美等全球市场，是工信部唯一颁发证书的手游测试中心，先后被评为国家高新技术企业、国家软件公共服务平台、APP云测试公共技术平台。依靠全球首创鹰眼识别技术，成为全球最大手游测试平台；凭借优质的移动广告服务，成为移动广告中的新势力。 成都信必优信息技术有限公司 主营业务是IT技术人员外包、智能终端测试、项目外包、RPA服务、ODC搭建等。 锐明技术 深圳市锐明技术股份有限公司，集研发、制造、销售和系统集成于一体的国家级高新技术企业。锐明致力成为全球领先的、商用车综合监控和智能化解决方案供应商。 联发科技 全球第四大无晶圆半导体公司。 华雁智能科技 公司处于软件和信息技术服务行业，是以大数据分析与视觉智能为核心的行业物联网解决方案服务提供商，致力为实施能源互联网发展战略的两大电网公司及其所属网省电力公司、发电企业等客户提供基于大数据分析与视觉智能为核心的平台软件、智能系统、网络通信等解决方案及相关技术服务。 华如科技 北京华如科技股份有限公司成立于2011年，致力于军事仿真、虚拟现实、人工智能和大数据应用技术研究及产品开发，在作战实验、装备论证、模拟训练、试验鉴定、综合保障等应用领域。 成都天佑创软科技有限公司 业务范围包括：工业软件及工具的开发、咨询服务、销售服务，工业控制系统的研发、服务咨询与销售，数字化机电系统或产品的研制、销售，面向工业互联网+的研发服务等。 四川中电启明星信息技术有限公司 四川中电启明星信息技术有限公司是国家电网公司系统内公司，是为大型企业提供专业化信息系统咨询开发、实施、运维服务的高新技术企业。 华文云计算 《华文云计算》是成都华文科技有限公司旗下产品门户网站，成都华文科技有限公司是一家具有创新型发展模式的互联网软件企业，致力于互联网相关的产品研发和运营。 宁静之盾成都科技有限公司 宁静之盾成都科技有限公司是一家网络安全服务提供商，专注于终端安全防御与漏洞挖掘，致力于防御服务终端的未知威胁。 绿盟科技 绿盟科技在国内设有40多个分支机构，为政府、运营商、金融、能源、互联网以及教育、医疗等行业用户，提供全线网络安全产品、全方位安全解决方案和体系化安全运营服务。 四川观想科技股份有限公司 四川观想科技股份有限公司是一家以计算机软硬件及网络通信技术研发为核心，以行业信息化产品研制及服务为特色的高科技企业。 顽未科技 成都顽未科技有限公司致力于提供从云到端的软件整体解决方案，技术领域包括云服务与运维、低功耗物联网、移动互联网应用等，业务涉及企业管理、银行、教育、制造等领域。 北京华清瑞达 成都分公司 军工企业，涉及到做雷达系统、侦察方面的，具体不太了解~ 华鲲振宇 2020年成立，主要做鲲鹏服务器，有成都政府投资，长虹代工，以及与华为合作，背景比较强。","categories":[],"tags":[]},{"title":"主流的个人博客搭建方案","date":"2020-07-01","updated":"2022-03-23","path":"2020070150115/","text":"Hexo快速、简洁且高效的博客框架，基于 Node.js ，用户量极大，文档完善，主题多。 HUGOGo 语言编写的开源静态网站生成器，主题多，速度快。 Jekyll基于 Ruby 的静态网站生成器。用户多，主题多。 Metalsmith简单可扩展的开源静态网站生成器。 VuePressVue 驱动的静态网站生成器 Expose简单的静态网站生成器。 Wintersmith简单灵活的开源静态网站生成器。 Next.jsThe React Framework. Nuxt.js基于 Vue 的开源 Web 开发框架。 Gatsby基于 React 的开源框架，快速构建网站和应用程序。 Typecho基于 PHP 的博客平台。 GitBook适合写电子书或者项目文档，支持输出多种格式文档。 docsify文档生成器，更适合用于编写项目文档。 MkDocs同 docsify 。","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"2020.05.21 牛客网 校招全国统一模拟笔试（2020年5月场）- C++方向","date":"2020-05-21","updated":"2022-03-23","path":"2020052151134/","text":"几天前报名了牛客网的“校招全国统一模拟笔试（2020年5月场）- C++方向”，考试时间也就是今晚的 19:00 - 21:00 ~ 整体题目难度中等吧，至少算不上难的。总共20个选择题，3个编程题，编程题我做出来两个，最后一个时间不够了。 下面大概写一下我的3个编程题的解题思路(●’◡’●) 题目一：偶串（1）题目 时间限制： C/C++1秒，其他语言2秒 空间限制： C/C++ 32768K，其他语言65536K 64bit I0 Format: %lld 如果一个字符串由两个相同字符串连接而成，就称这个字符串是偶串。例如 &quot;xyzxyz&quot; 和 &quot;aaaaa&quot; 是偶串，但是 &quot;ababab&quot; 和 &quot;xyzxy&quot; 却不是。 牛牛现在给你一个只包含小写字母的偶串 s ，你可以从字符串 s 的未尾删除1个或者多个字符，保证删除之后的字符串还是一个偶串，牛牛想知道删除之后得到最长偶串长度是多少。 输入描述： 输入包括一个字符串 s ，字符串长度 length（2 &lt;= length &lt;= 2000），保证 s 是一个偶串且由小写字母构成 输出描述： 输出一个整数，表示删除之后能得到的最长偶串长度是多少。保证测试数据有非零解 示例（输入输出示例仅供调试，后台判题数据一般不包含示例） 输入： abaababaab 输出： 6 （2）解题思路首先容易观察到的是，这个偶串的长度其实始终是偶数，即使我们从字符串 s 末尾删掉字符也必然是两个一组删除的，因为不可能存在长度为奇数的偶串。 又由于给定的字符串本身就是一个偶串，同时至少需要删除一个字符，所以直接先删掉末尾两个字符，然后循环，直接使用 substr() 函数比较字符串 s 的前一半和后一半是否相同，相同则输出 s 的长度，跳出循环结束运行；不相同则继续删掉末尾两个字符，重复上述步骤。 小思路：其实可以把循环前面的删除字符操作统一写到循环内部，逻辑更加清晰！ （3）代码#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() &#123; string str; cin &gt;&gt; str; str.pop_back();//至少删除一个字符 str.pop_back();//至少删除一个字符 while (!str.empty()) &#123; int len = str.size() / 2;//字符串长度的一半 if (str.substr(0, len) == str.substr(len, len)) &#123; cout &lt;&lt; str.size() &lt;&lt; endl; break; &#125; else &#123; //删除两个字符 str.pop_back(); str.pop_back(); continue; &#125; &#125; return 0; &#125; 题目二：制造回文（1）题目 时间限制： CIC++1秒，其他语言2秒 空间限制： C/C++ 32768K，其他语言65536K 64bit 10 Format: %lld 牛牛有一些字母卡片，每张卡片上都有一个小写字母，所有卡片组成一个字符串 s 。牛牛一直认为回文这种性质十分优雅，于是牛牛希望用这些卡片拼凑出一些回文串，但是有以下要求： 每张卡片只能使用一次 要求构成的回文串的数量最少 牛牛想知道用这些字母卡片，最少能拼凑出多少个回文串。 例如： s = &quot;abbaa&quot;，输出1，因为最少可以拼凑出 &quot;ababa&quot; 这一个回文串 s = &quot;abc&quot;，输出3，因为最少只能拼凑出 &quot;a&quot;，&quot;b&quot;，&quot;c&quot; 这三个回文串 输入描述： 输入包括一行，一个字符串 s，字符串 s 长度 length （1 &lt;= length &lt;= 1000）. s 中每个字符都是小写字母 输出描述： 输出一个整数，即最少的回文串个数。 示例（输入输出示例仅供调试，后台判题数据一般不包含示例） 输入： abc 输出： 3 （2）解题思路之前在 Leetcode 上做过这个题。这一次思路大体也和之前一样，但有一点使得逻辑更加简单~ 题目的意思其实就是用尽可能多的字符来构造一个回文串。构成回文串的规律是，同一个字符的偶数个数一定可以是任意回文串的一部分，换言之偶数个数的同一字符对能生成的最少的回文串个数是没有影响的，所以我们应该关注的重心是个数为奇数的字符。 要使构成的回文串的个数最少，那么根据前面所说的，首先我们尽可能的去构造一个最长的回文串，也就是把所有偶数个数的字符都用来构造这个回文串，这其中也包括 &quot;aaa&quot; 中的两个 &#39;a&#39; 也可以用于构造这个回文串，此时，如果有剩下的字符，显然都是单个的字符了。 但事实上前面构造的最大回文串长度为偶数，其实还可以在其正中间插入任意一个单个的字符，插入后仍然是回文串，此时剩下的单个字符的个数，也就是其余可以构成的回文串的个数了。 普遍情况下，可以根据前面所述的得到：最少的回文串个数 = 奇数个数的字符数 - 1 + 1 = 奇数个数的字符数 但是特殊的，需要考虑没有奇数个数的字符的情况，这种情况也就更简单了，所有的字符都用来构造唯一的一个回文串，最少的回文串个数也就是 1 。 （3）代码#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; using namespace std; int main() &#123; string str; cin &gt;&gt; str; //统计不同字符的个数 vector&lt;pair&lt;char, int&gt;&gt; words; for (int i = 0; i &lt; str.size(); i++) &#123; bool exist = false; for (int j = 0; j &lt; words.size(); j++) &#123; if (words[j].first == str[i]) &#123; exist = true; words[j].second++; &#125; &#125; if (exist == false) &#123; words.push_back(&#123; str[i], 1 &#125;); &#125; &#125; int odd = 0;//奇数个数的字符数 for (int i = 0; i &lt; words.size(); i++) &#123; if (words[i].second % 2 != 0) &#123; odd++; &#125; &#125; cout &lt;&lt; (odd &gt; 0 ? odd : 1) &lt;&lt; endl; return 0; &#125; 题目三：猜数游戏（1）题目 时间限制： CIC++1秒，其他语言2秒 间限制： C/C++ 32768K，其他语言65536K 64bit 1O Format: %lld 牛牛和羊羊在玩一个有趣的猜数游戏。在这个游戏中，牛牛玩家选择一个正整数，羊羊根据已给的提示猜这个数字。第个提示是 &quot;Y&quot; 或者 &quot;N&quot; ，表示牛牛选择的数是否是的倍数。 例如，如果提示是 &quot;YYNYY&quot;，它表示这个数是1，2，4，5的倍数，但不是3的倍数。 注意到一些提示会出现错误。例如：提示 &quot;NYYY&quot; 是错误的，因为所有的整数都是1的倍数，所以起始元素肯定不会是 &quot;N&quot; 。此外，例如 &quot;YNNY&quot; 的提示也是错误的，因为结果不可能是4的倍数但不是2的倍数。 现在给出一个整数 n ，表示已给的提示的长度。请计算出长度为 n 的合法的提示的个数。 例如 n = 5 ，合法的提示有： YNNNN YNNNY YNYNN YNYNY YYNNN YYNNY YYNYN YYNYY YYYNN YYYNY YYYYN YYYYY 所以输出 12 输入描述： 输入包括一个整数 n （1 &lt;= n &lt;= 10^6） ，表示已给提示的长度。 输出描述： 输出一个整数，表示合法的提示个数。因为答案可能会很大，所以输出对于 1000000007 的模 示例（输入输出示例仅供调试，后台判题数据一般不包含示例） 输入： 5 输出： 12 （2）解题思路这个题看完题目就知道是动态规划了，知道难搞，不过还是尝试着做了一下，时间不够，大概写了个框架出来，明明还有十多分钟的，不知道为啥就自动给我交卷了…… 下面的代码是考试结束后我继续完善的，自己本地简单测试了几组较小的数据，主要是我也不知道正确答案应该是什么，就不方便测试了，也不确定代码的正确性。另外我觉得我这代码就算逻辑是对的，但是性能也不太好，应该是有更好的办法的o_o …. 大概思路就是逐个的插入“提示”，也就是逐个的插入 &#39;Y&#39; 或 &#39;N&#39; ，判断当前插入是否合法，直到字符串长度达到输入的 n 并且该提示字符串合法，则合法的提示个数+1。 其中我判断当前插入的字符是否合法的想法是，我认为只有插入的是 &#39;Y&#39; 才可能是不合法的，比如当前第四个字符插入的是 &#39;Y&#39; ，也就是说是 4 的倍数，但字符串前面可能第二个提示是 &#39;N&#39; ，即不是 2 的倍数，那么当前的插入就矛盾了，不合法。另外，前述不合法的情况，只需要判断当前第 i 个字符是 &#39;Y&#39; ，只要找到一个 i 的约数对应的提示为 &#39;N&#39; 则当前提示不合法。 （3）代码#include &lt;iostream&gt; #include &lt;string&gt; using namespace std; //动态规划，参数分别为合法提示的个数、可能的提示、剩余的提示个数 void dp(long long&amp; count, string way, int n) &#123; //判断当前选择是否合法 bool legal = true; int l = way.size();//当前长度 char ch = way.back();//末尾字符即当前的选择 for (int i = 1; ch == &#x27;Y&#x27; &amp;&amp; i &lt; l - 1; i++) &#123; if (l % (i + 1) == 0 &amp;&amp; way[i] == &#x27;N&#x27;) &#123; legal = false; return; &#125; &#125; if (legal == true &amp;&amp; n == 0) &#123; count++; //cout &lt;&lt; way &lt;&lt; endl;//打印合法的提示 return; &#125; //做选择 dp(count, way + &quot;Y&quot;, n - 1); dp(count, way + &quot;N&quot;, n - 1); &#125; int main() &#123; int n; cin &gt;&gt; n; long long count = 0; dp(count, &quot;Y&quot;, n - 1); cout &lt;&lt; count &lt;&lt; endl; return 0; &#125;","categories":[],"tags":[]},{"title":"2020.05.11 字节跳动笔试题目:记事本程序","date":"2020-05-11","updated":"2022-03-23","path":"202005119793/","text":"都5月份了，意外收到字节跳动的笔试链接，今天上午十点到十二点的笔试。 四个编程题目，换句话说就是考算法吧，一点不出意外的我只做出来一个题，另外三个题几乎都没时间看，实不相瞒做出一个题我都很激动了……第二个题目大概看了下，很显然的动态规划的题目，给我两个小时也不一定能做出来的那种…… 啊啊啊，我真菜……😭 题目忘了截图，题目大概是这样的~ 一个记事本程序，里面的内容用字符串 S 表示。 可以执行以下四种命令： 1 W：表示添加字符串 W 到字符串 S 的末尾； 2 k：表示删除字符串 S 末尾的 k 个字符； 3 k：表示输出字符串 S 的第 k 个字符； 4：回滚上一步对字符串 S 的操作，操作 3 并没有对字符串进行更改，所以只回滚1、2两种操作。 输入规范： 第一行输入一个整数 N ，表示总共有多少步操作； 从第二行开始输入每一步具体的命令。 示例： 8 1 abc 3 3 2 3 1 xy 3 2 4 4 3 1 输出说明： 输出： c y a 说明： 1 abc // 字符串S默认初始为空&quot;&quot;，第一步插入&quot;abc&quot;后S变为&quot;abc&quot; 3 3 // 输出S的第三个字符，即输出&#x27;c&#x27; 2 3 // 删除字符串S的末尾3个字符，删除后S变为&quot;&quot; 1 xy // 在字符串S末尾插入&quot;xy&quot;，插入后S为&quot;xy&quot; 3 2 // 输出字符串S的第二个字符，即输出&#x27;y&#x27; 4 // 回滚，即回滚对&quot;xy&quot;的插入，回滚后S为&quot;&quot; 4 // 回滚，即回滚对字符串S末尾3个字符的删除操作，回滚后S为&quot;abc&quot; 3 1 // 输出字符串S的第一个字符，即输出&#x27;a&#x27; 解题思路毕竟是笔试啊，有点慌。因为需要对一些操作步骤进行回滚，一开始我想着应该要把操作的步骤记录下来，所以我定义了一个 vector&lt;pair&lt;int, string&gt;&gt; 类型的数组用于保存输入的每一步命令，每个命令保存为 int 类型的整数，参数保存为 string 类型的字符串，主要是为了兼容不同的参数，如果是命令 4 则将其参数保存为空字符串 &quot;&quot; 。 最初的想法是遍历保存下来的命令数组一步一步执行就好了，但是到处理命令 4 的操作时就遇到问题了，感觉处理回滚操作很麻烦，同时觉得回滚这个操作完全就是回溯法相同的模式，想了想觉得应该可行，就改用了回溯法来执行每一步命令。 定义回溯函数 void execute(string S,vector&lt;pair&lt;int, string&gt;&gt;&amp; vec, int&amp; seq, bool&amp; rollback) ，字符串 S 即题目中所述的字符串，数组 vec 即保存下来的命令数组，seq 为当前命令执行到的位置，回滚操作需要记录当前命令执行到的位置，所以 seq 采用引用传参的方式，布尔型的 rollback 用于判断当前命令是回滚操作还是正常的顺序执行。 seq 是递增的，当所有命令都执行完毕后 seq == vec.size() ，此时已经没有可执行的命令，退出回溯函数。 默认要执行当前的命令，对于命令1、2、3，当前命令执行完毕后，只需要将 seq + 1，递归执行下一条命令。对于命令4，回滚操作，对于回溯法来说也就是 return 就可以了，但也需要将 seq + 1，即当前回滚命令已执行。 具体的回滚操作需要交给具体的某一步操作去执行，对于命令3，不需要做任何处理，继续往上回溯，对于命令1、2，在执行递归的下一行，判断 rollback == true 则表明在后续命令中遇到了回滚操作，这里就需要进行回滚处理，对于命令1来说，即删除原本插入的字符串；对于命令2来说即恢复原本删除的字符串。回滚操作完毕需要将 rollback 重新置为 false 。 处理完回滚操作后，还需要继续顺序执行剩下的命令，我用一个 do &#123;...&#125;while(...) 循环来模拟递归执行命令的操作，也就是让命令的执行恢复到顺序执行。 代码#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; void execute(string S, vector&lt;pair&lt;int, string&gt;&gt;&amp; vec, int&amp; seq, bool&amp; rollback) &#123; if (seq == vec.size()) return; do &#123; string str = vec[seq].second;//命令参数 int k = 0;//将字符串参数vec[seq].second转换为整数k if (vec[seq].first == 2 || vec[seq].first == 3) &#123; for (int i = 0; i &lt; str.size(); i++) &#123; k = k * 10 + (str[i] - &#x27;0&#x27;); &#125; &#125; switch (vec[seq].first) &#123; case 1: S += str;//末尾插入字符串str seq += 1; execute(S, vec, seq, rollback); if (rollback == true) &#123; //回滚 S.erase(S.begin() + S.size() - str.size(), S.end());//撤销插入 rollback = false; &#125; break; case 2: &#123; string tmp = S.substr(S.size() - k, k);//临时记录要删除的k个字符 S.erase(S.begin() + S.size() - k, S.end());//删除末尾k个字符 seq += 1; execute(S, vec, seq, rollback); if (rollback == true) &#123; //回滚 S += tmp;//插销删除 rollback = false; &#125; break; &#125; case 3: cout &lt;&lt; S[k - 1] &lt;&lt; endl;//输出第k个字符 seq += 1; execute(S, vec, seq, rollback); if (rollback == true) return;//不处理回滚操作 break; case 4: rollback = true;//回滚 seq += 1; return; default: break; &#125; &#125; while (seq &lt; vec.size()); &#125; int main() &#123; string S = &quot;&quot;; int N;//要执行的命令数 cin &gt;&gt; N; vector&lt;pair&lt;int, string&gt;&gt; vec;//输入命令 for (int i = 0; i &lt; N; i++) &#123; int seq; string str = &quot;&quot;; cin &gt;&gt; seq; if (seq != 4) &#123; cin &gt;&gt; str; &#125; vec.push_back(&#123; seq, str &#125;); &#125; bool rollback = false;//是否回滚命令 int q = 0;//命令序号 execute(S, vec, q, rollback);//执行命令vec[q]，该命令不是回滚命令 return 0; &#125;","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"使用jQuery on()方法绑定动态添加的元素","date":"2020-05-05","updated":"2022-03-23","path":"2020050549325/","text":"关于 jQuery on() 方法的 API 文档：https://api.jquery.com/on/ .on( events [, selector ] [, data ], handler ) 网页往往需要根据服务器返回的数据动态的添加HTML元素，但是动态添加的HTML元素用常规方法绑定事件往往没有效果。 可以使用 jQuery 的 on() 方法进行动态绑定，使用起来很简单，网上也有很多这个方法的使用说明，但是我觉得网上的都没有把最重要的问题说清楚。 实际使用的代码大概是这样的： $(&quot;#parent&quot;).on(&quot;click&quot;, &quot;#child&quot;, function()&#123; ...... &#125; 其中最重要的是两个选择器 $(&quot;#parent&quot;) 和 &quot;#child&quot; 。 前面的选择器是选择一个父元素，注意是要动态添加的元素的父元素，我的理解是，只要能保证这个父元素不受动态添加的元素的影响即可，比如说你可以直接将其设置为 $(&quot;body&quot;) 。 后面的 &quot;#child&quot; 才是要绑定事件的元素，比如说动态添加了一个 &lt;button id=&quot;btn&quot;&gt;确定&lt;/button&gt; 按钮，要绑定这个动态添加的 button 的点击事件，就应该将后面的选择器设置为 &quot;#btn&quot; 。","categories":[{"name":"前端","slug":"前端","permalink":"https://mxy493.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://mxy493.xyz/tags/jQuery/"}]},{"title":"Leetcode 面试题56 - I.数组中数字出现的次数【C++】","date":"2020-04-28","updated":"2022-03-23","path":"2020042825600/","text":"地址：https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/ 题目一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 示例 1： 输入：nums = [4,1,4,6] 输出：[1,6] 或 [6,1] 示例 2： 输入：nums = [1,2,10,4,1,4,3,3] 输出：[2,10] 或 [10,2] 限制： 2 &lt;= nums &lt;= 10000 解题思路这个题暴力解其实很简单，比如遍历数组，如果是第一次遍历到的元素，就将其加入到返回数组中，对遍历到的每一个元素，去返回数组中查找其是否已遇到过，如果返回数组中已存在，则将其从返回数组中删除，最终遍历完整个数组，则返回数组中剩下的元素即只出现过一次的元素。时间复杂度大于O(n)。 然后我想到了用集合来做同样的工作，只不过集合有 find() 函数可以直接判断集合中是否已存在某一个元素，思路都是一样的，换汤不换药。其实我觉得这么做并不是题目要求时间复杂度为O(1)的意思，不过提交还是通过了。 官方题解是用异或来做的，挺巧妙的办法，感觉一般不容易想到。 代码class Solution &#123; public: vector&lt;int&gt; singleNumbers(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ans;//返回值 set&lt;int&gt; ns;//存储数组中唯一的元素 for (int i = 0; i &lt; nums.size(); i++) &#123; set&lt;int&gt;::iterator index = ns.find(nums[i]); if (index == ns.end()) &#123; ns.insert(nums[i]); &#125; else &#123; ns.erase(index); &#125; &#125; //集合转数组 for (set&lt;int&gt;::iterator i = ns.begin(); i != ns.end(); i++) &#123; ans.push_back(*i); &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 33.搜索旋转排序数组【C++】","date":"2020-04-27","updated":"2022-03-23","path":"2020042730620/","text":"地址：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/ 题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 解题思路这个题如果是已排序的数组，那么用二分查找应该就是最快的，但是题目是进行了旋转后的数组。 其实仔细观察不难发现，相当于题目已经把一个已排序的数组分成了两部分，前面一部分的数较大，后面一部分的数较小。以示例中的数组 [4,5,6,7,0,1,2] 为例，前一部分的数为 [4,5,6,7] ，后一部分的数为 [0,1,2] ，前面一部分任意一个数都是大于后面一部分的数的。 与标准二分查找不同的是，这个题的二分的点并不是数组的正中心，并且我们也不知道具体是从哪里二分的（需要遍历查找）。但是可以肯定的是，题目给出的 target 只可能属于两部分中的一个部分，换言之 target 要么大于数组的第一个数，要么小于数组的最后一个数。 那么剩下的事情就好办了，只需要遍历找出 target 的位置即可，当然这里并不能用到二分查找，因为没法确定边界的位置，对于前面一部分来说没法确定右边界的位置，而对于后面一部分来说，没法确定左边界的位置，当然也可以通过遍历找到边界的位置的，但是显然既然都要遍历数组了，不就可以直接进行逐个比较了吗。 首先判断 target 可能在前面一部分还是在后面一部分，如果在前面一部分则从前往后遍历，如果在后面一部分则从后往前遍历，找到了就跳出循环，返回结果。如果找不到函数返回默认值 -1 。 代码class Solution &#123; public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int ans = -1; if (nums.empty()) return -1; if (target &gt;= nums[0]) &#123; //在前半部分找 for (int i = 0; i &lt; nums.size(); i++) &#123; if (nums[i] == target) &#123; ans = i; break; &#125; &#125; &#125; else if (target &lt;= nums.back()) &#123; //在后半部分找 for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; if (nums[i] == target) &#123; ans = i; break; &#125; &#125; &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"2020.04.26 记录今天的两个人生第一次","date":"2020-04-27","updated":"2022-03-23","path":"2020042757742/","text":"记录一下特别的今天，两个人生第一次(ง •_•)ง （1）求职第一次被拒绝3月27投的美团点评的简历，4月2日做了笔试，4月15日第一轮面试，然后是一周多没消息，昨天差点都发消息问面试官了，最后没问，结果今天一早醒来，美团点评就彻底凉凉了ಠಿ_ಠ 也不是多难过，确实自己太菜了，还是有点自知之明，所以也没抱着那种一定会拿下这个岗位的心态，后面继续努力吧！ （2）第一次域名备案成功也不至于多么激动人心啦，只不过确实人生第一次做这个事😂 mxy493.xyz 这个域名已经注册一年多了，但是一直没备案。一方面因为我这博客用的是 GitHub 的静态网页服务，不备案也不影响使用；另一方面，域名备案必须要有服务器，但是，买服务器得花钱吖，而且它贵吖，关键是我又没有那个需求，所以就一直都没买过云服务器，也就没发备案域名。 这一次的云服务器也不是花钱买的，这次因为疫情的原因，阿里云搞活动《学生“在家实践”计划》，每天早晨八点都可以抢免费的云服务器，所以我上周抢到了一个，应该并不是多难抢的，只不过尽量准点去抢应该就不会抢不到。 上周末申请了域名备案，刚好一周的时间，今天通过了审核，很棒👍🏻👍🏻","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://mxy493.xyz/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"2020.04.26 鲁大师C++实习笔试题目","date":"2020-04-26","updated":"2020-04-28","path":"2020042641730/","text":"昨天在拉勾上投了鲁大师的C++实习岗位，今天下午接到了HR的电话，商量了下晚上七点做笔试。 没有使用在线笔试平台，HR直接发给我的一个word文档。简要记录一下，以下解答为笔试结束后整理~ 题目一：符号&amp;的意义题目：下列几个C语言表达式是否正确？如果正确，写出它们表达的意思： a&amp;b a&amp;(&amp;b) a&amp;&amp;b a**b 解答： 正确。结果为 a 与 b 的二进制按位相与； 不正确。括号内为取址符，取变量 b 的地址；括号外为按位与运算； 正确。逻辑运算符，当且仅当 a ， b 同时为真时，结果为真； 正确。前一个为乘法运算，后一个表示指针，即变量 a 乘上指针 b 所指向的变量的值。 题目二：内存分配题目：char a[] = &quot;Hello&quot;; sizeof(a) 是多少？char *b= &quot;Hello&quot;; sizeof(b) 是多少？ 解答： char a[] = &quot;Hello&quot;; sizeof(a) 是 6。五个字符加一个结束符 &#39;\\0&#39; ； char *b= &quot;Hello&quot;; sizeof(b) 在32位系统下是 4 ，64位系统下是 8 ，即 sizeof(char*) 的大小。 题目三：宏定义题目：#ifndef，#define，#endif 是做什么用的？构思一个场景用一下。 解答： 宏定义。#define 为定义一个宏；#ifndef 判断一个宏是否已经定义过，避免重复定义；#endif 搭配 #ifndef 使用，结束判断。 场景：可以用于头文件的引用，多文件相互引用时，可能会存在重复引用的情况，这时就可以先判断一个头文件是否已经引用，如果未引用，则通过宏定义引用，否则不再重复引用。 题目四：static题目：C语言函数前面加static，和C++类的成员函数前面加static，两者的意义有何区别？ 解答： 在C和C++中 static 都有扩展生存周期的作用，static 静态变量在其作用范围内仅进行一次初始化操作。 C++中在类的成员函数前面加 static 表示该函数为静态成员函数，这个函数不属于这个类的任何一个实例化对象，而仅属于这个类，并且静态成员函数内部也不能访问该类的非静态成员。 C/C++ 中 static 的用法全局变量与局部变量：https://www.runoob.com/w3cnote/cpp-static-usage.html 题目五：找出程序的问题题目：这段代码有哪些问题。 char* GetTextA(void) &#123; char p[] = &quot;AAAAAAAA&quot;; return p; &#125; char* GetTextB(void) &#123; char *p = &quot;BBBBBBBB&quot;; return p; &#125; void main(void) &#123; char *p = NULL; p = GetTextA(); printf(p); p = GetTextB(); printf(p); &#125; 解答： char* p = &quot;BBBBBBBB&quot;; 中 &quot;BBBBBBBB&quot; 为 const char* 类型的常量，不能用来初始化一个 char* 类型的变量。可以使用 const_cast&lt;&gt;() 函数去除常量性，也就是可以将该语句更改为：char* p = const_cast(&quot;BBBBBBBB&quot;); 。 函数GetTextB(void) 和 GetTextB(void) 中的变量 p 为局部变量，作用域为所在的函数内部，函数调用结束后变量 p 所占用的内存就会被释放掉，而 main() 函数中的指针 p 仍指向已释放内存的地址，输出的结果将是无意义的。一个简单的解决办法是，可以将两个函数中的 p 声明为 static 的，延长其生命周期，直到程序运行结束以后才释放。（参考题目四） 修改后的代码为： char* GetTextA(void) &#123; static char p[] = &quot;AAAAAAAA&quot;; return p; &#125; char* GetTextB(void) &#123; static char* p = const_cast&lt;char*&gt;(&quot;BBBBBBBB&quot;); return p; &#125; void main(void) &#123; char* p = NULL; p = GetTextA(); printf(p); p = GetTextB(); printf(p); &#125; 题目六：内存泄漏题目：什么是内存泄漏？ 解答：由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。（来自维基百科） 题目七：Windows API题目：描述三个 Windows API。（用途、大致用法） 解答：API Index for desktop Windows applications：https://docs.microsoft.com/en-us/windows/win32/apiindex/api-index-portal 题目八 unsigned long 转字符串题目：写程序，把 unsigned long 型变量转为字符串。在函数调用上，只允许使用 malloc 这个函数，无需 free，不准调用其它函数。如果不调用任何函数更好。如果使用数组要指出数组大小的设置理由。用注释指出哪个变量是结果即可，无需输出。 解答： string ultostr(unsigned long n) &#123; string str = &quot;&quot;; while (n != 0) &#123; unsigned long x = n % 10; str.insert(str.begin(), &#x27;0&#x27; + x); n /= 10; &#125; return str;//结果 &#125; 题目九：统计字母出现的次数题目：写程序，输入一个由英文小写字母组成的字符串，字母可重复出现，&#39;0&#39; 结尾，统计每个字母出现的次数。输出格式自定。 解答： 笔试的时候连题目都搞错了，因为前些天刚做过压缩字符串的题目，那个题是把连续相同的多个字符压缩为两个个数加该字符，例如字符串 &quot;aaabbbbcc&quot; 就可以压缩为 &quot;3a4b2c&quot; 。但是，这个题目它不一样吖，人都傻了…… &#39;0&#39; 应该也是字符串的一部分，解题的时候我并没有把它作为字符串的一部分。 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main() &#123; string str = &quot;&quot;; char c; while (cin &gt;&gt; c) &#123; str += c; if (c == &#x27;0&#x27;) &#123;//&#x27;0&#x27;应该也是字符串的一部分 break; &#125; &#125; vector&lt;pair&lt;char, int&gt;&gt; vec;//存储统计信息 for (int i = 0; str[i] != &#x27;0&#x27;; i++) &#123; bool exist = false; for (int j = 0; j &lt; vec.size(); j++) &#123; if (str[i] == vec[j].first) &#123; exist = true; vec[j].second++; break; &#125; &#125; if (exist == false) &#123; vec.push_back(&#123; str[i],1 &#125;); &#125; &#125; //输出统计结果 for (auto v : vec) &#123; cout &lt;&lt; v.first &lt;&lt; v.second &lt;&lt; endl; &#125; return 0; &#125; 题目十：字符串查找题目：完成这个程序。input 是一个由英文小写字母组成的字符串，&#39;0&#39; 结尾。sub_string 是一个由英文小写字母组成的字符串，&#39;0&#39; 结尾。要查找 sub_string 在 input 中第一次出现时的位置（返回这个地址），如果没找到，则返回 NULL 。不准调用任何函数。 char* strstr(char *input, char *sub_string) &#123; ... &#125; 解答： 笔试的时候做的这个题直接写的代码，都没来得及调试，实际上也确实写错了，其中找到的几个问题： &#39;0&#39; 也应该是字符串的一部分； 对 sub_string 的遍历不应该以 NULL 作为结束标志，而是 &#39;\\0&#39; ； 二层循环对字符进行遍历，应该更新指针，最初的代码忘了更改指针了。 char* strstr(char* input, char* sub_string) &#123; char* ans = new char();//结果 char* s1 = input; char* s2 = sub_string; while (s1 != NULL) &#123; if (*s1 == *s2) &#123; ans = &amp;(*s1); bool find = true; while (*s2 != &#x27;\\0&#x27;)//NULL不是结束标志 &#123; if (*s1 != *s2) &#123; find = false; break; &#125; //更改指针指向下一个字符 s1++; s2++; &#125; if (find) &#123; break; &#125; else &#123; s1 = ans; s2 = sub_string; &#125; &#125; s1++; &#125; return ans;//返回结果 &#125;","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"Leetcode 46.全排列【C++】","date":"2020-04-25","updated":"2022-03-23","path":"2020042559303/","text":"地址：https://leetcode-cn.com/problems/permutations/ 题目给定一个 没有重复 数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 解题思路其实按照我们人的思维很容易想到，全排列就是每次从剩余的数字里面取一个数字，只要保证相同的操作就可以了，但是要写代码来求解还是有些不太一样的。起初我试图找到一点什么规律，比如，知道数组的长度 n 其实就可以确定不同全排列的个数为 n! ，但是对解题并没什么益处。 后来再一想，动态规划？感觉不行，虽然可以一个数一个数的取，但是由于最重要得到所有可能的全排列，所以意味着我们没取一个数，都要将取这个数所能构成的所有全排列保存下来，这个工作是很复杂的。 其实应该用回溯法，因为我们每取一个数出来排列，都会影响下一次能取到的数。以 [1,2,3] 为例，第一次我们可以取三个数中的任意一个，也就是我们可以用一个循环 for x in [1,2,3] 取依次取三个数中的一个，假如我们取了 1 ，则剩下可取的为 [2,3] ，重复上述步骤，直到没有可取的数了，即找到了一个全排列。 不同的全排列即我们每一步取数的路径，所以递归函数中需要用一个引用型参数用于记录路径，找到一个全排列，就将其加入到要求的返回结果中。 附上 labuladong 的回溯算法框架： result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ans; vector&lt;int&gt; path;//路径 backtrack(ans, nums, path); return ans; &#125; void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; ans, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path) &#123; if (nums.empty()) &#123; ans.push_back(path); return; &#125; int i = 0; while (i &lt; nums.size()) &#123; //做选择 path.push_back(nums[i]); nums.erase(nums.begin() + i); //回溯 backtrack(ans, nums, path); //撤销选择 nums.insert(nums.begin() + i, path.back()); path.pop_back(); i++; &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 199.二叉树的右视图【C++】","date":"2020-04-22","updated":"2022-03-23","path":"2020042212988/","text":"地址：https://leetcode-cn.com/problems/binary-tree-right-side-view/ 题目给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例: 输入: [1,2,3,null,5,null,4] 输出: [1, 3, 4] 解释: 1 &lt;--- / \\ 2 3 &lt;--- \\ \\ 5 4 &lt;--- 解题思路首先这是一个很明显的使用递归算法的题目，由于是“右视图”，所以应该采用后序遍历，先遍历右子女结点，再遍历左子女结点。 二叉树的递归遍历是不难实现的，但是这个题要找的是从右侧能看到的结点，以上述示例为例，显然能看到的结点就是右侧的三个结点 [1, 3, 4] 。假设结点 5 还有一个左孩子结点值为 6 ，那么在结点 6 的右侧是没有任何结点阻挡的，所以 6 也应该能看到。 不难发现，具体能看到的结点并不一定只是最右侧一条路径上的的所有结点，而是跟 深度 有关。如果左子树存在深度更深的结点，那就也可以被看到。 在函数外部定义一个 depth 用于记录当前遍历过的所有路径所达到的最深的深度，换言之如果遇到大于 depth 的结点，那么这个结点就是可以被看到的。在调用递归函数前，需要确保传入的是非空结点，当然也可以在递归函数内部判断当前结点是否为空。 递归函数有三个参数，vector&lt;int&gt;&amp; nodes 用于保存返回值，注意必须是引用，这样才能始终在一个数组上更新找到的结点；TreeNode* cur 即传入的非空结点，将其作为新的树根；int dp 即实际的深度，用于和最大到达深度 depth 做对比。 代码/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123; int depth = 0;//遍历到的最大深度 public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; nodes; //调用递归函数前确保传入非空结点 if (root != NULL) &#123; backtrack(nodes, root, 1); &#125; return nodes; &#125; void backtrack(vector&lt;int&gt;&amp; nodes, TreeNode* cur, int dp) &#123; //当前深度大于最大遍历深度 if (dp &gt; depth) &#123; depth = dp;//更新最大深度 nodes.push_back(cur-&gt;val);//添加可见结点 &#125; //结束条件：没有子女节点 if (cur-&gt;right == NULL &amp;&amp; cur-&gt;left == NULL) &#123; return; &#125; //选择右侧 if (cur-&gt;right != NULL) &#123; backtrack(nodes, cur-&gt;right, dp + 1); &#125; //右侧为空则选择左侧 if (cur-&gt;left != NULL) &#123; backtrack(nodes, cur-&gt;left, dp + 1); &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1248.统计「优美子数组」【C++】","date":"2020-04-21","updated":"2022-03-23","path":"2020042156763/","text":"地址：https://leetcode-cn.com/problems/count-number-of-nice-subarrays/ 题目给你一个整数数组 nums 和一个整数 k。 如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。 请返回这个数组中「优美子数组」的数目。 示例 1： 输入：nums = [1,1,2,1,1], k = 3 输出：2 解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。 示例 2： 输入：nums = [2,4,6], k = 1 输出：0 解释：数列中不包含任何奇数，所以不存在优美子数组。 示例 3： 输入：nums = [2,2,2,1,2,2,1,2,2,2], k = 2 输出：16 提示： 1 &lt;= nums.length &lt;= 50000 1 &lt;= nums[i] &lt;= 10^5 1 &lt;= k &lt;= nums.length 解题思路首先，这个题是需要找规律的，要怎么怎么去计算优美子数组的个数，不然就算是暴力解那也没法下手。 这个题 读懂题就很重要，通过题目给出的三个示例，以示例3为例，题目要求是“恰有” k 个奇数数字的“连续”子数组，所以在示例3种，要找的是恰有 2 个连续奇数数字的连续子数组，而示例3种仅有 2 个奇数数字，显然必须要有 1,2,2,1 这部分。剩下可能的组合仅与左右两侧的偶数个数有关，简要列举可能的几个情况如下： //左侧共有连续的3个偶数，可能的情况有4种 //左侧没有更多的偶数（为数组边界或相邻位置是奇数） 1,2,2,1 //左侧有1个偶数 2,1,2,2,1 //左侧有2个偶数 2,2,1,2,2,1 左侧有3个偶数 2,2,2,1,2,2,1 //右侧同理 可以看出，左侧或者右侧有 m 个偶数，就有 m + 1 种可能的情况。如果左侧有 a 种可能的情况，右侧有 b 种可能的情况，则共有 a * b 种情况。 由此，我们只需要遍历所有可能的连续 k 个奇数的情况，分别计数左右两侧偶数的个数并计算可能的组合情况，加到总的优美子数组的个数 ans 中即可。于是我想到了用双指针的办法解题，这就是一个快慢指针的题目，只不过对指针的修改情况稍微复杂一些。只考虑奇数，快指针找到第 k 个奇数，慢指针才开始找第一个奇数，也就是慢指针到快指针之间始终保持 k 个奇数，在遍历的过程中同时就计数偶数数字的个数，避免了重复遍历。剩下的工作就是计算优美子数组个数以及正确的修改指针。 另外，其实可以知道如果数组中的奇数个数小于 k ，是不可能有满足条件的情况的，也就说可以直接返回 0 。但在我的代码中，仅当找到 k 个奇数，才可能进行进一步的计算，所以如果找不到 k 个奇数，则返回初始值 0 。 代码class Solution &#123; public: int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0;//返回值 //模拟快慢指针，快指针比慢指针快k个奇数 int front = 0; int slow = 0; for (; front &lt; nums.size(); front++) &#123; //前k个奇数不做处理 if (nums[front] % 2 == 1 &amp;&amp; k != 0) &#123; k--; &#125; //从第k个奇数开始计算优美子数组的个数 if (nums[front] % 2 == 1 &amp;&amp; k == 0) &#123; int left = 1;//左右两侧偶数可能的组合情况 int right = 1;//默认为1，即一个偶数也没有 //慢指针遍历到下一个奇数，同时计数偶数的个数，m个偶数有m+1种可能的情况 for (; slow &lt; nums.size(); slow++) &#123; if (nums[slow] % 2 == 1) &#123; slow++; break; &#125; left++; &#125; //快指针遍历到下一个计数，同时计数偶数个数 for (int t = front + 1; t &lt; nums.size(); t++) &#123; if (nums[t] % 2 == 1) &#123; break; &#125; right++; &#125; //当前k个连续计数组成的子数组可能的组合情况 ans += left * right; &#125; &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 200.岛屿数量【C++】","date":"2020-04-20","updated":"2022-03-23","path":"2020042052344/","text":"地址：https://leetcode-cn.com/problems/number-of-islands/ 题目给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 此外，你可以假设该网格的四条边均被水包围。 示例 1: 输入: 11110 11010 11000 00000 输出: 1 示例 2: 输入: 11000 11000 00100 00011 输出: 3 解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。 解题思路很巧的是，之前做过一个同类型的题，岛屿的最大面积 。 所以这次很容易就有思路了。首先显然的要遍历二维数组找岛屿，很容易，遇到字符 &#39;1&#39; 就是遇到了岛屿，将岛屿数量 count++ ，那么剩下的问题就是，怎么避免重复遇到同一个岛屿？ 有过之前做同类型题目的经验，不难想到将当前遇到的岛屿将其置为非 &#39;1&#39; 的状态，因为我们判断一个格子是不是岛屿的一部分，就是看这个格子是不是字符 &#39;1&#39; ，所以只要将其置为非 &#39;1&#39; 即表示当前格子已经是已经计算过的岛屿的一部分或者它本来就不是岛屿。 并不是遇到字符 &#39;1&#39; 只将这个格子置为 &#39;0&#39; ，我们的目的是这个岛屿已经计算过了，再次遇到这个岛屿的任意位置，都不再对其做处理，所以应该使用递归将该岛屿的所有位置都置为 &#39;0&#39; 。 另外在我的代码中，不是对每一个格子都调用递归函数进行判断，而是在确定当前格子是 &#39;1&#39; 的情况下才调用递归函数，也就是说在递归函数内部，不再需要判断当前递归进来的格子是否为 &#39;0&#39; 。 代码class Solution &#123; public: int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; int count = 0; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; //找到任意一个&#x27;1&#x27;即表示找到了一个岛屿 //首先岛屿数量count++，再通过回溯将该岛屿全部置为&#x27;0&#x27; if (grid[i][j] == &#x27;1&#x27;) &#123; count++; backtrack(grid, i, j); &#125; &#125; &#125; return count; &#125; //将grid[i][j]所在的岛屿全部置为0，避免重复判断的问题 void backtrack(vector&lt;vector&lt;char&gt;&gt;&amp; grid, int i,int j) &#123; vector&lt;pair&lt;int, int&gt;&gt; dir = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;; grid[i][j] = &#x27;0&#x27;; //做选择，上下左右四个方向 for (auto d : dir) &#123; int ii = i + d.first; int jj = j + d.second; //当且仅当索引ii，jj合法且grid[ii][jj]为&#x27;1&#x27;是递归 if (ii &gt;= 0 &amp;&amp; ii &lt; grid.size() &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; grid[0].size() &amp;&amp; grid[ii][jj] == &#x27;1&#x27;) &#123; backtrack(grid, ii, jj); &#125; &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 11.盛最多水的容器【C++】","date":"2020-04-18","updated":"2022-03-23","path":"2020041821614/","text":"地址：https://leetcode-cn.com/problems/container-with-most-water/ 题目给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解题思路比较典型的双指针问题，这个题难在要把问题读懂，如果能想到是双指针问题，那么这个题已经做好了 80% 了。 双指针问题通用模板： int i = 0; int j = nums.size() - 1; while(i &lt; j)&#123; do something i++; j--; &#125; 我们的目标值只有一个，就是题目要求的最大值。遍历所有可能的情况是很容易写出来的，但却没有必要那么做。 以题目的示例为例，考虑 [1,8,6,2,5,4,8,3,7] 的首尾两个数，我们要找最大值，那么较小的值就可以不再考虑，也就是左侧1小于右侧的7，如果有更大的值，肯定是和较大的数所构成的，第一步我们把左指针右移一位，8和7所能容纳的水量显然大于1和7。 重复上述步骤，根据两端的值移动左右指针，同时不断更新最大值。当遍历结束，题目要求的最大值也就找到了。 代码class Solution &#123; public: int maxArea(vector&lt;int&gt;&amp; height) &#123; //初始化最大值为首尾两条线所围成的容器能容纳的水 int area = (height.size() - 1) * min(height.front(), height.back()); int l = 0; int r = height.size() - 1; while (l &lt; r) &#123; //去掉较短的一边 if (height[l] &lt; height[r]) &#123; l++; &#125; else &#123; r--; &#125; //去掉较短一边后首位两条线围成的容器能容纳的水 int a = (r - l) * min(height[l], height[r]); //更新最大值 area = a &gt; area ? a : area; &#125; return area; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Hexo 压缩&优化插件 Hexo-all-minifier","date":"2020-04-17","updated":"2022-03-23","path":"2020041736855/","text":"Hexo-all-minifier：https://github.com/chenzhutian/hexo-all-minifier 一款 Hexo 插件，通过压缩 HTML、CSS、JS 和图片来优化博客访问速度。 安装npm install hexo-all-minifier --save 注：我在执行以上命令进行安装的时候遇到了问题 Failed to connect to raw.githubusercontent.com port 443 ，查了下原因，其实就是这个域名（raw.githubusercontent.com）被墙了。 解决办法： 查真实 IP 地址 https://www.ipaddress.com/ ，我查到的IP地址是：199.232.68.133 修改系统 hosts 。Windows 系统上的路径为 C:\\Windows\\System32\\drivers\\etc\\hosts ，在 hosts 文件中添加一行： 199.232.68.133 raw.githubusercontent.com Mac 电脑还需要安装一些其他东西： brew install libtool automake autoconf nasm 使用将这行代码填写到 Hexo 博客根目录下的博客配置文件 _config.yml 中就可以了。 all_minifier: true 默认添加以上代码就可以了，比较简单，但仅添加以上代码的情况下，如果在 hexo g 生成静态网页时遇到了问题，或者说有更进阶的需求，那么可以使用以下更进阶一些的设置。 进阶设置如果使用默认的 all_minifier: true 遇到了问题，将对应出问题的某一项关闭即可（enable: false）。 HTML 优化html_minifier: enable: true ignore_error: false silent: false exclude: enable - 开启 HTML minifier. 默认为 true 。 ignore_error - 忽视 HTML 优化时遇到的错误。 silent - 禁用日志优化，默认为 false 。 exclude - 排除文件。 CSS 优化css_minifier: enable: true silent: false exclude: - &#x27;*.min.css&#x27; enable - 开启 CSS minifier，默认为 true 。 silent - 禁用日志优化，默认为 false 。 exclude - 排除文件。 JS 优化js_minifier: enable: true mangle: true silent: false output: compress: exclude: - &#x27;*.min.js&#x27; enable - 开启 JS minifier，默认为 true 。 mangle - Mangle file names output - 输出选项。如果为空，请从 .yml 文件中将其删除！否则，它将被设置为 null，null 不同于 undefined。 compress - 压缩选项。同上。 silent - 禁用日志优化，默认为 false 。 exclude - 排除文件。 图片优化 image_minifier: enable: true interlaced: false multipass: false optimizationLevel: 2 pngquant: false progressive: false silent: false enable - 开启 image minifier. 默认为 true 。 interlaced - Interlace gif for progressive rendering. 默认为 false 。 multipass - 多次优化 svg 图片，直到完全优化。默认为 false 。 optimizationLevel - 选择一个 0 - 7 之间的图片优化等级，默认为 2 。 pngquant - 开启 imagemin-pngquant 插件。默认为 false 。 progressive - Lossless conversion to progressive.默认为 false 。 silent - 禁用日志优化，默认为 false 。 exclude - 排除特定类型的图片文件。可选的值有 gif,jpg, png, or svg 。默认为 null ，不支持 Glob 。","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Leetcode 56.合并区间【C++】","date":"2020-04-16","updated":"2022-03-23","path":"202004168673/","text":"地址：https://leetcode-cn.com/problems/merge-intervals/ 题目给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解题思路这题的思路不算难的，下面我的第一版代码也没花太多时间就写出来了。 第一版思路挺简单的，就是暴力解，遍历数组，把每一个区间的可能和它合并的区间都找出来和它合并，把合并了的区间直接删除。提交，超时，后来看了超时的输入数据，总共 10000 个区间…… 然后我又想别的方法，起初写第一版代码的时候，我其实就有考虑对所有区间按区间的起始位置排序的，但是想着排序应该挺费时的，就没那么做。然后第一版超时了，想想其实排序了应该还好很多，因为按照初版代码的思路，每一次只考虑一个区间要把所有能合并的都找出来和它合并，这期间每新合并了一个区间，它都需要把剩下的所有区间重新遍历一次，复杂度已经是是指数级的了。但是如果先对区间排序，那么只需要考虑相邻区间是否需要合并即可，也就是说排序后的区间数组，只需要对它进行一次遍历即可。按照这个思路，写出了第二版先排序再合并的代码，然而还是超时了。 另外，在我的代码中，我为了节省内存，企图在原数组上修改，也就是两个区间合并到其中一个，然后把另一个删除。 后来我还是看了官方题解，其实官方题解跟我排序的思路就几乎是一样的了，看了之后才想明白，其实频繁的删除操作代价是很大的，毕竟每一次删除都要移动很多元素的位置，牺牲空间来换取时间是值得的。同时，我是真的傻了，明明 sort() 函数就可以直接对数组排序，我还自己写了一个排序…… 代码初版（超时）class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; int i = 0; while (i &lt; intervals.size()) &#123; int j = i + 1; while (j &lt; intervals.size()) &#123; bool canMerge = (intervals[i][1] &lt; intervals[j][0] || intervals[i][0] &gt; intervals[j][1]) ? false : true; //把intervals[j]合并到intervals[i] if (canMerge) &#123; intervals[i][0] = min(intervals[i][0], intervals[j][0]); intervals[i][1] = max(intervals[i][1], intervals[j][1]); intervals.erase(intervals.begin() + j); j = i + 1; continue; &#125; j++; &#125; i++; &#125; return intervals; &#125; &#125;; 排序版（超时）class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; //按区间的起始位置排序 for (int i = 1; i &lt; intervals.size(); i++) &#123; int last = 0; for (int j = 0; j &lt; intervals.size() - i; j++) &#123; if (intervals[j][0] &gt; intervals[j + 1][0]) &#123; last = j; vector&lt;int&gt; tmp = intervals[j]; intervals[j] = intervals[j + 1]; intervals[j + 1] = tmp; &#125; &#125; i = intervals.size() - last - 1; &#125; //合并 int i = 1; while (i &lt; intervals.size()) &#123; if (intervals[i - 1][1] &gt;= intervals[i][0]) &#123; intervals[i - 1][1] = max(intervals[i - 1][1], intervals[i][1]); intervals.erase(intervals.begin() + i); continue; &#125; i++; &#125; return intervals; &#125; &#125;; 官方题解class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; if (intervals.size() == 0) &#123; return &#123;&#125;; &#125; sort(intervals.begin(), intervals.end()); vector&lt;vector&lt;int&gt;&gt; merged; for (int i = 0; i &lt; intervals.size(); ++i) &#123; int L = intervals[i][0], R = intervals[i][1]; if (!merged.size() || merged.back()[1] &lt; L) &#123; merged.push_back(&#123;L, R&#125;); &#125; else &#123; merged.back()[1] = max(merged.back()[1], R); &#125; &#125; return merged; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"2020.04.15 美团点评一面【前端】","date":"2020-04-15","updated":"2022-03-23","path":"2020041557008/","text":"其实我投简历投的后端开发岗，但是昨晚面试官联系到我问我可以转前端吗，说前端收到的简历太少了，我恰好最近半个月算是入了点前端的门也就答应了，然后今天面试官也直说了主要考查一些计算机基础知识…… 记录一下，下面的内容并不是我的回答，是面试结束后查资料完善的，不过有些内容我个人都觉得有问题，选择性的参考学习吧~ 并没有自我介绍。（我打了两三个小时的自我介绍草稿🤐） 一、计算机网络😳 TCP为什么三次握手？不是两次？ 因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。 为了防止已失效的连接请求报文段突然又传送到服务端，产生错误。（究其本质还是请求没有得到确认） 😅 拥塞控制？什么情况下会网络拥塞？TCP 拥塞控制，指防止过多的数据注入网络，保证网络中的路由器或链路不过载。 😥 怎么实现拥塞控制？ 我……我答成流量控制了…… 慢开始、拥塞避免、快重传、快恢复 慢开始 拥塞窗口从 cwnd = 1开始指数增长，直到达到慢开始门限 ssthresh 拥塞避免 发送端拥塞窗口 cwnd 每经过一个往返时延 RTT 就增加一个 MSS 得大小，使 cwnd 按线性规律缓慢增长。（加法增大） 当出现一次超时（网络拥塞）时，令慢开始门限 ssthresh 等于当前 cwnd 的一半。（乘法减小） 快重传 当发送方连续收到3个重复的 ACK 报文时，直接重传对方尚未收到的报文段，不必等待那个报文段设置的重传计时器超时。 快恢复 发送方收到连续三个冗余 ACK 时，执行“乘法减小”算法，把慢开始门限设置为出现拥塞时发送方 cwnd 的一半。 🤐 了解 HTTPS 吗？HTTP 和 HTTPS 的区别？ 不知道……还没学到……（🙃我为什么不答一句：HTTPS更安全） HTTP 一般是明文传输，很容易被攻击者窃取重要信息，鉴于此，HTTPS 应运而生。HTTPS 的全称为 （Hyper Text Transfer Protocol over SecureSocket Layer），全称有点长，HTTPS 和 HTTP 有很大的不同在于 HTTPS 是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础上增加了 SSL 层，也就是说 HTTPS = HTTP + SSL。 二、数据结构😉 数组、链表的区别 数组：一次性分配一整块连续的存储空间，可以通过索引直接取到任意元素。需要快速访问数据，较少插入或删除数据，或者大内存空间分配使用数组。 链表：通过指针链式连接，存储空间不连续，要找到某一个元素最好的情况是第一个节点就是该元素，最坏的情况需要遍历整个链表。频繁删除和插入元素使用链表。 😋 栈和队列的区别 栈：LIFO，先进后出。限制在栈顶插入元素和删除元素。 队列：FIFO，先进先出。限制在队尾插入元素，在队头删除元素。 什么场景可以用到队列？计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等 😑 堆有了解吗？堆（heap）也被称为优先队列，队列中允许的操作是 先进先出（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素。二叉树的衍生，有最小堆最大堆的两个概念，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 😕 树有哪些应用？ AVL树：平衡二叉树之一，应用相对其他数据结构比较少，windows对进程地址空间的管理用到了AVL 红黑树：平衡二叉树，广泛应用在C++STL中，比如map和set，Java的TreeMap B和B+树：主要用在文件系统以及数据库中做索引等 Trie 树：用在统计和排序大量字符串中，一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示。还有比如IP选路，也是前缀匹配 R树：空间数据库索引 参考链接：https://sohu.gg/S2cwGU3 三、操作系统🥴 计算机存储的最小单位？计算机数据存储的最小单位是字节Byte，数据传输的最小单位是比特bit。 🤪 RAM和ROM RAM(Random Access Memory) 随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储介质。RAM工作时可以随时从任何一个指定的地址写入（存入）或读出（取出）信息。它与 ROM 的最大区别是数据的易失性，即一旦断电所存储的数据将随之丢失。RAM 在计算机和数字系统中用来暂时存储程序、数据和中间结果。 ROM (Read Only Memory) 只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除，且内容不会因为电源关闭而消失。在电子或电脑系统中，通常用以存储不需经常变更的程序或数据。 🤣 机械硬盘和固态硬盘的区别？ 固态硬盘防震抗摔性好。机械硬盘都是磁碟型的，数据储存在磁碟扇区里；而固态硬盘是使用闪存颗粒制作而成。 固态硬盘读写速度快。 固态硬盘功耗低。 固态硬盘重量轻。 固态硬盘无噪音，而机械硬盘由于机械转动有噪音。 机械硬盘相对于固态硬盘便宜。 机械硬盘一般寿命更长，但由于其机械结构，使用过程中会磨损，所以寿命不一定长于固态硬盘。 百度百科：https://sohu.gg/ffWSA1m 😲 删除的数据是怎么找回的？原理是什么？硬盘在保存文件时，一般会按照“簇”的形式将数据进行保存，至于保存的文件默认会记录在文件分配表中。而硬盘删除文件时，系统也不会把它所存储的文件全部清空，而是将之前在各个分配表中的“簇”标记为空显示。文件分配表里面还有哪个“簇”没有使用，后期所存储的数据也就会存入该簇中。所以在数据重新写入之前，这些删除的文件依然会存在之前所在的“簇”中，直到新数据的写入，覆盖原有数据。 视频讲解：https://www.bilibili.com/video/av17027659 🤕 CPU和GPU的区别？ CPU 内核比较少，而且是串行的，主要做一些常规的操作，如打开文档，打开程序，播放声音等一些有序的工作，擅长一些逻辑运算，有高速缓存，可以提高数据访问的速度。 GPU 则接受来自 CPU 的指令，有大量的内核，而且是并行计算的，所以能够完成大规模的数据运算。 😦 时钟频率和浮点率？ 时钟频率：每秒运算的次数，通常所说的某某CPU是多少GHz的，而这个多少GHz就是“CPU的主频”。 浮点率：FLOPS，每秒浮点运算次数（亦称每秒峰值速度）是每秒所执行的浮点运算次数。 😝 一个汉字几个字节？ 字节数：2；编码：GB2312 字节数：2；编码：GBK 字节数：3；编码：UTF-8 字节数：4；编码：UTF-16 🤫 Unicode和utf-8的区别？ Unicode 是「字符集」，UTF-8 是「编码规则」，UTF-8 是 Unicode 的实现方式之一。 Unicode 的出现是因为世界各地编码方式不一，为了解决不同编码格式导致的乱码问题；UTF-8 采用变长编码的方式，解决 Unicode 过于占用空间的问题。 四、Linux😎 会使用Linux吗？ 答：会使用，但是没有作为开发系统长期使用，有学习过。 😭 Linux和Windows内核上有哪些区别？ 其实我觉得下面这些不是“内核”上的区别，似乎还过时了…… Windows是商业软件，源码保密；Linux开源。 Windows中安装软件主要是二进制形式；而Linux中一般是源码安装。 Windows中创建进程使用 WIN32 API 的 CreateProcess 函数；Linux中使用 fofk+execv 创建进程 Windows中可执行文件格式为PE；Linux中为ELF。 Windows内核有一套固定的 API 且向后兼容；而 Linux 没有固定的内核 API。 中断处理方式不同。 Windows中有注册表这一概念；Linux中所有配置信息都是文件。 参考链接：http://www.wanfangdata.com.cn/details/detail.do?_type=perio&amp;id=jsjywl201206041 五、我的提问🙏🏻 如果入职会使用到怎样的技术栈？TS。下来查了下，哦，TypeScript。 🙏🏻 入职后工作内容是什么？🙏🏻 留用的机会怎样？一般只要表现不差留用机会都很大。 🙏🏻 培训的情况怎么样？","categories":[],"tags":[{"name":"面经","slug":"面经","permalink":"https://mxy493.xyz/tags/%E9%9D%A2%E7%BB%8F/"}]},{"title":"Leetcode 355.设计推特【C++】","date":"2020-04-13","updated":"2020-04-13","path":"2020041332657/","text":"地址：https://leetcode-cn.com/problems/design-twitter/ 题目设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。你的设计需要支持以下的几个功能： postTweet(userId, tweetId): 创建一条新的推文 getNewsFeed(userId): 检索最近的十条推文。每个推文都必须是由此用户关注的人或者是用户自己发出的。推文必须按照时间顺序由最近的开始排序。 follow(followerId, followeeId): 关注一个用户 unfollow(followerId, followeeId): 取消关注一个用户 示例： Twitter twitter = new Twitter(); // 用户1发送了一条新推文 (用户id = 1, 推文id = 5). twitter.postTweet(1, 5); // 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文. twitter.getNewsFeed(1); // 用户1关注了用户2. twitter.follow(1, 2); // 用户2发送了一个新推文 (推文id = 6). twitter.postTweet(2, 6); // 用户1的获取推文应当返回一个列表，其中包含两个推文，id分别为 -&gt; [6, 5]. // 推文id6应当在推文id5之前，因为它是在5之后发送的. twitter.getNewsFeed(1); // 用户1取消关注了用户2. twitter.unfollow(1, 2); // 用户1的获取推文应当返回一个列表，其中包含一个id为5的推文. // 因为用户1已经不再关注用户2. twitter.getNewsFeed(1); 解题思路首先，我写了一个多小时写出来，但是超时了，很尴尬~ 还是留下我的解题思路。 根据题目要求，我们知道要保存每一条推文及其发布者，定义了一个 vector&lt;pair&lt;int, int&gt;&gt; 类型的数组 tweets 用于存储成对的 userID 和 tweetID，并且题目要求检索最近的10条推文，所以发布的时候我们就顺序存储每一条推文，这样避免了每次检索都要对推文进行排序；另外还需要对应每一个用户要存储该用户所关注的用户，考虑每一个用户关注的用户ID都是唯一的，所以我选择用集合来存储每一个用户关注的用户，定义了一个 vector&lt;pair&lt;int, set&lt;int&gt;&gt;&gt; 类型的数组 users ，存储所有用户的用户ID及其对应的关注的用户的集合。 （1）发推首先直接将需要发布的推文及其发布者加入到 tweets 的末尾，然后判断发布该推文的用户是否已存在与用户数组 users ，如果已存在则不做处理，否则将该用户加入到用户数组。 （2）检索最近10条推文判断传入的用户ID是否存在，若不存在该ID的用户，则直接返回空数组。 否则从后往前遍历推文数组 tweets ，定义一个整型 count 用于计数已找到的符合要求的推文数量，遍历结束的条件即已检索到的推文数量 count 达到10条或者已遍历完整个推文数组。对遍历到的每一个推文，判断其对应的发布者ID是否就是要检索的用户ID或者该用户所关注的某个用户的ID，若是，将该推文加入返回数组，count++ ，否则继续遍历。 （3）关注遍历用户数组查找该用户，如果找到，则将其要关注的用户加入到关注的用户集合种；否则先将该用户加入到用户数组，再将要关注的用户ID加入到关注的用户集合。 （4）取关遍历用户数组查找该用户，若找到，则将要取关的用户从关注的用户集合中删除，同时结束函数。 # 优化优化这部分是后面改过的，虽然还是很耗时并且内存消耗也大，不过好歹通过了。 执行用时 :1648 ms, 在所有 C++ 提交中击败了5.15%的用户 内存消耗 :189.6 MB, 在所有 C++ 提交中击败了16.67%的用户 其实就是最开始的代码在索引的那一部分，我首先遍历了一次用户数组判断该用户是否存在，如果不存在，函数直接结束了那倒没什么影响。但如果存在的话，后续对每一条推文，我都还要再遍历一次去找这个用户，如果遍历了 n 条推文，那么就会做 n + 1 次完全重复的遍历查找，显然这是没有必要的。 所有我将判断该用户是否存在的标志改为了整型 index 并初始化为 -1 ，即表示该用户不存在，如果找到了该用户，则将 index 修改为该用户在用户数组中的位置，后续就不再需要遍历用户数组去查找该用户了。 我将优化部分的代码放到了👇🏻最后面👇🏻 代码（超时）原始代码（未优化）class Twitter &#123; vector&lt;pair&lt;int, int&gt;&gt; tweets;//所有推文 vector&lt;pair&lt;int, set&lt;int&gt;&gt;&gt; users;//所有用户及其关注的用户 public: /** Initialize your data structure here. */ Twitter() &#123; &#125; /** Compose a new tweet. */ void postTweet(int userId, int tweetId) &#123; //加入推文数组 tweets.push_back(&#123; userId,tweetId &#125;); //判断该用户是否存在 for (auto user : users) &#123; if (user.first == userId) &#123; return;//如果用户存在，函数将在这里结束 &#125; &#125; //函数执行到这里说明用户不存在，将用户加入到用户列表 users.push_back(&#123; userId,&#123;&#125; &#125;); &#125; /** Retrieve the 10 most recent tweet ids in the user&#x27;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; vector&lt;int&gt; ans; //判断是否存在该id的用户 bool exist = false; for (auto user : users) &#123; if (userId == user.first) &#123; exist = true; break; &#125; &#125; //不存在直接返回空数组 if (exist == false) &#123; return ans; &#125; int amount = tweets.size(); int count = 0; for (int i = 0; count &lt; 10 &amp;&amp; i &lt; tweets.size(); i++) &#123; if (tweets[amount - i - 1].first == userId || isFollowing(userId, tweets[amount - i - 1].first)) &#123; ans.push_back(tweets[amount - i - 1].second); count++; &#125; &#125; return ans; &#125; // id1是否关注了id2 bool isFollowing(int id1, int id2) &#123; for (int i = 0; i &lt; users.size(); i++) &#123; if (users[i].first == id1 &amp;&amp; users[i].second.find(id2) != users[i].second.end()) &#123; return true; &#125; &#125; return false; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) &#123; bool exist = false; for (int i = 0; i &lt; users.size(); i++) &#123; if (followerId == users[i].first) &#123; exist = true; users[i].second.insert(followeeId); return; &#125; &#125; if (exist == false) &#123; users.push_back(&#123; followerId,&#123;&#125; &#125;); users[users.size() - 1].second.insert(followeeId); &#125; &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) &#123; for (int i = 0; i &lt; users.size(); i++) &#123; if (followerId == users[i].first) &#123; users[i].second.erase(followeeId); return; &#125; &#125; &#125; &#125;; /** * Your Twitter object will be instantiated and called as such: * Twitter* obj = new Twitter(); * obj-&gt;postTweet(userId,tweetId); * vector&lt;int&gt; param_2 = obj-&gt;getNewsFeed(userId); * obj-&gt;follow(followerId,followeeId); * obj-&gt;unfollow(followerId,followeeId); */ 优化部分对函数 getNewsFeed(int userId) 进行了修改，并删除了函数 isFollowing(int id1, int id2)。 /** Retrieve the 10 most recent tweet ids in the user&#x27;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; vector&lt;int&gt; ans; //判断是否存在该id的用户 bool exist = false; int index = -1; for (int i = 0; i &lt; users.size(); i++) &#123; if (userId == users[i].first) &#123; index = i; break; &#125; &#125; //不存在直接返回空数组 if (index == -1) &#123; return ans; &#125; int amount = tweets.size(); int count = 0; for (int i = 0; count &lt; 10 &amp;&amp; i &lt; tweets.size(); i++) &#123; int cur = tweets[amount - i - 1].first; if (cur == userId || users[index].second.find(cur) != users[index].second.end()) &#123; ans.push_back(tweets[amount - i - 1].second); count++; &#125; &#125; return ans; &#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 151.翻转字符串里的单词【C++】","date":"2020-04-10","updated":"2022-03-23","path":"2020041016643/","text":"地址：https://leetcode-cn.com/problems/reverse-words-in-a-string/ 题目给定一个字符串，逐个翻转字符串中的每个单词。 示例 1： 输入: &quot;the sky is blue&quot; 输出: &quot;blue is sky the&quot; 示例 2： 输入: &quot; hello world! &quot; 输出: &quot;world! hello&quot; 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 输入: &quot;a good example&quot; 输出: &quot;example good a&quot; 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 进阶： 请选用 C 语言的用户尝试使用 O(1) 额外空间复杂度的原地解法。 解题思路做倒是做出来了，思路不复杂，但是代码极其复杂。 起初我的想法是写一个循环，同时从两头往中间遍历，一头找到一个单词就先停下来，等另一头也找到一个单词，然后对换，再继续找下一对单词前后对换。但是在我写代码的过程中，才慢慢发现，只要在原字符串上进行了对换，那么原本的索引 i ， j 就不再是正确的索引了，要搞清楚其中的变换关系还是挺复杂的。 后来我改为了两层循环，并且定义两个整型变量 lenl 和 lenr 分别表示前后两个单词的长度。外层循环从前往后遍历，找到一个单词就进入内层循环，内层循环从后往前遍历，找到一个单词后，进行前后对换，然后修改索引 i ， j 的值，并将 lenl 和 lenr 重新置为 0 ，继续查找下一个单词。 前面所做的工作只对单词进行了处理，字符串中的空格还没有处理。所以现在要分别删除首尾的空格以及将单词之间的多个空格压缩为一个。 代码class Solution &#123; public: string reverseWords(string s) &#123; int i = 0; int j = 1; int lenl = 0;//前单词长度 int lenr = 0;//后单词长度 while (i + j &lt;= s.size()) &#123; //单词长度+1 if (s[i] != &#x27; &#x27;) &#123; lenl++; &#125; if (s[i] == &#x27; &#x27; &amp;&amp; lenl != 0) &#123; while (j + i &lt;= s.size()) &#123; //单词长度+1 if (s[s.size() - j] != &#x27; &#x27;) &#123; lenr++; &#125; if (s[s.size() - j] == &#x27; &#x27; &amp;&amp; lenr != 0) &#123; string tmp = s.substr(i - lenl, lenl); //替换前单词 s.erase(i - lenl, lenl); s.insert(i - lenl, s.substr(s.size() - j + 1, lenr)); //替换后单词 s.insert(s.size() - j + 1, tmp); s.erase(s.size() - j + 1, lenr); //重新设置i，j i = i - lenl + lenr; j = j - lenr + lenl; //重置lenl和lenr lenl = 0; lenr = 0; break; &#125; j++; &#125; &#125; i++; &#125; //去掉首尾空格 while (s.size() &gt; 0 &amp;&amp; s.front() == &#x27; &#x27;) &#123; s.erase(0, 1); &#125; while (s.size() &gt; 0 &amp;&amp; s.back() == &#x27; &#x27;) &#123; s.pop_back(); &#125; //去掉中间重复空格 int ii = 0; int count = 0; while (ii &lt; s.size()) &#123; if (s[ii] == &#x27; &#x27;) &#123; count++; &#125; if (s[ii] != &#x27; &#x27; &amp;&amp; count != 0) &#123; s.replace(ii - count, count, &quot; &quot;); ii = ii - count + 1; count = 0; &#125; ii++; &#125; return s; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 22.括号生成【C++】","date":"2020-04-09","updated":"2022-03-23","path":"2020040959524/","text":"地址：https://leetcode-cn.com/problems/generate-parentheses/ 题目数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例： 输入：n = 3 输出：[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot; ] 解题思路首先感谢 labuladong 上面的两篇文章，这个题完全是靠这两篇文章学会的。 labuladong 回溯算法详解：https://sohu.gg/i70eLLuTA labuladong 括号生成：https://sohu.gg/ZJ2b1P9tC 是的，我自己做了很久并没有做出来，然后看了 labuladong 这两篇关于回溯算法的文章，真的讲的很清晰明了，至少可以说是我所看过的所有文章里讲的把回溯讲的最清楚的了。万分感激，同时也强烈推荐 labuladong 的微信公众号，有很多很有用的原创文章。 这里我就不细说本题的解题思路了，附上 labuladong 的回溯算法框架： result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 代码class Solution &#123; public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; vec; string str; backtrack(vec, str, n, n); return vec; &#125; void backtrack(vector&lt;string&gt;&amp; vec, string str, int left, int right) &#123; if (left &lt; 0 || right&lt;0 || left&gt;right) return; if (left == 0 &amp;&amp; right == 0) &#123; vec.push_back(str); return; &#125; //放置左括号 str += &#x27;(&#x27;;//做选择 backtrack(vec, str, left - 1, right); str.pop_back();//撤销选择 //放置右括号 str += &#x27;)&#x27;; backtrack(vec, str, left, right - 1); str.pop_back(); &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题 01.07.旋转矩阵【C++】","date":"2020-04-07","updated":"2022-03-23","path":"2020040753413/","text":"地址：https://leetcode-cn.com/problems/rotate-matrix-lcci/ 题目给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。 不占用额外内存空间能否做到？ 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 解题思路这个题的解题思路真的是个意外的发现，起初题目要求都没搞明白以为是求对称矩阵就开始下手做，还很快就写出来了，然后才注意到是旋转矩阵。 然后就一直在思考旋转的过程中坐标 (i, j) 的变化规律，其实都有一点想法了，大概要分成四块来分别做转换才行。但是恰巧这个时候我突然间发现，我前面做的对称矩阵，恰好是每一列顺序反的，也就是说把每一列前后互换就可以了。 例如给定的矩阵： matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 第一步求对称矩阵： matrix = [ [1,4,7], [2,5,8], [3,6,9] ], 可以看到只需要每一列前后互换就可以了，也就是第1列和第3列互换，得到最终结果： matrix = [ [7,4,1], [8,5,2], [9,6,3] ] 代码class Solution &#123; public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); //对称矩阵 for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &lt; n; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125; //左右对换 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n / 2; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[i][n - j - 1]; matrix[i][n - j - 1] = tmp; &#125; &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 460.LFU缓存【C++】","date":"2020-04-05","updated":"2022-03-23","path":"2020040543717/","text":"地址：https://leetcode-cn.com/problems/lfu-cache/ 题目请你为最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。 get(key) - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。 put(key, value) - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。 「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。 进阶： 你是否可以在 O(1) 时间复杂度内执行两项操作？ 示例： LFUCache cache = new LFUCache( 2 /* capacity (缓存容量) */ ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // 返回 1 cache.put(3, 3); // 去除 key 2 cache.get(2); // 返回 -1 (未找到key 2) cache.get(3); // 返回 3 cache.put(4, 4); // 去除 key 1 cache.get(1); // 返回 -1 (未找到 key 1) cache.get(3); // 返回 3 cache.get(4); // 返回 4 解题思路首先，题目涉及到的几个数据： capacity ：容量 key 、 value 、 frequency ：分别是码、值、频次，并且这三项数据是一一对应的关系，所以我定义了一个 vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; 类型的数组来存储。vec.first 即键值对 &#123;key, value&#125; ，vec.second 即该键值对对应的频次。 起初我的想法是，需要什么就去数组里遍历查找，但是后面发现，频次可以找到最低的频次，但是同样频次的两个数据怎么判断哪一个离得近哪一个离得远呢？所以我另外定义了一个函数 rearrange(int index) ，每次 get 或 put 之后就对该项数据重排序，以保证数组始终是以频次最高且最近使用的排在前面，而频次低且离得远的排在后面。对于容量已满但要插入新数据的情况，就可以直接 vec.pop_back() 删除数组末尾的元素，并在末尾插入新元素。 需要注意，如果容量为0的话，put() 不应该执行任何操作，get() 默认将返回 -1 。 代码class LFUCache &#123; private: int capacity; vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; vec;//默认使用频率高切最近使用的排在前面 public: LFUCache(int capacity) &#123; this-&gt;capacity = capacity; &#125; //每当get()或者put()的时候都重新对这个元素的位置进行排序 void rearrange(int index) &#123; //即使频率相同，但由于当前元素为最近使用，所以也应该排在前面 for (int j = index - 1; j &gt;= 0; j--) &#123; if (vec[j + 1].second &gt;= vec[j].second) &#123; pair&lt;pair&lt;int, int&gt;, int&gt; tmp = vec[j + 1]; vec[j + 1] = vec[j]; vec[j] = tmp; &#125; &#125; &#125; int get(int key) &#123; for (int i = 0; i &lt; vec.size(); i++) &#123; if (vec[i].first.first == key) &#123; vec[i].second++; int val = vec[i].first.second; rearrange(i);//频率改变，对其重排序 return val; &#125; &#125; return -1;//容量为0或者不存在这个元素默认返回-1 &#125; void put(int key, int value) &#123; //容量为0无法新增 if (capacity == 0) return; for (int i = 0; i &lt; vec.size(); i++) &#123; //已存在值为key的元素应该更新其value，并将其频率+1 if (vec[i].first.first == key) &#123; vec[i].first.second = value; vec[i].second++; rearrange(i);//频率改变，对其重排序 return; &#125; &#125; //元素不存在且容量未满 if (vec.size() &lt; capacity) &#123; vec.push_back(&#123; &#123;key,value&#125;,0 &#125;); rearrange(vec.size() - 1); return; &#125; //元素不存在但容量已满 else &#123; vec.pop_back();//末尾元素就是最最远且少使用的元素 vec.push_back(&#123; &#123;key,value&#125;,0 &#125;); rearrange(vec.size() - 1); &#125; &#125; &#125;; /** * Your LFUCache object will be instantiated and called as such: * LFUCache* obj = new LFUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 42.接雨水【C++】","date":"2020-04-04","updated":"2022-03-23","path":"2020040443575/","text":"地址：https://leetcode-cn.com/problems/trapping-rain-water/ 题目给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例： 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 解题思路一开始做的时候，思路错了，到代码都写出来了才发现，然后又重新来一遍~ 首先，要能接住雨水说明两边高中间低，我们就总是以当前的点为左侧的最高点，默认在右侧总能找到比我们以为的最高点大的数，那么问题就简化了。 我们只需要遍历数组，起始处默认 height[0] 就是左侧的最高点，始终认为 height[left] - height[i] 的水量是可以接住的，遇到大于 height[left] 的数说明遇到了右侧最高点，同时也就表面我们前面的假设成立了，此时再更新 left 继续以同样的方法计算。如果恰好最后一个 height[left] 是小于 height.back() 的，那么遍历完一次数组就得到了结果。 但事实上可能 height.back() 是小于最后的 height[left] 的。例如假如最后一部分数组是 [5,1,2,4] ，我们默认 5 为左侧的最大值，并认为右侧能找到大于 5 的数，然后我们分别为总水量 water 加上了 (5-5)+(5-1)+(5-2)+(5-4) = 8 ，这就导致得到了错误的结果。 解决的办法是，按前述假设遍历完一次数组后，判断 height.back() &lt; height[left] ，如果很不幸遇到了这样的情况，那么我们就反过来以同样的思路从后往前遍历到 left 下标处即可。也就是将 height.back() 作为右侧最高点，而现在我们清楚的知道往前遍历到 left 下标处 height[left] &gt; height[right] 一定是成立的。以上述例子为例，也就是 [5,1,2,4] 从后往前遍历，首先减掉之前错误的水量，同时为总水量加上正确的水量 (4-4)+(4-2)+(4-1) = 5 。 代码class Solution &#123; public: int trap(vector&lt;int&gt;&amp; height) &#123; //至少要三个柱子才可能接住雨水 if (height.size() &lt; 3) return 0; int water = 0; int left = 0;//左高点 for (int i = 0; i &lt; height.size(); i++) &#123; if (height[i] &gt;= height[left]) &#123; left = i; &#125; water += height[left] - height[i]; &#125; if (height.back() &lt; height[left]) &#123; int right = height.size() - 1;//右高点 for (int i = height.size() - 1; i &gt; left; i--) &#123; water -= height[left] - height[i]; if (height[i] &gt;= height[right]) right = i; water += height[right] - height[i]; &#125; &#125; return water; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 289.生命游戏【C++】","date":"2020-04-02","updated":"2022-03-23","path":"20200402358/","text":"地址：https://leetcode-cn.com/problems/game-of-life/ 题目根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。 给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律： 如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。 示例： 输入： [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] 输出： [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] 进阶： 你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 解题思路这个题目难度不大，思路很容易想到，只要直到每个格子的当前状态和它周围活细胞（知道周围活细胞的个数等同于知道周围死细胞的个数）的个数，就可以知道它的下一个状态。 需要知道的数据有两个：当前状态和周围活细胞的个数。很容易想到再建一个等大的二维数组来保存对应位置上的细胞周围的活细胞的个数，所以很顺畅的写出了第一份代码（代码一）。 其实题目的“进阶”部分也提到了，这个题是可以用原地算法解的，也就是不用另外创建二维数组来保存每个格子周围的活细胞数量。 思考了一下，如果要直接在原二维数组上做修改，那么每一个位置相当于要同时保存当前状态和周围活细胞的个数两条信息，于是通过 观察法 发现每个格子就两种状态要么1要么0，可以把它等价的转换为要么为正要么为负，这样就可以把活细胞周围的活细胞个数用正数表示，而死细胞周围的活细胞个数用负数表示。开始撸代码，然后会发现，如果周围活细胞的个数为0，那么当前细胞不管是活细胞还是死细胞都保存为了0，这就导致这种情况下无法正确判断当前格子的下一个状态。解决办法很简单，不管正负，把个数都+1。（例如，若当前格子是活细胞，周围有4个活细胞，则将当前格子置为5；若当前格子是死细胞，周围活细胞个数为2，则将当前格子置为-3） 原地算法思路：活细胞用正数保存其周围活细胞的个数+1，死细胞用负数保存周围活细胞的个数+1 代码 代码一：另外创建一个等大二维数组保存每个格子周围的活细胞个数 class Solution &#123; public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; vector&lt;vector&lt;int&gt;&gt; sta;//记录每个坐标周围有多少个活细胞 const vector&lt;pair&lt;int, int&gt;&gt; dir = &#123; &#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125; &#125;; for (int i = 0; i &lt; board.size(); i++) &#123; vector&lt;int&gt; s; for (int j = 0; j &lt; board[0].size(); j++) &#123; int num = 0;//周围活细胞个数 for (auto d : dir) &#123; int ii = i + d.first; int jj = j + d.second; if (ii &gt;= 0 &amp;&amp; ii &lt; board.size() &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; board[0].size() &amp;&amp; board[ii][jj] == 1) num++; &#125; s.push_back(num); &#125; sta.push_back(s); &#125; //一次更新 for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (board[i][j] == 1) &#123; if (sta[i][j] &lt; 2 || sta[i][j] &gt;3) board[i][j] = 0; &#125; if (board[i][j] == 0 &amp;&amp; sta[i][j] == 3) &#123; board[i][j] = 1; &#125; &#125; &#125; &#125; &#125;; 代码二：在原表上修改，不需要额外创建数组 class Solution &#123; public: void gameOfLife(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; const vector&lt;pair&lt;int, int&gt;&gt; dir = &#123; &#123;-1,-1&#125;,&#123;-1,0&#125;,&#123;-1,1&#125;,&#123;0,-1&#125;,&#123;0,1&#125;,&#123;1,-1&#125;,&#123;1,0&#125;,&#123;1,1&#125; &#125;; for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; //活细胞用正数保存其周围活细胞的个数+1，死细胞用负数保存周围活细胞的个数+1 board[i][j] = board[i][j] == 0 ? -1 : 1; for (auto d : dir) &#123; int ii = i + d.first; int jj = j + d.second; //周围格子只要大于0就是活细胞，小于或者等于0都是死细胞 if (ii &gt;= 0 &amp;&amp; ii &lt; board.size() &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; board[0].size() &amp;&amp; board[ii][jj] &gt; 0) &#123; //当前细胞是活细胞则+1，否则-1 if (board[i][j] &gt; 0) board[i][j]++; else board[i][j]--; &#125; &#125; &#125; &#125; //一次更新 for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; if (board[i][j] &gt; 0) &#123; if (board[i][j] - 1 &lt; 2 || board[i][j] - 1 &gt; 3) &#123; board[i][j] = 0; &#125; else board[i][j] = 1; &#125; if (board[i][j] &lt; 0) &#123; if (abs(board[i][j] + 1) == 3) board[i][j] = 1; else board[i][j] = 0; &#125; &#125; &#125; &#125; &#125;;","categories":[],"tags":[]},{"title":"4.2 美团点评笔试记录","date":"2020-04-02","updated":"2020-04-03","path":"2020040229380/","text":"几天前投了美团点评后端开发工程师的岗位，今晚七点到九点两个小时的笔试。 估计我已经没了😓五个编程题，就做出来无错误提交了一个…… 笔试系统用的赛码网 ，可以提前刷点题适应一下。 以下解题思路以及代码只是我自己做的，不保证正确，如果存在错误还请指正！ 题目一：最少删除多少个数字 1.1 题目 时间限制：C/C++语言 1000MS；其他语言 3000MS 内存限制：C/C++语言 65536KB；其他语言 589824KB 题目描述： 给出一个序列包含 n 个正整数的序列 A，你可以从中删除若干个数，使得剩下的数字中的最大值和最小值之差不超过 x ，请问最少删除多少个数字。 输入： 输入第一行仅包含两个正整数n和x，表示给出的序列的长度和给定的正整数。(1 &lt;= n &lt;= 1000,1 &lt;= x &lt;= 10000) 接下来一行有 n 个正整数，即这个序列，中间用空格隔开。(1 &lt;= a[i] &lt;= 10000) 输出： 输出仅包含一个正整数，表示最少删除的数字的数量。 样例输入 5 2 2 1 3 2 5 样例输出 1 提示： 极端情况下，当删除到仅剩1个数时，最大值和最小值的差为0，故不会出现无解的情况。 1.2 解题思路笔试的时候写的有问题，更改过了不知道对不对~ 思路：先对数组排序，因为排序后的数组最小最大的数可以直接取到，要尽可能少的删除数字的话，肯定要么删除最大的数，要么删除最小的数，所以我写了一个递归，如果当前传入的有序数组已经满足最大的数与最小的数的差（vec.back() - vec.front()）不超过 x ，那么就结束递归返回 0 ，否则返回 1 + std::min(getMin(vec1, x), getMin(vec2, x)) 。 1.3 代码#include&lt;iostream&gt; #include&lt;vector&gt; #include &lt;algorithm&gt; //递归算法 int getMin(std::vector&lt;int&gt;&amp; vec, int x) &#123; if (vec.back() - vec.front() &lt;= x) &#123; return 0; &#125; std::vector&lt;int&gt; vec1; std::vector&lt;int&gt; vec2; vec1.assign(vec.begin(), vec.end() - 1); vec2.assign(vec.begin() + 1, vec.end()); return 1 + std::min(getMin(vec1, x), getMin(vec2, x)); &#125; int main() &#123; int n; int x; int ans = 0; std::cin &gt;&gt; n &gt;&gt; x; if (n == 1) &#123; std::cout &lt;&lt; 0; return 0; &#125; std::vector&lt;int&gt; seq(n); for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; seq[i]; &#125; //从小到大排序 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n - i - 1; j++) &#123; if (seq[j] &gt; seq[j + 1]) &#123; int temp = seq[j]; seq[j] = seq[j + 1]; seq[j + 1] = temp; &#125; &#125; &#125; ans = getMin(seq, x); std::cout &lt;&lt; ans; return 0; &#125; 题目二：空间回廊 2.1 题目 时间限制：C/C++语言 1000MS；其他语言 3000MS 内存限制：C/C++语言 65536KB；其他语言 589824KB 题目描述： 有一款叫做空间回廊的游戏，游戏中有着n个房间依次相连，如图，1号房间可以走到2号房间，以此类推，n 号房间可以走到1号房间。 这个游戏的最终目的是为了在这些房间中留下尽可能多的烙印，在每个房间里留下烙印所花费的法力值是不相同的，已知他共有 m 点法力值，这些法力是不可恢复的。 小明刚接触这款游戏，所以只会耿直的玩，所以他的每一个行动都是可以预料的： 一开始小明位于1号房间。 如果他剩余的法力能在当前的房间中留下一个烙印，那么他就会毫不犹豫的花费法力值。 无论是否留下了烙印，下一个时刻他都会进入下一个房间，如果当前位于i房间，则会进入 i+1 房间，如果在 n 号房间则会进入 1 号房间。 当重复经过某一个房间时，可以再次留下烙印。 很显然，这个游戏是会终止的，即剩余的法力值不能在任何房间留下烙印的时候，游戏终止。请问他共能留下多少个烙印。 输入：输入第一行有两个正整数 n 和 m ，分别代表房间数量和小明拥有的法力值。(1 &lt;= n &lt;= 100000,1 &lt;= m &lt;= 10^18) 输入第二行有 n 个正整数，分别代表1~n号房间留下烙印的法力值花费。(1 &lt;= a[i] &lt;= 10^9) 输出： 输出仅包含一个整数，即最多能留下的烙印。 样例输入 4 21 2 1 4 3 样例输出 9 样例解释： 显然是所有房间都留下两个烙印，然后剩下1点法力值，仅能在2号房间再留下一个烙印. 2.2 解题思路这题挺像约瑟夫环问题的，所以思路倒是很好想到，只要循环遍历数组，如果剩下的法力值不少于当前房间要消耗的法力值，就减掉当前房间要消耗的法力值，同时烙印数+1。 跳出循环的条件是，没有足够的法力值可以消耗了，也就是剩下的法力值都不够在消耗法力最少的房间花费了。所以在传入数组的时候就定义了一个 min 用以保存最少需要花费的法力，只要剩下的法力小于 min 就可以跳出循环。 2.3 代码#include&lt;iostream&gt; #include&lt;vector&gt; int main() &#123; int n;//房间数 int m;//法力值 int ans = 0; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;int&gt; room(n); int min = -1; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; room[i]; if (min == -1) min = room[i]; min = min &lt; room[i] ? min : room[i]; &#125; int i = 0; while (m &gt;= min) &#123; if (m &gt;= room[i]) &#123; m -= room[i]; ans++; &#125; i++; if (i == n) i = 0; &#125; std::cout &lt;&lt; ans; return 0; &#125; 题目三：小仓的射击练习4 3.1 题目 时间限制：C/C++语言 1000MS；其他语言 3000MS 内存限制：C/C++语言 65536KB；其他语言 589824KB 题目描述： 小仓酷爱射击运动。今天的小仓想挑战自我。小仓有 N 颗子弹，接下来小仓每次会自由选择 K 颗子弹进行连续射击，全中靶心的概率为 p[k] 。如果成功小仓将获得 a[k] 的得分，并且可以使用余下子弹继续射击，否则今天的挑战结束。小仓想知道在最佳策略下，自己能得到的最高期望分数是多少。 输入： 第一行一个数N，代表子弹数量。 第二行N个数p[]，第 i 个数代表p[i]。 第三行N个数a[]，第 i 个数代表a[i]。 1&lt;=N&lt;=5000 0&lt;=p[i]&lt;=1 0&lt;=a[i]&lt;=1000 输出： 一个数表示最高期望得分，保留两位小数。 示例1： 样例输入 2 0.80 0.50 1 2 样例输出 1.44 样例1解释 选择用一颗子弹射击：如果命中则再用余下子弹射击（仅剩一颗子弹故只能选择一颗）：0.80 * 1 + 0.80 * 0.80 * 1= 1.44 选择用两颗子弹射击：0.5 * 2 = 1.00 此时最高期望得分为1.44 示例2： 输入样例2 3 0.90 0.10 0.10 2 1 1 输出样例2 4.88 选择用一颗子弹射击：如果命中则再用一颗子弹进行射击，如果命中则再用一颗子弹进行射击（即3轮均使用了一颗子弹进行）：0.90 * 2 + 0.90 * 0.90 * 2+0.90 * 0.90 * 0.90 * 2= 4.878≈4.88 此种情况的期望得分最高，故为4.88 3.2 解题思路绝了，概率也不行，动态规划也不行…… 3.3 代码 题目四：拆分 4.1 题目 时间限制：C/C++语言 1000MS；其他语言 3000MS 内存限制：C/C++语言 65536KB；其他语言 589824KB 题目描述： 给定长度为n的串S，仅包含小写字母。定义： 公式中，|A|代表字符串A的长度。 也就是说如果子串是一个 ABA 型的字符串，且满足长度限制，则f(l,r)=1，否则等于0。（注意：形如 “ababab” 也可视为 ABA 型） 例如当n=2时，原式为 f(1,1)+f(1,2)+f(2,2) 。 输入： 第一行一个字符串S 第二行一个数字k 输出： 输出题目描述中式子的值 示例： 样例输入 abcabcabc 2 样例输出 8 提示 1 &lt;= n &lt;= 2000 ，S[i] 为小写字母 样例解释： 在这个字符串中，有 f(1,5),f(1,8),f(1,9),f(2,6),f(2,9),f(3,7),f(4,8),f(5,9) 的值为 1，其他为 0 ，故和为 8 。以 f(1,5) 为例，选择的子串是 abcab，令 A=“ab” ，B=“c” ，则 |A|&gt;=k 且 |B|&gt;=1 ，因此 f(1,5) 等于 1 ，以此类推。 4.2 解题思路4.3 代码 题目五：max xor min 5.1 题目 时间限制：C/C++语言 1000MS；其他语言 3000MS 内存限制：C/C++语言 65536KB；其他语言 589824KB 题目描述： 给你一个长度为n的序列 a，请你求出对每一个 1&lt;=l&lt;r&lt;=n 的区间中最大值和最小值的异或和的异或和。 例如序列为 &#123;1,3,5&#125; ,不同的 a(1,2)=1^3,a(1,3)=1^5,a(2,3)=(3^5),a(1,2)^a(1,3)^a(2,3)=0 ，所以最后的答案是 0 。 输入： 输入第一行仅包含一个正整数n，表示序列的长度。(1&lt;=n&lt;=10^5) 接下来一行有n个正整数a_i，表示序列a。(1&lt;=a_i&lt;=10^9) 输出： 输出仅包含一个整数表示所求的答案。 样例输入 3 1 3 5 样例输出 0 5.2 解题思路5.3 代码","categories":[],"tags":[{"name":"笔经","slug":"笔经","permalink":"https://mxy493.xyz/tags/%E7%AC%94%E7%BB%8F/"}]},{"title":"Leetcode 1111.有效括号的嵌套深度【C++】","date":"2020-04-01","updated":"2022-03-23","path":"2020040125540/","text":"地址：https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/ 题目有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。 嵌套深度 depth 定义：即有效括号字符串嵌套的层数。详情参见题末「嵌套深度」部分。 给你一个「有效括号字符串」 seq，请你将其分成两个不相交的子序列 A 和 B，且 A 和 B 都满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。 由于可能存在多种划分方案，请你从中选出 任意 这样的 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。其中 depth(A) 表示 A 的嵌套深度，depth(B) 表示 B 的嵌套深度。 请你返回一个长度为 seq.length 的答案数组 answer，编码规则如下：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。 示例 1： 输入：seq = &quot;(()())&quot; 输出：[0,1,1,1,1,0] 示例 2： 输入：seq = &quot;()(())()&quot; 输出：[0,0,0,1,1,0,1,1] 提示： 1 &lt;= text.size &lt;= 10000 有效括号字符串： 仅由 &quot;(&quot; 和 &quot;)&quot; 构成的字符串，对于每个左括号，都能找到与之对应的右括号，反之亦然。 下述几种情况同样属于有效括号字符串： 空字符串 连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串 嵌套，可以记作 (A)，其中 A 是有效括号字符串 嵌套深度： 类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)： s 为空时，depth(&quot;&quot;) = 0 s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串 s 为嵌套情况，depth(&quot;(&quot; + A + &quot;)&quot;) = 1 + depth(A)，其中 A 是有效括号字符串 例如：&quot;&quot;，&quot;()()&quot;，和 &quot;()(()())&quot; 都是有效括号字符串，嵌套深度分别为 0，1，2，而 &quot;)(&quot; 和 &quot;(()&quot; 都不是有效括号字符串。 解题思路括号匹配的问题初学C++的时候就有做过，用栈可以很方便的匹配两两配对的括号，用数组模拟栈也很容易。 不过这个题并不是让自己配对括号，题目已经说明传入的参数字符串 seq 已经是有效括号字符串，所以不用担心括号不配对或者存在其它字符的问题，字符串要么为空，要么就是已配对的并且只存在左右括号的字符串。 不管怎么分为两个字符串，它们各自的深度加起来一定是等于原字符串 seq 的深度的，同时最终的结果要取 max(depth(A), depth(B)) 的最小可能取值，显然需要将 depth(A) ， depth(B) 应该均匀的分配。也就说如果原字符串的深度为 4，那么应该满足 depth(A) = depth(B) = 2 ，如果原字符串的深度为 5，那么要么 depth(A) = 3 ， depth(B) = 2 ，要么 depth(A) = 2 ， depth(B) = 3 。只要搞懂了这一点就很容易了。 根据题目要求返回的是一个和 seq 长度相等的 vector&lt;int&gt; 数组，所以可以直接定义这样一个数组并将其长度初始化为 seq.size() 。 seq 可能为空，为空可直接返回空数组。 分别定义 maxDepth 记录原字符串 seq 的最大深度，depth 记录 seq 中每一个括号的深度，遍历字符串 seq 对应记录每一个括号的深度到数组 ans 中。 虽然分组的方法不止一个，但是显然可以把内层的括号分为一组，外层的括号分为一组，这样就可以很容易得到两个深度相等或者深度相差1的有效括号字符串。只需要遍历上述记录了每一个括号深度的数组 ans ，将深度小于等于 (maxDepth + 1) / 2 的置为 0 （或者 1），其余的置为 1 （或者 0）即可。 代码class Solution &#123; public: vector&lt;int&gt; maxDepthAfterSplit(string seq) &#123; vector&lt;int&gt; ans(seq.size()); if (seq.empty()) return ans; int maxDepth = 0;//最大深度 int depth = 0;//用于记录每一个括号的深度 //记录每一个括号的深度 for (int i = 0; i &lt; seq.size(); i++) &#123; if (seq[i] == &#x27;(&#x27;) &#123; depth++; maxDepth = maxDepth &gt; depth ? maxDepth : depth; ans[i] = depth; &#125; if (seq[i] == &#x27;)&#x27;) &#123; ans[i] = depth; depth--; &#125; &#125; //max(depth(A), depth(B))一定是maxDepth的一半取上整 for (int i = 0; i &lt; ans.size(); i++) &#123; ans[i] = ans[i] &lt;= (maxDepth + 1) / 2 ? 0 : 1; &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题62.圆圈中最后剩下的数字【C++】","date":"2020-03-30","updated":"2022-03-23","path":"2020033021384/","text":"地址：https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/ 题目0,1,…,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 示例 1： 输入: n = 5, m = 3 输出: 3 示例 2： 输入: n = 10, m = 17 输出: 2 限制： 1 &lt;= n &lt;= 10^5 1 &lt;= m &lt;= 10^6 解题思路这题最容易想到的思路肯定是模拟真实的逐个删除的场景了，也就是暴力解，但是我并没有上来就这么做，我觉得这题肯定就不是让这么做的，暴力解存在挺大的问题，很傻，要遍历 n 次，逻辑也不是很好写。 自己想却真就想不出来好办法，后来看了官方题解，确实比暴力解好很多吧，但是实在不是我能想出来的，甚至有一个步骤（ f(n, m) 和 f(n - 1, m) 之间的关系）我看了题解也花了不少时间菜弄明白。具体的思路还是看官方题解吧，挺难用文字描述清楚的，这个题更偏向于数学问题，用数学的方法解体就简单很多。 同时官方题解分别用递归和迭代做了这个题，其实都是一个思路，理论上说递归更符合人的思路，但是 n 越大就要递归越深使用大量的栈空间，所以迭代是更好的办法，并且只需要一个变量保存相关数据，空间复杂度O(1)。 代码递归： class Solution &#123; public: int lastRemaining(int n, int m) &#123; return f(n, m); &#125; int f(int n, int m) &#123; if (n == 1) return 0; int x = f(n - 1, m); return (m + x) % n; &#125; &#125;; 迭代： class Solution &#123; public: int lastRemaining(int n, int m) &#123; int f = 0; for (int i = 2; i != n + 1; ++i) f = (m + f) % i; return f; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1162.地图分析【C++】","date":"2020-03-29","updated":"2022-03-23","path":"2020032942771/","text":"地址：https://leetcode-cn.com/problems/as-far-from-land-as-possible/ 题目你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。 我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。 如果我们的地图上只有陆地或者海洋，请返回 -1。 示例 1： 输入：[[1,0,1],[0,0,0],[1,0,1]] 输出：2 解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。 示例 2： 输入：[[1,0,0],[0,0,0],[0,0,0]] 输出：4 解释： 海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。 提示： 1 &lt;= grid.length == grid[0].length &lt;= 100 grid[i][j] 不是 0 就是 1 解题思路这个题Leetcode上标注难度“中等”，我可以说做出来了，但也没做出来，因为逻辑是对的，但是超时…… 这里还是先讲我超时的思路。很简单的暴力解的思路，计算每一个海洋到最近的陆地的距离 mino ，再取其中的最大值 maxo 即题目要求的离陆地区域最远的海洋。 超时的原因很明显的，无脑的遍历并计算所有陆地到海洋的距离，也就是说对于 m 个陆地 n 个海洋的情况就要遍历并计算 m × n 种可能的情况，而且可以想到，并不是每个海洋都会与所有的陆地相接，所以完全没必要对不可能接触到的陆地做判断，这样看来显然我的暴力解是极其耗时的…… 具体逻辑：定义两个 vector&lt;pair&lt;int, int&gt;&gt; 类型数组 land 和 ocean ，遍历整个地图分别保存所有陆地和海洋的坐标。题目说了如果只有陆地或者海洋，就返回 -1 ，对应的就是如果 land.empty() || ocean.empty() 就返回 -1 。遍历所有的海洋，对每一个海洋 o ，遍历所有陆地并计算 o 与陆地之间的最短距离 mino，而题目要求的离陆地区域最远的海洋到里这个海洋最近的陆地的距离，就是陆地到每一个海洋的最近距离的最大值。 附上暴力解超时的代码如下~ 暴力解代码（超时）class Solution &#123; public: int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; vector&lt;pair&lt;int, int&gt;&gt; land; vector&lt;pair&lt;int, int&gt;&gt; ocean; for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if (grid[i][j] == 1) &#123; land.push_back(&#123; i,j &#125;); &#125; else &#123; ocean.push_back(&#123; i,j &#125;); &#125; &#125; &#125; //只有陆地或者海洋 if (land.empty() || ocean.empty()) return -1; int maxo = 0; for (auto o : ocean) &#123; //离海洋o最近的陆地的距离 int mino = abs(land[0].first - o.first) + abs(land[0].second - o.second); for (int i = 1; i &lt; land.size(); i++) &#123; int d = abs(land[i].first - o.first) + abs(land[i].second - o.second); mino = mino &lt; d ? mino : d; &#125; maxo = maxo &gt; mino ? maxo : mino; &#125; return maxo; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"利用rand7()构造rand10()及其一些推广","date":"2020-03-28","updated":"2022-03-23","path":"202003281807/","text":"今天看到一个群里有人说自己面试的题目，是利用 rand5() 来生成 rand3() ，刚看到我还懵了一下，真不会唉，而且涉及概率还是有点让人瑟瑟发抖的…… 然后我还是花时间 Google 了一下，网上很多类似的 randA() 生成 randB() 的，大概是说利用 rand7() 构造 rand10() 是头条的一个面试题。然后我就学习了一下。 利用 rand7() 构造 rand10()思路分析其中一个解法是这样的： 只要能构造10的倍数的随机数，就可用通过对10取余得到 rand10() 。 rand7() 可以生成随机的 &#123;1, 2, 3, 4, 5, 6, 7&#125; ； rand7() - 1 可以生成随机的 &#123;0, 1, 2, 3, 4, 5, 6&#125; ； (rand7() - 1) * 7 可以生成随机的 &#123;0, 7, 14, 21, 28, 35, 42&#125; ； (rand7() - 1) * 7 + rand7() 可以生成随机的 &#123;0, 7, 14, 21, 28, 35, 42&#125; + &#123;1, 2, 3, 4, 5, 6, 7&#125; ，也就是 1 ~ 49 的随机数； 上一步中取到的 1 ~ 49 的随机数，我们只需要取其中 1 ~ 40 的部分对10求余再加1即可得到 1 ~ 10 的随机数，即 rand10() 。特别需要注意的是，这里并不是单纯的舍去了 41 ~ 49 的随机数，其概率计算看下图。假设这里取到的是 1 ~ 48 的随机数，直接舍去 41 ~ 48 的话最终取到的每个数的概率并不是 1/10，而是 1/9 。 分析上一步：取 1 ~ 40 的随机数 x 对10求余，x % 10 可以得到随机的 &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125; ，所以还需要+1最终得到 rand10() 。 代码int rand10() &#123; int x; do &#123; x = (rand7()-1) * 7 + rand7(); &#125;while(x &gt; 40); return x % 10 + 1; &#125; 推广 利用 randA() 构造 randA*A()：对于任意的 randA() 都可以通过类似 rand7() 的前四步，获取到 randA*A() ，即 1 ~ A*A 的随机数。 可以利用 n*K - 1 的随机数构造 randK()：概率计算公式同上。例如 49 = 5*10 - 1 的随机数 rand49() ，就可以构造 rand10() 。刚好，利用 rand5() 来生成 rand3() 就是满足这一条件的，所以只需要取 rand5() 生成的 1 ~ 3 的随机数即可（已经是 1 ~ 3 的随机数，不需要对3求余再加1）。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://mxy493.xyz/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Leetcode 914.卡牌分组【C++】","date":"2020-03-27","updated":"2022-03-23","path":"2020032742159/","text":"地址：https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/ 题目给定一副牌，每张牌上都写着一个整数。 此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组： 每组都有 X 张牌。 组内所有的牌上都写着相同的整数。 仅当你可选的 X&gt;= 2 时返回 true。 示例 1： 输入：[1,2,3,4,4,3,2,1] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4] 示例 2： 输入：[1,1,1,2,2,2,3,3] 输出：false 解释：没有满足要求的分组。 示例 3： 输入：[1] 输出：false 解释：没有满足要求的分组。 示例 4： 输入：[1,1] 输出：true 解释：可行的分组是 [1,1] 示例 5： 输入：[1,1,2,2,2,2] 输出：true 解释：可行的分组是 [1,1]，[2,2]，[2,2] 提示： 1 &lt;= deck.length &lt;= 10000 0 &lt;= deck[i] &lt; 10000 解题思路思路还是很容易想到的，统计不同数字的个数，然后求所有不同数字的个数的最大公约数，也就是最终能分成的组中的数的个数。 如果数组中元素的个数不到2个，是肯定找不到符合要求的分组的，所以直接返回 false 即可。 我用了一个 vector&lt;pair&lt;int, int&gt;&gt; 的数组 cards 来统计不同数字的个数，cards[i].first 即数组中的某一个数字，cards[i].second 即这个数字在数组中的个数。然后遍历 cards 求所有的 cards[i].second 的最大公约数，返回值判断其是否大于或等于 2 即可。 代码class Solution &#123; public: bool hasGroupsSizeX(vector&lt;int&gt;&amp; deck) &#123; if (deck.size() &lt; 2) return false; //统计不同数字的个数 vector&lt;pair&lt;int, int&gt;&gt; cards; for (auto d : deck) &#123; bool exist = false; for (int i = 0; i &lt; cards.size(); i++) &#123; if (d == cards[i].first) &#123; cards[i].second++; exist = true; break; &#125; &#125; if (exist == false) &#123; cards.push_back(&#123; d,1 &#125;); &#125; &#125; int agcd = cards[0].second;//最大公约数，即最终每个组的数的个数 for (int i = 0; i &lt; cards.size(); i++) &#123; agcd = gcd(agcd, cards[i].second); &#125; return agcd &gt;= 2; &#125; //返回两个数的最大公约数 int gcd(int m, int n) &#123; int t = 1; while (t != 0) &#123; t = m % n; m = n; n = t; &#125; return m; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 999.车的可用捕获量【C++】","date":"2020-03-26","updated":"2022-03-23","path":"2020032631551/","text":"地址：https://leetcode-cn.com/problems/available-captures-for-rook/ 题目在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。 车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。 返回车能够在一次移动中捕获到的卒的数量。 示例 1： 输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] 输出：3 解释：在本例中，车能够捕获所有的卒。示例 2： 输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] 输出：0 解释：象阻止了车捕获任何卒。示例 3： 输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]] 输出：3 解释： 车可以捕获位置 b5，d6 和 f5 的卒。 提示： board.length == board[i].length == 8 board[i][j] 可以是 &#39;R&#39;，&#39;.&#39;，&#39;B&#39; 或 &#39;p&#39; 只有一个格子上存在 board[i][j] == &#39;R&#39; 解题思路首先读懂题目，可以知道棋盘上只有唯一的一个白色车 R ，这就是切入点，转化一下题目的意思其实就是 R 所在的行和列上能直接连通的黑色卒 p 的个数（直接连通是指，没有任何棋子阻挡，空格不是棋子。并且显然可以知道结果只可能是整数0 ~ 4）。 所以第一步，找到唯一 R 的位置。通过一个两层循环可以很容易做到，并且代码中我利用一层循环两边向中间遍历，可以节省一半的查找速度。 第二步，以 R 的坐标 (ai, aj) 为中心，分别遍历四个方向上是否有可以捕获到的卒。这里再一次利用到了 vector&lt;pair&lt;int, int&gt;&gt; 数组用于遍历以 R 为中心的四个方向。遇到空格不做处理；如果遇到白象，则跳出当前方向上的遍历以继续判断下一个方向；如果遇到黑卒 p ，则该黑卒能捕获，将数量 num++ ，并跳出当前方向的遍历。 在二层循环内部的判断是否找到 R 的 if 语句块的末尾，将数量 num 返回，因为棋盘中仅存在一个 R 。 函数需要一个返回值，所以函数末尾需要默认返回 0 ，事实上根据题意程序不会运行到函数末尾，因为棋盘大小已经给定总是 8×8 的，并且 R 也是一定存在的，函数总会在二层循环内部就将结果返回。 代码class Solution &#123; public: int numRookCaptures(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int num = 0;//数量，返回值 for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; 8; j++) &#123; //前后同时往中间遍历，加快一半的查找速度 if (board[i][j] == &#x27;R&#x27; || board[7 - i][j] == &#x27;R&#x27;) &#123; int ai, aj;//白车的坐标 if (board[i][j] == &#x27;R&#x27;) &#123; ai = i; aj = j; &#125; else &#123; ai = 7 - i; aj = j; &#125; vector&lt;pair&lt;int, int&gt;&gt; dir = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;//上、下、左、右 for (auto d : dir) &#123; int ii = ai + d.first; int jj = aj + d.second; //往一个方向遍历 while (ii &gt;= 0 &amp;&amp; ii &lt; 8 &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; 8) &#123; //白色的象 if (board[ii][jj] == &#x27;B&#x27;) &#123; break; &#125; //黑色的卒 else if (board[ii][jj] == &#x27;p&#x27;) &#123; num++; break; &#125; ii += d.first; jj += d.second; &#125; &#125; return num;//返回结果 &#125; &#125; &#125; return 0; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 892.三维形体的表面积【C++】","date":"2020-03-25","updated":"2022-03-23","path":"2020032548117/","text":"地址：https://leetcode-cn.com/problems/surface-area-of-3d-shapes/ 题目在 N * N 的网格上，我们放置一些 1 * 1 * 1 的立方体。 每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。 请你返回最终形体的表面积。 示例 1： 输入：[[2]] 输出：10 示例 2： 输入：[[1,2],[3,4]] 输出：34 示例 3： 输入：[[1,0],[0,2]] 输出：16 示例 4： 输入：[[1,1,1],[1,0,1],[1,1,1]] 输出：32 示例 5： 输入：[[2,2,2],[2,1,2],[2,2,2]] 输出：46 提示： 1 &lt;= N &lt;= 50 0 &lt;= grid[i][j] &lt;= 50 解题思路一开始这个题还真是一头雾水，虽然之前做过类似的题，比如前不久才做过的“腐烂橘子”那个题，就很类似。 只要做过类似的题，应该还是很容易想到要遍历二维数组，然后对每一个元素要判断其周围的元素，如果有需要的话可能还需要动态规划、递归之类的方法来解题。 仔细思考一下，其实这个题想通了思路还挺简单的，因为并没有用到动态规划或是递归，只需要遍历一次二维数组就可以了。 首先不考虑周围格子的情况下，每一个格子上所堆叠的正方体都有一个表面积，如果没有立方体那么它的表面积为 0 ，显然也不会有与别的立方体重叠的部分；否则该单元格上堆叠的立方体的表面积应为 4 * grid[i][j] + 2 。 然后考虑周围格子的情况，不管周围单元格是否有立方体，与当前单元格重叠的部分始终是较少立方体的个数，也就是 grid[i][j] &lt;= grid[ii][jj] ? grid[i][j] : grid[ii][jj] ，按照我们人的思维很容易想到应该减去2倍的重叠部分的面积，但是不能这么做，程序它不聪明，当它遍历的这个相邻单元格的时候，再一次减掉2倍的重叠部分的面积，实际上就减去了4倍的重叠部分的面积，所以我们应该只考虑当前单元格应该做的事，也就是只减掉当前单元格与相邻单元格重叠部分的面积（1倍）。 重复上述步骤遍历完整个二维数组，即可以得到最终的三维形体表面积。 代码class Solution &#123; public: int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int area = 0;//表面积 vector&lt;pair&lt;int, int&gt;&gt; dir = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;//上、下、左、右 for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; if (grid[i][j] == 0)//没有立方体不做处理，面积不改变 continue; area += 4 * grid[i][j] + 2;//不考虑四周重叠部分的表面积 for (auto d : dir) &#123; int ii = i + d.first; int jj = j + d.second; //减掉相邻立方体个数较少的一侧的面积 //例如4和2相邻，应减掉当前4个立方体与2相邻一侧的表面积2 if (ii &gt;= 0 &amp;&amp; ii &lt; grid.size() &amp;&amp; jj &gt;= 0 &amp;&amp; jj &lt; grid[0].size()) &#123; area -= grid[i][j] &lt;= grid[ii][jj] ? grid[i][j] : grid[ii][jj]; &#125; &#125; &#125; &#125; return area; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题 17.16.按摩师【C++】","date":"2020-03-24","updated":"2022-03-23","path":"2020032431756/","text":"地址：https://leetcode-cn.com/problems/the-masseuse-lcci/ 题目一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。 注意：本题相对原题稍作改动 示例 1： 输入： [1,2,3,1] 输出： 4 解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。 示例 2： 输入： [2,7,9,3,1] 输出： 12 解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。 示例 3： 输入： [2,1,4,5,3,1,1,3] 输出： 12 解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。 解题思路👉🏻官方题解：https://leetcode-cn.com/problems/the-masseuse-lcci/solution/an-mo-shi-by-leetcode-solution/ 能想到要用动态规划了，但是情景感觉好复杂，要把逻辑想清楚可真不容易。 代码相当于直接把 nums[i] 之前的数的的最有安排归结为两种情况，其时长分别为 dp0 和 dp1 ，然后每次只需要用当前的数和 dp0 、 dp1 做处理，然后确定新的 dp0 、 dp1 ，直到处理完数组中所有的数，最长时长即为 max(dp0, dp1) 。 代码class Solution &#123; public: int massage(vector&lt;int&gt;&amp; nums) &#123; int n = (int)nums.size(); if (n == 0) return 0; int dp0 = 0, dp1 = nums[0]; for (int i = 1; i &lt; n; ++i) &#123; int tdp0 = max(dp0, dp1); // 计算 dp[i][0] int tdp1 = dp0 + nums[i]; // 计算 dp[i][1] dp0 = tdp0; // 用 dp[i][0] 更新 dp_0 dp1 = tdp1; // 用 dp[i][1] 更新 dp_1 &#125; return max(dp0, dp1); &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"},{"name":"动态规划","slug":"动态规划","permalink":"https://mxy493.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Leetcode 876.链表的中间结点【C++】","date":"2020-03-23","updated":"2022-03-23","path":"2020032336939/","text":"地址：https://leetcode-cn.com/problems/middle-of-the-linked-list/ 题目给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 解题思路思路很简单，定义两个指针并且都初始化为指向头结点，然后 cur 指针遍历整个链表，cur 每移动两个结点，mid 指针就往后移动一个结点，这样 mid 就始终是从 head 到 cur 的中间结点，直到 cur 遍历完整个链表，则 mid 所指向的结点即整个链表的中间结点。 需要注意头结点本就是中间结点，往后移动一个结点的时候，就应该将 mid 指向第二个结点。 👉🏻更好一点的办法是用 step 记录节点数，偶数个结点的时候 mid 就往后移动一个结点，这样就不用对头结点特殊处理。 代码/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* middleNode(ListNode* head) &#123; ListNode* mid = head;//始终指向中间结点 ListNode* cur = head;//当前结点 int step = 1;//cur每隔一步往后移一位 while (cur != NULL) &#123; if (step == 0) &#123; mid = mid-&gt;next; step = 1; cur = cur-&gt;next; continue; &#125; cur = cur-&gt;next; step--; &#125; return mid; &#125; &#125;; 更好一点的办法class Solution &#123; public: ListNode* middleNode(ListNode* head) &#123; ListNode* mid = head;//始终指向中间结点 ListNode* cur = head;//当前结点 int step = 1;//结点数为偶数的时候指针mid往后移一位 while (cur != NULL) &#123; if (step % 2 == 0) mid = mid-&gt;next; cur = cur-&gt;next; step++; &#125; return mid; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 945.使数组唯一的最小增量【C++】","date":"2020-03-22","updated":"2022-03-23","path":"2020032227578/","text":"地址：https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/ 题目给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。 返回使 A 中的每个值都是唯一的最少操作次数。 示例 1: 输入：[1,2,2] 输出：1 解释：经过一次 move 操作，数组将变为 [1, 2, 3]。 示例 2: 输入：[3,2,1,2,1,7] 输出：6 解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。 可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。 提示： 0 &lt;= A.length &lt;= 40000 0 &lt;= A[i] &lt; 40000 解题思路解题思路不算很复杂，一开始我上来就暴力解，遍历数组，然后对每一个数往前找是否有跟它相同的数，有的话就将其自身+1，操作步数+1，然后再来一遍，直到这个数的前面没有跟它相同的数。解题思路是对的，能得到正确结果，但是时间复杂度太高了，提交到 Leetcode 就会超时。 然后我想到了先对数组进行排序，排序我直接调用了 sort() 函数，这样就只需要遍历一次数组即可，对于每一个数只需要比较相邻的数是否相等，事实上由于对数组进行了修改，排序过的数组的顺序就可能打乱导致前面的数大于后面的数，但是操作步数始终应该等于 A[i - 1] - A[i] + 1 ，因为顺序未打乱前，前一个数应该是小于或者等于当前的数的，而顺序打乱后，只需要让当前的数变得比前一个数大即可。 特殊情况数组A的长度为0的时候操作步数显然为0，同时长度为1的时候，显然操作步数也是0，将A的长度为0和1的情况特殊处理，后续的判断就可以直接从 A[1] 开始，每一个数和前一个数作比较。 代码class Solution &#123; public: int minIncrementForUnique(vector&lt;int&gt;&amp; A) &#123; if (A.size() &lt;= 1) return 0; int operations = 0; //此部分代码时间复杂度过高，会超时 //for (int i = 1; i &lt; A.size(); i++) &#123; // for (int j = i - 1; j &gt;= 0; j--) &#123; // if (A[j] == A[i]) &#123; // A[i]++; // operations++; // j = i; // continue; // &#125; // &#125; //&#125; //对数组排序，每次只需要和前一个数比较即可，时间复杂度为O(n) sort(A.begin(), A.end()); for (int i = 1; i &lt; A.size(); i++) &#123; if (A[i] &lt;= A[i - 1]) &#123; int tmp = A[i - 1] - A[i]; A[i] += tmp + 1; operations += tmp + 1; &#125; &#125; return operations; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 365.水壶问题【C++】","date":"2020-03-21","updated":"2022-03-23","path":"2020032136490/","text":"地址：https://leetcode-cn.com/problems/water-and-jug-problem/ 题目有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？ 如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。 你允许： 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空 示例 1: (From the famous “Die Hard” example) 输入: x = 3, y = 5, z = 4 输出: True 示例 2: 输入: x = 2, y = 6, z = 5 输出: False 解题思路想到了深度优先搜索，但是没能实现…… 👇🏻 好好学数学 ಥ_ಥ 官方题解：https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/ 代码class Solution &#123; public: bool canMeasureWater(int x, int y, int z) &#123; if (x + y &lt; z) return false; if (x == 0 || y == 0) return z == 0 || x + y == z; return z % gcd(x, y) == 0; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题40.最小的k个数【C++】","date":"2020-03-21","updated":"2022-03-23","path":"2020032152167/","text":"地址：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/ 题目输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2： 输入：arr = [0,1,2,1], k = 1 输出：[0] 限制： 0 &lt;= k &lt;= arr.length &lt;= 10000 0 &lt;= arr[i] &lt;= 10000 解题思路这个题思路来的挺快的，不过肯定不是最好的办法了。看完题目我就想到了对数组进行排序，然后从小到大取 k 个数出来就好了。 然后我就按着这个思路写了一个反向的冒泡排序，把最小的数从后往前冒泡，最后就会得到一个从小到大的数组，之所以反向冒泡，是因为题目要求要找的是最小的 k 个数，所以我就想到把最小的数先冒泡求出来，就可以将其加入到数组 min 中保存，然后由于只需要返回最小的k个数，所以只要得到了最小的k个数，就可以返回结果，剩下的元素就没必要再排序了。顺利地写出来下面的代码~ 需要注意考虑特殊情况，如果题目没有做限制的话，我们是需要考虑数组 arr[] 的大小小于 k 的情况的，但是题目已经说明了 0 &lt;= k &lt;= arr.length &lt;= 10000 ，也就是说前述的情况不可能存在。但 k 可以取到 0 ，显然这个时候返回的应该是一个空数组；还有一种“特殊”情况是 k == arr.size() ，虽然不把它作为特殊情况程序也没问题，但是这种情况下显然返回值就是原数组，没必要对其进行排序，然后逐个取最小的数再构造一个数组。 存在的缺陷：考虑到上述 k == arr.size() 的情况后，我又想到了个问题，按照我的解题思路，如果 k 相对于数组 arr[] 的大小比较小的话，那只需要对少量的k个数排序就能得到结果，但如果 k 相对于数组 arr[] 的大小很大的情况下，如果 arr[] 中有9个元素，而 k == 8 ，那这种情况下就要对八个数进行排序，代价就更大了。 改进思路：有一个小改进思路，首先对判断 k &lt; arr.size()/2 ，如果为 true，那就从小往大对较少的k个数排序就可以得到结果；如果为 false ，则反过来从大到小对 arr.size() - k 个数排序，然后剩下没排序的k个数即要返回的结果。 代码（原始思路）class Solution &#123; public: vector&lt;int&gt; getLeastNumbers(vector&lt;int&gt;&amp; arr, int k) &#123; vector&lt;int&gt; min;//返回值 //k &lt;= arr.length，如果k为0则直接返回空数组 if (k == 0) return min; //如果k刚好等于arr的大小，则直接返回原数组arr if (arr.size() == k) return arr; //冒泡排序，把最小的数从后往前冒泡 for (int i = 0; i &lt; arr.size(); i++) &#123; for (int j = arr.size() - 1; j &gt; i; j--) &#123; if (arr[j] &lt; arr[j - 1]) &#123; int tmp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = tmp; &#125; &#125; min.push_back(arr[i]); //只要找到了k个数就可以不再继续往下找 if (min.size() == k) break; &#125; return min; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 409.最长回文串【C++】","date":"2020-03-19","updated":"2022-03-23","path":"2020031962002/","text":"地址：https://leetcode-cn.com/problems/longest-palindrome/ 题目给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 输入: &quot;abccccdd&quot; 输出: 7 解释: 我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。 解题思路解题思路还是很容易想到的，回文串的特征很明显，就是左右对称，也就是说只有正中可能存在单个的字符，其余的字符都一定是偶数个。 所以我很快就想到了统计字符串中不同字符的个数，使用了一个 vector&lt;pair&lt;char, int&gt;&gt; 类型的数组 count 用于保存每个字符及其对应的个数。 然后遍历 count 将每个字符的最多可能取到的偶数个数加到 length ，然后为了尽可能的让回文串的长度更长，所以如果存在计数个数的字符，那就应该再+1，即表示将一个单个的字符作为回文串的正中的字符。 代码class Solution &#123; public: int longestPalindrome(string s) &#123; int length = 0;//返回值默认为0 //统计每个字符的个数 vector&lt;pair&lt;char, int&gt;&gt; count; for (auto c : s) &#123; bool exist = false; for (int i = 0; i &lt; count.size(); i++) &#123; if (c == count[i].first) &#123; count[i].second++; exist = true; &#125; &#125; if (exist == false) &#123; count.push_back(&#123; c,1 &#125;); &#125; &#125; bool b = false;//判断是否有奇数个数的字符 for (auto co : count) &#123; //个数为偶数直接加进length if (co.second % 2 == 0) &#123; length += co.second; &#125; //个数为奇数 else &#123; //b为false表明第一次遇到奇数个数的字符，将其个数加到length并将b置为true if (b == false) &#123; length += co.second; b = true; &#125; //b不为false表明已遇到过奇数个数的字符，此时应该讲偶数个的该字符加到length else &#123; length += co.second - 1; &#125; &#125; &#125; return length; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 836.矩形重叠【C++】","date":"2020-03-18","updated":"2022-03-23","path":"2020031849025/","text":"地址：https://leetcode-cn.com/problems/rectangle-overlap/ 题目矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。 如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。 给出两个矩形，判断它们是否重叠并返回结果。 示例 1： 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3] 输出：true 示例 2： 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1] 输出：false 提示： 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。 矩形中的所有坐标都处于 -10^9 和 10^9 之间。 x 轴默认指向右，y 轴默认指向上。 你可以仅考虑矩形是正放的情况。 解题思路这个题我觉得主要是考思维吧，因为这个题完全没用到循环什么的，就一个两个判断就可以了，以至于我一开始都不太相信就是这么做的…… 根据题目的意思，两个矩形的坐标一定是左下角坐标在前，右上角坐标在后，也就是可以确定 rec1[0] 不可能比 rec1[2] 大，其它的坐标也是同理。 首先对传入的 rec1 和 rec2 做检查，矩形坐标不合法就直接返回 false。 如果矩形坐标合法，那么要使两个矩形重叠，只需要满足 rec1 右上角的点在 rec2 左下角的点的右上方，rec1 左下角的点在 rec2 右上角的点的左下方。 代码class Solution &#123; public: bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123; if (rec1.empty() || rec2.empty() || rec1[0] == rec1[2] || rec1[1] == rec1[3] || rec2[0] == rec2[2] || rec2[1] == rec2[3]) return false; //只要rec1右上角的点在rec2左下角的点的右上方， //rec1左下角的点在rec2右上角的点的左下方，就一定重叠 if (rec1[2] &gt; rec2[0] &amp;&amp; rec1[3] &gt; rec2[1] &amp;&amp; rec1[0] &lt; rec2[2] &amp;&amp; rec1[1] &lt; rec2[3]) return true; return false;//默认返回false &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1160.拼写单词【C++】","date":"2020-03-17","updated":"2022-03-23","path":"2020031713987/","text":"地址：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/ 题目给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。 注意：每次拼写时，chars 中的每个字母都只能用一次。 返回词汇表 words 中你掌握的所有单词的 长度之和。 示例 1： 输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot; 输出：6 解释： 可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。 示例 2： 输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot; 输出：10 解释： 可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。 提示： 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length, chars.length &lt;= 100 所有字符串中都仅包含小写英文字母 解题思路这个题其实就是从 words 中取出一个单词，然后到 chars 中去找字符看是否能组成这个单词。唯一需要考虑的是， chars 中的每个字符在一个单词中只能使用一次，所以应该标记已经使用过的单词。 首先如果 words 或 chars 为空，则直接返回0，因为不可能有能拼写的单词。然后定义一个 length 并将其初始化为0，用于保存掌握的单词的长度和，遍历 words 中的所有单词，定义一个和字母表中字符个数相同的 vector&lt;int&gt; 数组 mark[]，将其初始化为全1，表示所有字符均未被使用，然后二层循环遍历每个单词的所有字母，然后第三层循环遍历 chars 查找是否有还未使用过的这个字母，如果有，将 chars 中的这个字母标记为已经用，即 mark[j] = 0; ，继续循环查找下一个字母。只要三层循环中有一个字母找不到，则表示这个单词不能拼写，应直接查找下一个单词。找到一个能拼写的单词，就将这个单词的长度加到 length 上。循环上述步骤，直到遍历完 words 。 代码class Solution &#123; public: int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123; if (words.empty() || chars.empty()) return 0; int length = 0;//总长度 int n = chars.length(); for (auto word : words) &#123; bool b = true;//该单词能否拼写 vector&lt;int&gt; mark(n, 1);//标记字符是否被使用，0为已使用，1为未使用 for (auto c : word) &#123; bool findc = false;//是否有没被使用过的这个字符 for (int j = 0; j &lt; n; j++) &#123; if (c == chars[j] &amp;&amp; mark[j] == 1) &#123; findc = true; mark[j] = 0;//该字符被使用 break; &#125; &#125; //只要有一个字符没找到则这个单词不能拼写 if (findc == false) &#123; b = false; break; &#125; &#125; if (b == true) &#123; length += word.length(); &#125; &#125; return length; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题 01.06.字符串压缩【C++】","date":"2020-03-16","updated":"2022-03-23","path":"2020031636595/","text":"地址：https://leetcode-cn.com/problems/compress-string-lcci/ 题目字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串 aabcccccaaa 会变为 a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。 示例1: 输入：&quot;aabcccccaaa&quot; 输出：&quot;a2b1c5a3&quot; 示例2: 输入：&quot;abbccd&quot; 输出：&quot;abbccd&quot; 解释：&quot;abbccd&quot;压缩后为&quot;a1b2c2d1&quot;，比原字符串长度更长。 提示： 字符串长度在[0, 50000]范围内。 解题思路由于传入的字符串长度可能为0，所以这种特殊情况应该直接返回原字符串（无法对其进行压缩）。 由于题目要求是压缩字符串，但是如果“压缩”后的字符串长度没有变短的话，就应该返回原字符串，所以不应该在原字符串上进行修改，所以我定义了一个新的字符串 cpStr 存储压缩后的字符串。 思路很简单，遍历原字符串，取出一个字符串将其追加到 cpStr 末尾，然后对这个字符进行计数，直到遇到下一个不同的字符计数结束，将计数追加到 cpStr 末尾，并重新将计数 count 修改为1，即当前新遇到的字符个数为1，然后再对新遇到的字符计数，循环前述步骤，直到遍历完原字符串。最后跳出循环还应该将最后一个字符的计数值追加到 cpStr 末尾，因为循环内部最后一个字符不会再遇到新的字符，所以虽然对其进行了计数但是并没有将它的个数追加到压缩的字符串的末尾。 最后返回结果用一个条件表达式，判断 cpStr 的长度是否小于原字符串长度，当且仅当小于原字符串长度的时候才将压缩后的 cpStr 返回，否则应返回原字符串。 代码class Solution &#123; public: string compressString(string str) &#123; int length = str.length();//获取字符串长度 if (length == 0) return str; string cpStr;//压缩后的字符串 char c = str[0]; cpStr += c; int count = 0;//计数某一个字符 for (int i = 0; i &lt; length; i++) &#123; if (str[i] == c) &#123; count++; &#125; else &#123; if (count &gt; 0) &#123; cpStr += to_string(count); c = str[i]; cpStr += c; count = 1; &#125; &#125; &#125; cpStr += to_string(count);//追加最后一个字符的个数 return cpStr.length() &lt; length ? cpStr : str; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 695.岛屿的最大面积【C++】","date":"2020-03-15","updated":"2022-03-23","path":"2020031511361/","text":"地址：https://leetcode-cn.com/problems/max-area-of-island/ 题目给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的 ‘1’。 示例 2: [[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 解题思路这题也是看了官方题解才做出来的，其实自己都想到了深度优先搜索，想到了要递归，但是却没想到将搜索过的元素置为0。 主函数遍历整个二维数组，不管当前元素是0还是1，对每一个元素都调用搜索函数。 搜索函数首先判断元素的坐标 (i,j) 是否合法，以及当前元素是否为0，如果坐标不合法或者当前元素为0，则可以直接返回0表示当前元素不处在岛屿中。否则当前元素为1，即当前元素是一个岛屿的一部分，此时应以当前元素为中心递归搜索其周围的元素，找到一个就将面积+1，并将找到的元素置为0避免重复搜索。 代码class Solution &#123; public: int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int ans = 0;//返回值 //遍历二维数组 for (int i = 0; i &lt; grid.size(); i++) &#123; for (int j = 0; j &lt; grid[0].size(); j++) &#123; ans = max(ans, dfs(grid, i, j)); &#125; &#125; return ans; &#125; //深度优先搜索 int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int i, int j) &#123; if (i &lt; 0 || j &lt; 0 || i &gt;= grid.size() || j &gt;= grid[0].size() || grid[i][j] == 0) return 0; int ans = 1;//将当前位置的面积1初始化 grid[i][j] = 0;//已处理过的元素将其置为0，避免重复 int di[4] = &#123; 0,0,1,-1 &#125;; int dj[4] = &#123; 1,-1,0,0 &#125;; //遍历grid[i][j]周围的四个元素 for (int index = 0; index &lt; 4; index++) &#123; int next_i = i + di[index]; int next_j = j + dj[index]; ans += dfs(grid, next_i, next_j); &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 300.最长上升子序列【C++】","date":"2020-03-14","updated":"2022-03-23","path":"2020031457288/","text":"地址：https://leetcode-cn.com/problems/longest-increasing-subsequence/ 题目给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例： 输入: [10,9,2,5,3,7,101,18] 输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明： 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。进阶： 你能将算法的时间复杂度降低到 O(n log n) 吗? 解题思路没思路，然后看了官方题解： https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/ 这里就不复述具体的解题思路了，不太好描述清楚，官方题解中有动画演示，讲的很清晰。 附上官方题解中的状态转移方程：dp[i] = max(dp[j]) + 1，其中 0 ≤ j &lt; i 且 num[j] &lt; num[i] dp[i]为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度。 代码class Solution &#123; public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size();//nums[]的长度 if (n == 0) return 0; //dp[i]保存从nums[0]到nums[i]的子序的最长上升子序的长度 vector&lt;int&gt; dp(n, 0); for (int i = 0; i &lt; n; i++) &#123; dp[i] = 1;//默认为1即假设前面的元素中没有大于nums[i]的元素 //遍历nums[i]之前的元素 for (int j = 0; j &lt; i; j++) &#123; //只要有比nums[i]小的元素，就要更新dp[i] if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; &#125; return *max_element(dp.begin(), dp.end());//返回数组dp[]中的最大值 &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 169.多数元素【C++】","date":"2020-03-13","updated":"2022-03-23","path":"2020031339745/","text":"地址：https://leetcode-cn.com/problems/majority-element 题目给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1: 输入: [3,2,3] 输出: 3 示例 2: 输入: [2,2,1,1,1,2,2] 输出: 2 解题思路思路很简单，就是遍历数组记录每一个元素的个数，由于最终是要返回元素，所以需要将元素和其个数成对保存，我使用了 vector&lt;pair&lt;int, int&gt;&gt; 的数组来存储。 遍历数组，先到 aNums[] 中查找 num 是否已存在，如果已存在则将其个数+1；不存在，则将其添加到 aNums[] 并将其个数初始化为1。 题目已经说明“给定的数组总是存在多数元素”，所以可以确定出现次数大于 ⌊ n/2 ⌋ 的多数元素有且仅有一个。所以每遍历一个元素，我们就判断其个数是否大于 nums.size() / 2 ，一旦有一个元素的个数大于 nums.size() / 2 则说明这个元素就是要求的多数元素，直接将该元素返回即可。 代码class Solution &#123; public: int majorityElement(vector&lt;int&gt;&amp; nums) &#123; //可作为跳出循环的条件，因为多数元素只存在一个 int low = nums.size() / 2; vector&lt;pair&lt;int, int&gt;&gt; aNums;//保存元素及其个数 //统计不同元素的个数，一旦某个元素的个数大于low则可直接返回这个元素 for (auto num : nums) &#123; int quantity = 0;//num的个数 //查找aNums[]中是否已有num的记录 for (int i = 0; i &lt; aNums.size(); i++) &#123; //如果有的话，将其数量+1，并更新quantity if (aNums[i].first == num) &#123; aNums[i].second++; quantity = aNums[i].second; break; &#125; &#125; //quantity==0表明num第一次遇到 if (quantity == 0) &#123; aNums.push_back(&#123; num,1 &#125;);//将其添加到aNums[]中，数量初始化为1 quantity = 1;//更新num的数量为1 &#125; if (quantity &gt; low) return num; &#125; return 0;//遍历完整个数组之前一定能返回结果，不会运行到这一步 &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1071.字符串的最大公因子【C++】","date":"2020-03-12","updated":"2022-03-23","path":"2020031242499/","text":"地址：https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/ 题目对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。 返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。 示例 1： 输入：str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot; 输出：&quot;ABC&quot; 示例 2： 输入：str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot; 输出：&quot;AB&quot; 示例 3： 输入：str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot; 输出：&quot;&quot; 提示： 1 &lt;= str1.length &lt;= 1000 1 &lt;= str2.length &lt;= 1000 str1[i] 和 str2[i] 为大写英文字母 解题思路1. 原始思路我的解题思路大概算是暴力解吧。 我想到的是，如果两个字符串存在公共子串，并且这个子串能同时除尽两个字符串，那么这个子串的长度一定是两个字符串的长度的公约数。所以按照这个思路，应该找出两字符串长度的所有公约数，逐一判断以某一公约数为长度的子串（subString）是否能同时除尽 str1 和 str2 。 题目要求不仅要是子串，而且是最长子串，所以在找公约数的时候，从大到小找，并将公约数逐一存储到数组中备用。 从找到的公约数中，逐个取出公约数 cd（从大到小），从任一个字符串中截取以 cd 为长度的子串 subString，然后分别判断两个字符串是否能被 subString 除尽，如果前一个字符串不能被 subString 除尽，那么不必再判断后一个字符串，此时应该选取更短一点的子串继续判断。而 subString 的长度是从大到小取的，所以一旦遇到一个子串 subString 能除尽两个字符串，则可以直接将这个 subString 作为结果返回。 否则，知道函数运行结束，默认返回空串 &quot;&quot;。 2. 优化思路有一个小的优化思路，写完提交之后，再看代码，发现其实并没必要将公约数存储下来，完全可以从大到小找到一个公约数就判断以这个公约数为长度的子串是否满足题意。可以同时降低空间复杂度和时间复杂度~ 具体实现代码在“代码【2】”中！ 代码【1】class Solution &#123; public: string gcdOfStrings(string str1, string str2) &#123; vector&lt;int&gt; commonDivisor;//存储两字符串长度的公约数 int len_str1 = str1.length(); int len_str2 = str2.length(); int small = len_str1 &lt; len_str2 ? len_str1 : len_str2;//较短字符串的长度 //从大到小找两字符串长度的公约数并存储到数组commonDivisor中 for (int i = small; i &gt; 0; i--) &#123; if (len_str1 % i == 0 &amp;&amp; len_str2 % i == 0) &#123; commonDivisor.push_back(i); &#125; &#125; //从大到小判断长度为某公约数的子串是否能被两字符串除尽 for (auto cd : commonDivisor) &#123; bool div = true;//能否被除尽 string subString = str1.substr(0, cd);//从任一字符串中取长度为公约数cd的子串 //判断str1是否能被subString除尽 for (int i = 0; i &lt; len_str1; i += cd) &#123; if (subString != str1.substr(i, cd)) &#123; div = false; break; &#125; &#125; //判断str2是否能被subString除尽 //如果 div == false 则说明str1不能被subString除尽，不必再判断str2 for (int i = 0; div == true &amp;&amp; i &lt; len_str2; i += cd) &#123; if (subString != str2.substr(i, cd)) &#123; div = false; break; &#125; &#125; //由于是从大到小判断，所以当遇到第一个能除尽两个字符串的子串即可直接返回结果 if (div == true) return subString; &#125; return &quot;&quot;; &#125; &#125;; 代码【2】class Solution &#123; public: string gcdOfStrings(string str1, string str2) &#123; int len_str1 = str1.length(); int len_str2 = str2.length(); int small = len_str1 &lt; len_str2 ? len_str1 : len_str2;//较短字符串的长度 //从大到小找两字符串长度的公约数并存储到数组commonDivisor中 for (int cd = small; cd &gt; 0; cd--) &#123; if (len_str1 % cd == 0 &amp;&amp; len_str2 % cd == 0) &#123; bool div = true;//能否被除尽 string subString = str1.substr(0, cd);//从任一字符串中取长度为公约数cd的子串 //判断str1是否能被subString除尽 for (int i = 0; i &lt; len_str1; i += cd) &#123; if (subString != str1.substr(i, cd)) &#123; div = false; break; &#125; &#125; //判断str2是否能被subString除尽 //如果 div == false 则说明str1不能被subString除尽，不必再判断str2 for (int i = 0; div == true &amp;&amp; i &lt; len_str2; i += cd) &#123; if (subString != str2.substr(i, cd)) &#123; div = false; break; &#125; &#125; //由于是从大到小判断，所以当遇到第一个能除尽两个字符串的子串即可直接返回结果 if (div == true) return subString; &#125; &#125; return &quot;&quot;; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1013.将数组分成和相等的三个部分【C++】","date":"2020-03-11","updated":"2022-03-23","path":"2020031157295/","text":"地址：https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/ 题目给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。 形式上，如果可以找出索引 i+1 &lt; j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。 示例 1： 输出：[0,2,1,-6,6,-7,9,1,2,0,1] 输出：true 解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 示例 2： 输入：[0,2,1,-6,6,7,9,-1,2,0,1] 输出：false 示例 3： 输入：[3,3,6,5,-2,2,5,1,-9,4] 输出：true 解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 提示： 3 &lt;= A.length &lt;= 50000 -10^4 &lt;= A[i] &lt;= 10^4 解题思路这个题不难，首先需要明白的是，如果一个数组能如题述那样分成三等分，那么这三个和相等，并且三个等分的和相加即为整个数组所有元素的和。 求整个数组的和 sum 是很简单的，如果这个数组能三等分则每个等分的和即为 sum/3 ，所以我们只需要遍历数组，逐个元素相加求和 sumOfPart，一旦 sumOfPart == sum / 3 则说明找到了一个等分，此时将 sumOfPart 重置为0（以开始计算新的一部分的部分和），并将 part++ 表示新找到了一个等分。 特别需要注意的是，当 sum == 0 的时候，sumOfPart == 0 是可能存在多个部分的，即 part &gt;= 3，但不能小于3，因为至少需要三等分。 代码class Solution &#123; public: bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) &#123; //计算整个数组的和 int sum = 0; for (auto a : A) &#123; sum += a; &#125; int part = 0;//计数和为sum/3的分组数 int sumOfPart = 0;//部分和 for (auto a : A) &#123; sumOfPart += a; if (sumOfPart == sum / 3) &#123; sumOfPart = 0;//将部分和重置为0 part++;//组数+1 &#125; &#125; //当sum==0的时候part存在大于3的情况,但不可能小于3 return part &gt;= 3 ? true : false; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 543.二叉树的直径【C++】","date":"2020-03-10","updated":"2022-03-23","path":"2020031047606/","text":"地址：https://leetcode-cn.com/problems/diameter-of-binary-tree/ 题目给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。 示例 :给定二叉树 1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 解题思路首先这个题需要注意一点，整棵树的最长路径，不一定是左右子树的深度相加，因为可能最长路径并没有经过根结点。但是可以确定的是，最长路径一定是某一个结点作为根节点的左右子树的深度相加。 所以如果求出每一个结点作为根结点的左右子树的深度，也就可以找出所有可能的最长路径，只需要不断更新最大长度即可。 代码/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: int maxLength = 0;//最大长度 int diameterOfBinaryTree(TreeNode* root) &#123; //如果树为空则长度为0 if (root == NULL) return 0; getDepth(root); return maxLength; &#125; //获取深度 int getDepth(TreeNode* root) &#123; //树空则深度为0 if (root == NULL) return 0; int leftDepth = getDepth(root-&gt;left);//左子树深度 int rightDepth = getDepth(root-&gt;right);//右子树深度 //当前树的左右深度相加即经过根结点的最长路径（但不是整棵树的最长路径） //整棵树的最长路径需要根据经过每一个结点作为根结点并且经过该根结点的最长路径动态更新 maxLength = max(maxLength, leftDepth + rightDepth); return max(leftDepth, rightDepth) + 1;//+1即当前根结点到父节点之间的路径 &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 121.买卖股票的最佳时机【C++】","date":"2020-03-09","updated":"2022-03-23","path":"2020030911514/","text":"地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 题目给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路这个题其实不是第一次遇上了，初学C++的时候就做过这个题，有几个需要注意的地方是： 需要判别数组为空的情况，此时利润为0可以直接返回； 不能在买入股票前卖出股票，所以不是单纯找数组的最小值、最大值； 股票价格起伏不定，阶段性的买入卖出获得的是阶段性的最大利润，所以在题目要求“最多只允许完成一笔交易”的情况下，要始终保持利润最大化。 代码class Solution &#123; public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int profit = 0;//利润 int buy = prices[0];//买入价格 int sold = prices[0];//售出价格 for (auto price : prices) &#123; if (price &lt; buy) &#123; buy = price;//当前价格低于原买入价格，则应以当前价格买入 sold = price;//由于售出不能早于买入，所以每当以新的低价买入的时候应同步修改卖出价格 &#125; if (price &gt; sold) &#123; sold = price;//当前价格高于原卖出价格，则应以当前价格卖出 //存在前一段时间利润高于后一段时间利润的情况，要保持利润最大化 profit = (sold - buy) &gt; profit ? (sold - buy) : profit; &#125; &#125; return profit; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 322.零钱兑换【C++】","date":"2020-03-08","updated":"2022-03-23","path":"202003087706/","text":"地址：https://leetcode-cn.com/problems/coin-change/ 题目给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 输入: coins = [2], amount = 3 输出: -1 说明: 你可以认为每种硬币的数量是无限的。 解题思路解题思路参考官方题解~ 一开始的时候自己尝试做这道题，首先想到的办法是将硬币按面值从小到大排序，然后尽可能多的取面较值大的，最终将不同面值的硬币个数加起来即题解。但后来发现，其实有时候并不是面值越大的越多就符合题意，因为会有取面值小一点的才能组合成总金额的情况，所以这个思路是错误的。 然后我参考了官方的题解的自上而下的动态规划法！ 官方题解：https://leetcode-cn.com/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/ 首先定义： F(S)：组成金额 S 所需的最少硬币数量 [Cn……Cn-₁]：可选的 n 枚硬币面额值 假设我们知道 F(S) ，即组成金额 S 最少的硬币数，最后一枚硬币的面值是 C。那么由于问题的最优子结构，转移方程应为：F(S) = F(S − C) + 1 。但由于不知道最后一枚硬币的面值是多少，所以需要枚举每个硬币面额值并取其中的最小值。 另外为了避免重复的计算，将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中取出返回即可，这样能保证每个子问题最多只被计算一次。 代码class Solution &#123; public: vector&lt;int&gt; count;//用于存储 0~amount 的所有总金额的最少硬币数 //动态规划（Dynamic programming） int dp(vector&lt;int&gt;&amp; coins, int rem) &#123; if (rem &lt; 0) return -1;//余额小于0 if (rem == 0) return 0;//余额等于0 //如果 count[rem - 1] != 0 说明已获取到组成总金额的最少硬币数 if (count[rem - 1] != 0) return count[rem - 1]; int Min = INT_MAX; //枚举不同面额值得硬币分别使用动态规划法求解 for (int coin : coins) &#123; int res = dp(coins, rem - coin); if (res &gt;= 0 &amp;&amp; res &lt; Min) &#123; Min = res + 1; &#125; &#125; count[rem - 1] = Min == INT_MAX ? -1 : Min; return count[rem - 1]; &#125; int coinChange(vector&lt;int&gt;&amp; coins, int amount) &#123; if (amount &lt; 1) return 0;//总金额小于1 count.resize(amount);//将count初始化大小为amount return dp(coins, amount); &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 53.最大子序和【C++】","date":"2020-03-07","updated":"2022-03-23","path":"2020030735761/","text":"地址：https://leetcode-cn.com/problems/maximum-subarray/ 题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 解题思路笨办法！遍历所有可能的子序并计算其子序和，不断地更新最大子序和。 代码class Solution &#123; public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int maxSum = nums[0];//子序和 for (int i = 0; i &lt; nums.size(); i++) &#123; //查找并更新从每一个数开始的所有可能子序的子序和 int sum = 0;//以nums[i]开头的子序的子序和 for (int j = i; j &lt; nums.size(); j++) &#123; sum += nums[j]; maxSum = sum &gt; maxSum ? sum : maxSum; &#125; &#125; return maxSum; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 58.最后一个单词的长度【C++】","date":"2020-03-07","updated":"2022-03-23","path":"202003072784/","text":"地址：https://leetcode-cn.com/problems/length-of-last-word/ 题目给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例： 输入: &quot;Hello World&quot; 输出: 5 解题思路一开始想着就是遍历字符串，思路是每遇到一个单词的第一个字符就开始统计这个单词的长度，然后找到最后的这个单词就可以了。 后来一下子想到，反过来逆序遍历不就好了，而且只需要遍历完逆序的第一个单词即可结束遍历，实现起来很简单。 代码class Solution &#123; public: int lengthOfLastWord(string s) &#123; int length = 0;//单词长度 for (int i = s.length() - 1; i &gt;= 0; i--) &#123; //只要不是空格单词长度就+1 if (s[i] != &#x27; &#x27;) length++; //遇到空格并且单词长度不为0，则说明最后一个单词遍历完了，此时跳出循环 if (s[i] == &#x27; &#x27; &amp;&amp; length != 0) break; &#125; return length; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 67.二进制求和【C++】","date":"2020-03-07","updated":"2022-03-23","path":"202003076204/","text":"地址：https://leetcode-cn.com/problems/add-binary/ 题目给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例 1: 输入: a = &quot;11&quot;, b = &quot;1&quot; 输出: &quot;100&quot; 示例 2: 输入: a = &quot;1010&quot;, b = &quot;1011&quot; 输出: &quot;10101&quot; 解题思路这个题不可避免的要处理十进制和二进制之间的转换问题，按照二进制求和的方法，从低位到高位依次相加。 定义一个 car 记录进位，默认为 0 即没有进位，有进位只可能为 1 ；定义一个 string 类型的 sum 用以保存得到的和；定义两个int型变量 cur_a 和 cur_b 保存两个字符串相同位置上的字符转为 int 型后的值，方便进行常规加法计算，若字符串为空则作 0 处理，效果等同于没有数与之相加；x 保存某一位上的相加结果，以根据其相加的结果进行进位处理。 因为是二进制加法，x 可能的取值情况仅四种： //前两个数为同一位上的两个数，最后一个数即进位 0 + 0 + 0 = 0 0 + 1 + 0 = 1 1 + 0 + 0 = 1 1 + 1 + 0 = 2 0 + 0 + 1 = 1 0 + 1 + 1 = 2 1 + 0 + 1 = 2 1 + 1 + 1 = 3 当 x 为 0 或 1 时，不需要进位（car为0），x 保持；当 x&gt;1 时，即相加结果为 2 或 3 时，需要进位处理（car为1），为 2 时 x 进 1 取 0，为 3 时 x 进 1 取 1。将整型 x 转为字符串加到 sum 的开头，并将 a、b 字符串的尾字符删去，循环重复上述步骤即可，直到字符串 a、b 均为空并且进位为 0。 代码class Solution &#123; public: string addBinary(string a, string b) &#123; int car = 0;//进位 string sum = &quot;&quot;;//返回值 while (a.length() &gt; 0 || b.length() &gt; 0 || car == 1) &#123; int cur_a = a.length() == 0 ? 0 : a[a.length() - 1] - 48;//末尾字符转为整型，如果为空则为0 int cur_b = b.length() == 0 ? 0 : b[b.length() - 1] - 48; int x = cur_a + cur_b + car;//两末尾字符以及进位相加，x的可能取值有0，1，2，3 car = x &gt; 1 ? 1 : 0;//如果x&gt;1说明有进位，置car为1 if (x &gt; 1) //x&gt;1需要进位处理 x = x &gt; 2 ? 1 : 0;//只可能是2或3，2进1留0，3进1留1 sum = to_string(x) + sum;//将x加到字符串头部 if (a.length() &gt; 0) a.pop_back();//删除已处理的尾字符 if (b.length() &gt; 0) b.pop_back(); &#125; return sum; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 69.x的平方根【C++】","date":"2020-03-07","updated":"2022-03-23","path":"2020030761994/","text":"地址：https://leetcode-cn.com/problems/sqrtx/ 题目实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842...，由于返回类型是整数，小数部分将被舍去。 解题思路采用二分法求解。 平方根一定是 &gt;= 0 的，则 low 取初始值为0；平方根不大于这个数的一半再+1，所以 up 取初始值为 x / 2.0 + 1.0，然后两头向中间逼近。题目要求只保留整数部分，小数部分舍去，所以平方根将最终的 mid 取整。 代码class Solution &#123; public: int mySqrt(int x) &#123; double low = 0;//平方根一定是 &gt;= 0 的 double up = x / 2.0 + 1.0;//平方根不大于这个数的一半再+1 double mid; while (int(low) != int(up)) &#123; mid = (low + up) / 2.0; if (mid * mid &gt; x) up = mid; else if (mid * mid &lt; x) low = mid; else return int(mid); &#125; return int(mid); &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 70.爬楼梯【C++】","date":"2020-03-07","updated":"2022-03-23","path":"2020030738502/","text":"地址： 题目假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 输入：2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 1 阶 示例 2： 输入：3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 解题思路参考官方题解，采用动态规划法。 第 i 阶可以由以下两种方法得到： 在第 (i - 1) 阶后向上爬 1 阶； 在第 (i - 2) 阶后向上爬 2 阶。 所以，只要知道任意相邻的两级台阶的方法数，就可以推算出其后的所有台阶数可以到达的方法总数。即 dp[i] = dp[i - 1] + dp[i - 2] 。而第一级台阶和第二级台阶到达的方法数是显而易见的，所以只需要定义出 dp[1] = 1; dp[2] = 2;，则后续的爬 n 阶楼梯的不同方法就可以通过前述公式计算出来。 代码class Solution &#123; public: int climbStairs(int n) &#123; //一级台阶只有一种方法 if(n == 1) return 1; //动态规划 int* dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题59 - II.队列的最大值【C++】","date":"2020-03-07","updated":"2022-03-23","path":"2020030757743/","text":"地址：https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/ 题目请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数 max_value、push_back 和 pop_front 的时间复杂度都是O(1)。 若队列为空，pop_front 和 max_value 需要返回 -1。 示例 1： 输入: [&quot;MaxQueue&quot;,&quot;push_back&quot;,&quot;push_back&quot;,&quot;max_value&quot;,&quot;pop_front&quot;,&quot;max_value&quot;] [[],[1],[2],[],[],[]] 输出: [null,null,null,2,1,2] 示例 2： 输入: [&quot;MaxQueue&quot;,&quot;pop_front&quot;,&quot;max_value&quot;] [[],[],[]] 输出: [null,-1,-1] 限制： 1 &lt;= push_back, pop_front, max_value的总操作数 &lt;= 10000 1 &lt;= value &lt;= 10^5 解题思路这个题是参考Leetcode的官方题解做的，一开始都没太明白题目意思~ 其实 push_back 和 pop_front 都可以直接用队列的 pop() 函数和 front() 函数，没有难度，但是 max_value 需要考虑的就不一样了，主要是因为题目给了要求时间复杂度是O(1)，也就是说不能用遍历整个队列的方法来找最大值。 题解中用到了双端队列，而双端队列的作用就是查找最大值，并且它的巧妙之处在于，双端队列的队首元素 d.front() 始终是队列 q 中的最大元素。代码中用到的几个关于双端队列的函数如下： back()：获取队列的最后一个元素； empty()：判断队列空否，空则返回true； push_back()：在队列末端插入元素； pop_back()：从队列末端弹出队尾元素； pop_front()：从队列前端弹出队首元素。 定义一个 queue&lt;int&gt; 队列，主要用于元素的入队与出队操作。 在元素入队的函数中，如果双端队列 d 为空或者入队的元素小于 d 的队尾元素，则分别将该元素插入到 d 和 q 的队尾；如果双端队列 d 非空并且入队元素大于 d 的队尾元素，则将 d 的队尾元素逐个弹出，直到 d 的队尾元素大于入队元素或者 d 空，然后将该元素插入到 d 和 q 的队尾。 在队列 q 的出对函数中，需要注意对双端队列 d 的操作，不然可能会造成 q 中已将最大元素删除，但 d 没有进行任何操作，就会导致获取最大值的时候获取到已经删除的不存在于队列中的元素的值。所以需要在 q 和 d 的队首元素相同的情况下，同步删除 d 的队首元素。以保证 d.front() 仍然是队列 q 中剩余元素的最大值。 代码class MaxQueue &#123; private: queue&lt;int&gt; q;//队列 deque&lt;int&gt; d;//双端队列，用于求最大值 public: MaxQueue() &#123;&#125; int max_value() &#123; //d为空也就意味着q为空，因为只要q中有元素，那d.front()就一定是队列q中元素的最大值 if (d.empty()) return -1; return d.front(); &#125; void push_back(int value) &#123; //d要保持单调递减，即为了保持d.front()是最大的元素 while (!d.empty() &amp;&amp; d.back() &lt; value) &#123; d.pop_back(); &#125; d.push_back(value); q.push(value);//原始队列 &#125; int pop_front() &#123; if (q.empty()) return -1; //划重点，此处需要深入理解 if (q.front() == d.front()) d.pop_front();//删除队首元素之后，双端队列d的队首元素仍然是队列q中剩余元素的最大元素 int ans = q.front();//获取返回值 q.pop();//弹出队首元素 return ans;//返回队首元素的值 &#125; &#125;; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-&gt;max_value(); * obj-&gt;push_back(value); * int param_3 = obj-&gt;pop_front(); */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 83.删除排序链表中的重复元素【C++】","date":"2020-03-06","updated":"2022-03-23","path":"2020030653639/","text":"地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 题目给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2 输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3 输出: 1-&gt;2-&gt;3 解题思路就是一个简单的遍历链表的方法，外层循环遍历链表中的每一个结点，内存循环查找这个结点后面的所有结点是否有重复元素，找到重复元素就将其删除。 需要考虑传入的链表为空的特殊情况。 代码/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* deleteDuplicates(ListNode* head) &#123; if (head == NULL) return head; ListNode* cur = head; while (cur-&gt;next != NULL) &#123; ListNode* ptr = cur; while (ptr-&gt;next != NULL) &#123; if (ptr-&gt;next-&gt;val == cur-&gt;val) &#123; ListNode* tmp = ptr-&gt;next; ptr-&gt;next = ptr-&gt;next-&gt;next; tmp-&gt;next = NULL; delete tmp; &#125; else ptr = ptr-&gt;next; &#125; if (cur-&gt;next != NULL) cur = cur-&gt;next; &#125; return head; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 167.两数之和II - 输入有序数组【C++】","date":"2020-03-06","updated":"2022-03-23","path":"2020030634217/","text":"地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 题目给定一个已按照升序排列的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 解题思路二层循环遍历数组找满足条件的两个数，完全遍历整个数组能得到结果，但是会超出时间限制，因为这是一个有序数组，所以当两个数的和大于目标值的的时候，就可以跳出循环不再继续遍历。 代码class Solution &#123; public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; vec; for (int i = 0; i &lt; numbers.size(); i++) &#123; for (int j = i + 1; j &lt; numbers.size(); j++) &#123; if (numbers[i] + numbers[j] == target) &#123; vec.push_back(i + 1); vec.push_back(j + 1); return vec; &#125; if (numbers[i] + numbers[j] &gt; target) break; &#125; &#125; return vec; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 633.平方数之和【C++】","date":"2020-03-06","updated":"2022-03-23","path":"202003064703/","text":"地址：https://leetcode-cn.com/problems/sum-of-square-numbers/ 题目给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3 输出: False 解题思路双指针。设置返回值 ret 默认为 false，分别取最小的数（0）和最大的数，最大的数可以直接使用 sqrt() 函数求目标数的平方根并向下取整，小数的平方与大数的平方求和，若大于目标值，大数减1，继续循环；若小于目标值，小数加1，继续循环；直到与目标值相等（置 ret 为 true）或者小数不再小于大数，跳出循环。返回结果。 代码class Solution &#123; public: bool judgeSquareSum(int c) &#123; bool ret = false; long small = 0; long big = int(sqrt(c)); while (small &lt;= big) &#123; if (big * big &gt; c || small * small + big * big &gt; c) &#123; big--; continue; &#125; else if (small * small + big * big &lt; c) &#123; small++; continue; &#125; else &#123; ret = true; break; &#125; &#125; return ret; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 345.反转字符串中的元音字母【C++】","date":"2020-03-06","updated":"2022-03-23","path":"2020030641619/","text":"地址：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/ 题目编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: &quot;hello&quot; 输出: &quot;holle&quot; 示例 2: 输入: &quot;leetcode&quot; 输出: &quot;leotcede&quot; 说明: 元音字母不包含字母”y”。 解题思路26个英文字母中，21个是辅音字母，5个是元音字母。5个元音字母分别是：a、e、i、o、u。 双指针。分别指向字符串的首尾元素，前指针从前往后查找元音字母，后指针从后往前查找元音字母。 两层循环，第一层即从前往后找元音字母，找到一个元音字母就进入二层循环，从后往前查找元音字母，找到后互换前后两个元音字母，j-- 并跳出二层循环，继续遍历一层循环，直到 i 不再小于 j 即找完了字符串的所有元音字母。 代码class Solution &#123; public: string reverseVowels(string s) &#123; int i = 0; int j = s.length() - 1; while (i &lt; j) &#123; if (isVowel(s[i])) &#123; while (j &gt; i) &#123; if (isVowel(s[j])) &#123; char temp = s[i]; s[i] = s[j]; s[j] = temp; j--; break; &#125; j--; &#125; &#125; i++; &#125; return s; &#125; bool isVowel(char c) &#123; if (c == &#x27;a&#x27; || c == &#x27;e&#x27; || c == &#x27;i&#x27; || c == &#x27;o&#x27; || c == &#x27;u&#x27;|| c == &#x27;A&#x27; || c == &#x27;E&#x27; || c == &#x27;I&#x27; || c == &#x27;O&#x27; || c == &#x27;U&#x27;) return true; return false; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 225.用队列实现栈【C++】","date":"2020-03-06","updated":"2022-03-23","path":"2020030656924/","text":"地址：https://leetcode-cn.com/problems/implement-stack-using-queues/ 题目使用队列实现栈的下列操作： push(x) – 元素 x 入栈 pop() – 移除栈顶元素 top() – 获取栈顶元素 empty() – 返回栈是否为空 注意: 你只能使用队列的基本操作 – 也就是 push to back，peek/pop from front，size 和 is empty 这些操作是合法的。 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。 解题思路使用C++标准模板库queue模板类实现。 q.push(x)：将x插入到队列末端。 q.pop()：弹出队列的第一个元素（不会返回被弹出元素的值）。 q.front()：返回队首元素，即最早被压入队列的元素。 q.empty()：判断队列是否为空，当队列空时，返回true。 插入元素x定义了一个临时队列 temp，然后将x插入到空的 temp 队列中，此时x是队首元素，即栈顶元素，然后将队列q（栈）中的所有元素依次取出并插入到temp队列的末端，此时得到的 temp 队列即将x入栈的得到的队列，然后再用同样的方法将 temp 队列的元素依次弹出并插入回队列q（栈）。 弹出栈顶元素即弹出队首元素，但需要返回弹出的队首元素值，而队列的 pop() 函数不会返回队首元素值，所以需要先定义一个临时 int 变量 temp 通过 front() 函数获取队首元素值，然后再弹出队首元素（即出栈），最后返回 temp 。 代码class MyStack &#123; public: queue&lt;int&gt; q; /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; queue&lt;int&gt; temp; temp.push(x); while(!q.empty())&#123; temp.push(q.front()); q.pop(); &#125; while(!temp.empty())&#123; q.push(temp.front()); temp.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int temp = q.front(); q.pop(); return temp; &#125; /** Get the top element. */ int top() &#123; return q.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return q.empty(); &#125; &#125;; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 206.反转链表【C++】","date":"2020-03-06","updated":"2022-03-23","path":"2020030649994/","text":"地址：https://leetcode-cn.com/problems/reverse-linked-list/ 题目反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 解题思路这个题我的做法很清奇，但是我觉得应该很容易想到这种做法，通过栈，依次读取链表元素压入栈中，然后取出来的时候就是逆序取出的，同样依次从栈中去除所有元素插入到链表中即可得到逆序后的链表。 用到了一个临时存储用的栈，应该有更好的直接修改链表的解法，可以尝试一下~ 代码/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ #include&lt;stack&gt; class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; stack&lt;int&gt; s;//用于临时存储链表元素 ListNode* ptr = head; //将链表元素依次压入栈中 while(ptr!=NULL)&#123; s.push(ptr-&gt;val); ptr = ptr-&gt;next; &#125; //将栈中元素依次取出并写回链表 ptr = head; while(!s.empty())&#123; ptr-&gt;val = s.top(); s.pop(); ptr = ptr-&gt;next; &#125; return head; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题 10.01. 合并排序的数组【C++】","date":"2020-03-06","updated":"2022-03-23","path":"2020030627193/","text":"地址：https://leetcode-cn.com/problems/sorted-merge-lcci/ 题目给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。 初始化 A 和 B 的元素数量分别为 m 和 n。 示例: 输入: A = [1,2,3,0,0,0], m = 3 B = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 解题思路挺蠢的解法，思路是遍历数组B，将数组B中的元素逐个插入到数组A中合适的位置。 将遍历A,B数组用的下表i,j定义在函数作用域内，是因为A,B均为排序后的数组，所以已经查找过的部分就没必要再查找一次了。 第一层循环从数组B中逐个取出元素，在循环体内插入到数组A中，考虑两种情况，第一种情况A，的已排序部分有比B[i]大的数，所以需要进入第二层循环找到第一个比B[i]大的数的位置，将这个数及其后面的已排序的数整体后移一位（第三层循环），然后将B[i]插入到这个位置；第二种情况，B[i]比A中已排序部分的所有数都大，这时候 j == m + i 并且 A[m+i] 一定是等于0的，此时只需将B[i]插入到A的已排序部分的尾部即可。 还有一个思路是直接将数组B整体插入到数组A已排序部分的后面，然后对整个数组A进行一次排序。但我没有采用这个思路，是因为题目已经表明A,B是已排序数组，所以“已排序”这个特性是应该要考虑到的。 代码class Solution &#123; public: void merge(vector&lt;int&gt;&amp; A, int m, vector&lt;int&gt;&amp; B, int n) &#123; //分别作为两个数组的下标 int i = 0; int j = 0; //遍历数组B for (i; i &lt; n; i++) &#123; //遍历数组A for (j; j &lt; m + i; j++) &#123; //将B[i]插入到A中合适的位置 if (B[i] &lt; A[j]) &#123; for (int k = m + i; k &gt; j; k--) &#123; A[k] = A[k - 1]; &#125; A[j] = B[i]; break; &#125; &#125; //B[i]比A中现有的所有数都大，将B[i]插入到A的末尾 if (j == m + i &amp;&amp; A[m + i] == 0) &#123; A[m + i] = B[i]; &#125; &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 面试题57 - II.和为s的连续正数序列【C++】","date":"2020-03-06","updated":"2022-03-23","path":"202003065179/","text":"地址：https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/ 题目输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 示例 1： 输入：target = 9 输出：[[2,3,4],[4,5]] 示例 2： 输入：target = 15 输出：[[1,2,3,4,5],[4,5,6],[7,8]] 限制： 1 &lt;= target &lt;= 10^5 解题思路首先很容易想到一点，最大可能取到的数是 target/2 + 1 ，例如对 target == 5 而言，最大只可能取到 5/2 +1 = 3 ，若取到4，由于题目要求是连续正整数，那么就必须取到3或者5，此时 3 + 4 = 7 已经大于目标值5。 这个题按照人的思维还是很容易想到的，就是从第一个正整数1开始往后依次相加，如果相加之后的和sum小于目标值，那就继续加后一个正整数，如果sum大于目标值，就减去序列最小的数，直到 sum == target 即找到了一组符合题目要求的连续正整数。 转化为编程思想，我首先想到了用队列queue来存储一串连续的正整数。队列中的数的和小于目标值，就将后一个正整数加入队列；如果大于目标值，就将队首的最小数弹出；直到队列中的数的和等于目标值target，此时逐个取出队列中的数即为一组符合题意的连续正整数。但是，使用队列只能很方便的用于找到一组这样的数，如果我们要继续找第二组，那就要让第一组数中从第二个数开始的所有数重新加入队列，这是很不划算的~ 所以，还是用 vector&lt;int&gt;，与队列同样的步骤，但不需要每次找到一组连续整数后都重新将那些数加入到数组，每找到一个只需要利用 push_back() 函数，仅一条语句就可以将这个 vector&lt;int&gt; 加入到 vector&lt;vector&lt;int&gt;&gt; 的返回值中，然后就可以继续使用这个vector&lt;int&gt; 查找下一组满足题目要求的连续整数。 代码class Solution &#123; public: vector&lt;vector&lt;int&gt;&gt; findContinuousSequence(int target) &#123; vector&lt;vector&lt;int&gt;&gt; ans;//返回值 vector&lt;int&gt; consecutive;//存储连续的数 int sum = 0;//一串连续的数的和 //最大可能取到的值是target/2+1 //但当最后加上这个最大可能取到的数后，i也会++，所以应使 i &lt;= target/2+2 for (int i = 1; i &lt;= target / 2 + 2;) &#123; if (sum &lt; target) &#123; sum += i; consecutive.push_back(i);//将i加到一串连续的数的末尾 i++;//取下一个整数 &#125; else if (sum == target) &#123; ans.push_back(consecutive); sum -= consecutive[0];//减掉序列中最小的数 consecutive.erase(consecutive.begin());//删去序列中最小的数 &#125; else &#123; sum -= consecutive[0];//减掉序列中最小的数 consecutive.erase(consecutive.begin());//删除第一个元素（最小的数） &#125; &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 994.腐烂的橘子【C++】","date":"2020-03-05","updated":"2022-03-23","path":"2020030518450/","text":"地址：https://leetcode-cn.com/problems/rotting-oranges/ 题目在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格；值 1 代表新鲜橘子；值 2 代表腐烂的橘子。每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 输入：[[2,1,1],[1,1,0],[0,1,1]] 输出：4 示例 2： 输入：[[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。 示例 3： 输入：[[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1 &lt;= grid.length &lt;= 10 1 &lt;= grid[0].length &lt;= 10 grid[i][j] 仅为 0、1 或 2 解题思路（1）笨办法，先记录一下吧😅（内存消耗 :15.2 MB, 在所有 C++ 提交中击败了5.40%的用户） 我不确定有没有不用模拟橘子被感染的办法，如果有的话我觉得应该会更好一些。我一上来想到的就是模拟橘子被感染的整个过程，所以需要逐个橘子判断它的当前状态，然后判断它的上下左右的橘子的状态，如果存在需要感染的情况就修改某个橘子的状态。 我定义了一个同样大小的二维数组用来作为状态记录表(这里是主要占用内存的地方)，初始化为全0，其中的整数即表示分钟数 另外定义了一个函数用于判断橘子是否全部腐烂，或者还有橘子可以被感染，或是存在不可能被感染的橘子。 代码class Solution &#123; public: int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int minute = 0; size_t rows = grid.size();//行数 size_t cols = grid[0].size();//列数 vector&lt;int&gt; temp(cols);//仅用于初始化状态记录表 vector&lt;vector&lt;int&gt;&gt; record(rows, temp);//状态记录表，初始化为全0，数字0，1，2表示第0，1，2步 //模拟橘子随时间被感染 while (isInfectionOver(grid) == 1) &#123; minute++;//分钟数+1 //同步遍历橘子网格与状态记录表 for (size_t i = 0; i &lt; rows; i++) &#123; for (size_t j = 0; j &lt; cols; j++) &#123; if (grid[i][j] == 2 &amp;&amp; record[i][j] &lt; minute) &#123; record[i][j] = minute; //感染上侧橘子 if (i &gt; 0 &amp;&amp; grid[i - 1][j] == 1) &#123; grid[i - 1][j] = 2; record[i - 1][j] = minute; &#125; //感染下侧橘子 if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] == 1) &#123; grid[i + 1][j] = 2; record[i + 1][j] = minute; &#125; //感染左侧橘子 if (j &gt; 0 &amp;&amp; grid[i][j - 1] == 1) &#123; grid[i][j - 1] = 2; record[i][j - 1] = minute; &#125; //感染右侧橘子 if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] == 1) &#123; grid[i][j + 1] = 2; record[i][j + 1] = minute; &#125; &#125; &#125; &#125; &#125; return isInfectionOver(grid) == 2 ? -1 : minute; &#125; //是否感染结束，可能的返回值为0，1，2 //0表示所有橘子都已腐烂；1表示仍存在可以被感染的橘子；2表示存在不可能被感染的橘子 int isInfectionOver(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int ret = 0;//作为返回值 size_t rows = grid.size();//行数 size_t cols = grid[0].size();//列数 for (size_t i = 0; i &lt; grid.size(); i++) &#123; for (size_t j = 0; j &lt; grid[i].size(); j++) &#123; //只需判断表中的新鲜橘子是否可能被感染 if (grid[i][j] == 1) &#123; ret = 2;//此处默认这个橘子不可能被感染 //上侧有腐烂橘子 if (i &gt; 0 &amp;&amp; grid[i - 1][j] == 2) return 1; //下侧有腐烂橘子 if (i &lt; rows - 1 &amp;&amp; grid[i + 1][j] == 2) return 1; //左侧有腐烂橘子 if (j &gt; 0 &amp;&amp; grid[i][j - 1] == 2) return 1; //右侧有腐烂橘子 if (j &lt; cols - 1 &amp;&amp; grid[i][j + 1] == 2) return 1; &#125; &#125; &#125; return ret; &#125; &#125;; 解题思路（2）其实不是我自己想出来的这个解法~这是我自己用上面的思路解出来后，本来想自己优化一下上面的代码，结果改来改去反而不能正常运行了……然后我才去看了别人的题解，其中看了这个，思路比较简单，然后我觉得有些地方挺有亮点的，所以就自己复现了一遍。 将腐烂的橘子和新鲜橘子分了两类，腐烂的橘子用一个 queue&lt;pair&lt;int, int&gt;&gt; 类型的队列存储坐标，新鲜橘子只统计其个数。需要记录每分钟橘子开始腐烂前的腐烂的橘子的个数 n ，即处理完这n个腐烂的橘子分钟数才+1，逐个判断队列头的腐烂橘子周围是否有新鲜橘子需要感染，如果有就将这个新鲜橘子置为 2 即这个橘子已腐烂，将新腐烂的橘子的坐标加入到队列，并将新鲜橘子的个数-1。此外，还需要注意某一分钟内的n个腐烂橘子是否真的有感染周围的新鲜橘子，如果并没有感染任何新鲜橘子，那么分钟数是不应该增加的。直到所有的队列中的腐烂橘子处理完毕，跳出循环，此时如果新鲜橘子个数为0，即所有橘子均已腐烂，返回分钟数；若剩余新鲜橘子个数大于0，则说明存在不可能被感染的橘子，此时返回 -1。 几个值得学习的亮点： 用 pair&lt;int, int&gt; 来记录二维数组的横纵坐标。真的很方便，简直量身定做吖； 用队列了处理腐烂的橘子。已处理过的橘子只需从队列头弹出，完美避免重复工作； 用 vector&lt;pair&lt;int, int&gt;&gt; around = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;; 来对 grid[i][j] 上下左右相邻的位置进行处理。很巧妙的办法，因为 grid[i][j] 的横纵坐标 &#123;i,j&#125; 分别加上 &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; 后即为上下左右相邻四个位置的横纵坐标，只需写一个循环即可处理四种情况，而不用对四种情况进行单独判断（比如解题思路（1）中我的代码😅）。 代码class Solution &#123; public: int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; queue&lt;pair&lt;int, int&gt;&gt; rottenQueue;//保存腐烂橘子坐标的队列 int fresh = 0;//剩余新鲜橘子的个数 //统计 for (size_t i = 0; i &lt; grid.size(); i++) &#123; for (size_t j = 0; j &lt; grid[0].size(); j++) &#123; if (grid[i][j] == 2) rottenQueue.push(&#123; i, j &#125;); if (grid[i][j] == 1) fresh++; &#125; &#125; int minute = 0;//分钟数 vector&lt;pair&lt;int, int&gt;&gt; around = &#123; &#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125; &#125;;//+&#123;i,j&#125;后分别是上下左右 while (!rottenQueue.empty()) &#123; int n = rottenQueue.size();//当前队列中的腐烂橘子个数，处理完这n个橘子分钟数才+1 bool rotten = false; for (int i = 0; i &lt; n; i++) &#123; //从队列头取出一个腐烂橘子 auto rot = rottenQueue.front(); for (auto side : around) &#123; int i = rot.first + side.first; int j = rot.second + side.second; if (i &gt;= 0 &amp;&amp; i &lt; grid.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].size() &amp;&amp; grid[i][j] == 1) &#123; grid[i][j] = 2;//这个橘子会腐烂 rottenQueue.push(&#123; i,j &#125;);//将新腐烂的橘子加入队列 fresh--;//新鲜橘子减少一个 rotten = true;//当前橘子腐烂了周围的橘子 &#125; &#125; rottenQueue.pop();//已处理过的腐烂橘子无需再处理 &#125; if (rotten == true) &#123; minute++;//分钟数+1 &#125; &#125; return fresh == 0 ? minute : -1; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"Leetcode 1103.分糖果II【C++】","date":"2020-03-05","updated":"2022-03-23","path":"2020030545178/","text":"地址：https://leetcode-cn.com/problems/distribute-candies-to-people/ 题目排排坐，分糖果。 我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。 给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。 然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。 重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。 返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。 示例 1： 输入：candies = 7, num_people = 4 输出：[1,2,3,1] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0,0]。 第三次，ans[2] += 3，数组变为 [1,2,3,0]。 第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。 示例 2： 输入：candies = 10, num_people = 3 输出：[5,2,3] 解释： 第一次，ans[0] += 1，数组变为 [1,0,0]。 第二次，ans[1] += 2，数组变为 [1,2,0]。 第三次，ans[2] += 3，数组变为 [1,2,3]。 第四次，ans[0] += 4，最终数组变为 [5,2,3]。 提示： 1 &lt;= candies &lt;= 10^9 1 &lt;= num_people &lt;= 1000 解题思路定义一个数组（初始化为全0）用于记录每个小朋友分到的糖果数，定义一个整型count用于计数当前应该分给小朋友多少个糖果。 每一次分糖果后总的糖果数减掉分发掉的糖果数，即为剩下的总糖果数，所以外层循环当糖果数**candies == 0**时退出循环。内层循环遍历每一个小朋友模拟分发糖果的真实情况，如果剩余的糖果数足够，就直接将应分发的count个糖果分发给ans[i]小朋友，即这个小朋友的糖果数+count，并且总的糖果数要减掉已分发出去的count，计数count++即应该分给下一个小朋友的糖果数；如果剩余的糖果数不足，则把剩下的所有糖果都分给这个小朋友，并将剩下的糖果数count置为0以跳出外层循环。 代码class Solution &#123; public: vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123; vector&lt;int&gt; ans(num_people); int count = 1;//当前应分发的糖果数 while (candies != 0) &#123; for (int i = 0; i &lt; num_people; i++) &#123; //糖果数目已不足够，剩下的全部糖果都分给这个小朋友 if (candies &lt; count) &#123; ans[i] += candies; candies = 0; &#125; //糖果数目足够 else &#123; ans[i] += count; candies -= count; count++; &#125; &#125; &#125; return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"}]},{"title":"博客搭建一周年ᓚᘏᗢ","date":"2020-01-17","updated":"2022-03-23","path":"2020011755548/","text":"哈哈哈，博客搭建一周年，小纪念一下吧~ 搭了博客才发现，坚持写可太难了，而且写一篇博客可不简单啊，要自己动手做一遍，然后把整个过程写下来，也许还要贴一些图片，实在是不简单，不过好歹也算是做了件有那么些意义的事，虽然这一年里并没有多大的产量，但零零散散写了一些总好过没有吧，哈哈哈O(∩_∩)O 新的一年，加油(ง •_•)ง 2020年1月17日","categories":[],"tags":[]},{"title":"Leetcode 删除排序数组中的重复项","date":"2019-08-15","updated":"2022-03-23","path":"2019081564979/","text":"地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 题目给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i &lt; len; i++) &#123; print(nums[i]); &#125; 我的解决方案：题目给出了一个很重要的信息“排序”，千万不能遗漏，否则会耗费过多的时间用来遍历整个数组。 易错点：一般情况下会想到用两个 for 循环来做，外层循环遍历第一个到倒数第二个元素，内层循环遍历从外层循环当前遍历到的的下一个元素开始找出与当前元素值相同的元素并删去，大致逻辑如下： for i in range(0, len(nums) - 1): for j in range(i + 1, len(nums)): if nums[i] == nums[j]: nums.pop(j) 看似逻辑没问题的，但是我们在内部删除了列表 nums[] 的元素之后，列表长度 len(nums) 就已经改变了，而 range() 函数的不会动态的根据 len(nums) 改变它的范围，最终就会导致删除元素后列表长度已经改变但是for语句不知道，超范围后仍然进入循环内部，当访问到 nums[j] 是已经超出列表索引范围。 正解：要解决上述问题，不难想到改用while循环，并且只需要一个循环即可，代码如下： class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i = 0 # 作为索引遍历列表元素 while i &lt; len(nums) - 1: # 最多只遍历到倒数第二个元素 if nums[i] == nums[i + 1]: # 这就是问什么只遍历到倒数第二个元素的原因，因为始终要和下一个元素作比较 nums.pop(i + 1) continue # i保持不变，继续判断nums[i]和补位上来的nums[i + 1]是否相等 i += 1 return len(nums) while语句中的 len(nums) 是动态更新的，这就解决了索引超出范围的问题； continue 很重要，它解决了数组中有多个重复项的问题。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"},{"name":"python","slug":"python","permalink":"https://mxy493.xyz/tags/python/"}]},{"title":"Ubuntu上自定义Code::Blocks工作区颜色主题","date":"2019-05-25","updated":"2022-03-23","path":"2019052565269/","text":"本文主要针对 Ubuntu 系统，理论上任何系统上也都是通用的。网上关于设置 Code::Blocks 主题的教程很多，但是都是在 Windows 系统环境下，并不适用于 Linux 系统。 可能大家都知道 Code::Blocks 的工作区主题是可以自定义的，路径 Settings —&gt; Editor —&gt; Syntax highlighting ，在这里就可以设置你想要的代码以及背景颜色，如图： 可以注意到顶部的 Colour theme 即颜色主题，然而后面的选项里默认只有一个 default 的主题，事实上尽管官方没有提供更多的主题，但是还是有大神做好了一系列的主题分享在网上。 主题样式请参看：Syntax highlighting custom colour themes 另外需要注意的是，这些主题仅适用于 C/C++ 语言！ 建议备份所有要修改的文件以防出错～ 网上的教程大概就是用这份主题的代码替换 Code::Blocks 原本的 default.conf 文件，虽然说确实是可行的，替换之后主题都能正常使用，但是实测发现，替换之后 Code::Blocks 不能保存设置了，每次重新启动都会使用默认的设置，比如说 Ubuntu 系统上我更改了设置使用 Gnome Terminal ，替换 default.conf 后每次重启 Code::Blocks 都会是默认的 xterm ，这就很影响使用体验了。 显然的 Code::Blocks 的主题颜色代码在 default.conf 中，所以我们可以找到对应的关于颜色的设置，只更改颜色相关的设置，就能完美的解决这个问题。 找到 default.conf 文件所在位置，Ubuntu 系统中它在主目录下 /.config/codeblocks 文件夹中 ，默认是隐藏起来的，可以通过快捷键 Ctrl + H 或者文件管理器右上角设置中显示隐藏文件。 用任意文本编辑器打开 default.conf ，看一下代码的结构，可以知道这个文件不仅是关于主体颜色的设置，还包括了其它的各项设置，我们直入主题找到关于颜色主题的代码段，如图所示位置： 所以我们把对应的颜色主题代码复制过来放在 default 主题前后即可，以 dark grey 主题为例，在主题代码中找到 dark grey 的代码片段，如图： 其它主题同样，都是类似的代码块： &lt;dark_grey&gt; ...... &lt;/ dark_grey&gt; 可以随意添加其中一部分或者添加所有主题，复制到 default.conf 文件中与 default 主题并列的位置，保存即可！ 打开 Code::Blocks ，在设置中修改颜色主题选择自己添加的主题即可，设置之后 Code::Blocks 会保存当前设置，以后打开也会保持设置过的主题！","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://mxy493.xyz/tags/Ubuntu/"},{"name":"CodeBlocks","slug":"CodeBlocks","permalink":"https://mxy493.xyz/tags/CodeBlocks/"}]},{"title":"Hexo博客使用插件hexo-git-backup通过GitHub备份与恢复","date":"2019-05-25","updated":"2022-03-23","path":"2019052557154/","text":"好久没更新过博客了，现在用的这台电脑是前些天刚装的Ubuntu系统，今天打算把博客迁移过来，折腾了好一会儿，所以准备写一篇关于Hexo博客的备份与恢复的。 用的是一个插件：hexo-git-backup，Hexo官网的插件里搜不到，这个插件发布在了GitHub上，关于安装使用官方也给了很简洁易懂的说明文档。 备份安装插件如果你的Hexo版本是2.x.x（查看Hexo版本可使用命令：hexo version）在终端中使用如下命令安装： $ npm install hexo-git-backup@0.0.91 --save 如果你的Hexo版本是3.x.x则使用如下命令安装： $ npm install hexo-git-backup --save 插件升级如果你是通过 --save安装的，那么升级之前你必须先删除旧的版本： $ npm remove hexo-git-backup $ npm install hexo-git-backup --save 新建GitHub仓库新建一个 GitHub 仓库用来备份博客（具体操作不再赘述） 复制仓库ＳＳＨ链接备用，此处需确保你的电脑已通过SSH连接到 GitHub ，具体操作可参考 GitHub 官方帮助文档。 插件配置在博客根目录下的 _config.yml 文件中配置插件： backup: type: git repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 配置说明：如果你想连同主题一起备份，在 _config.yml 文件中添加主题名即可： backup: type: git theme: coney,landscape,xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 注意：如果你选择了备份主题例如landscape，那么landscape主题文件夹下的 themes/landscape/.git 文件就会被删除 如果你想自定义 commit 信息，添加一行 message: update xxx 即可： backup: type: git message: update xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 插件使用现在就可以使用以下命令备份你的博客到GitHub了 $ hexo backup 或者 $ hexo b 博客备份至此就已经结束！安全起见可以每次 hexo d 的时候同步 hexo b 备份一下博文。 恢复有时候换了另一台电脑或者另一个系统环境下，想要写博客就不得不把博客文件迁移过去，这一部分是关于博客的迁移，接上文使用 hexo-git-backup 插件的情况下（其他方法备份的博客原理类似）。 安装Hexo根据 Hexo 官网说明安装 Hexo 即可 附上官网地址：https://hexo.io/zh-cn/ 要部署博客到 GitHub 还需要安装插件： $ npm install --save hexo-deployer-git 恢复博客下载或者 clone 前文所述备份的博客到本地任意位置，复制备份文件夹内所有文件到新安装的博客目录下，重复文件保留备份的即可。 至此博客迁移已完成，可以”三部曲“测试一下是否迁移成功： $ hexo clean $ hexo g $ hexo s","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Connecting to GitHub with SSH","date":"2019-04-12","updated":"2022-03-23","path":"2019041221240/","text":"通过SSH连接到GitHub 整理自GitHub官方帮助文档：https://help.github.com/articles/connecting-to-github-with-ssh 一、关于SSH使用SSH协议，您可以连接和验证远程服务器和服务。通过使用SSH密钥，您可以在每次访问GitHub时无需提供用户名或密码。 设置SSH时，您将生成SSH密钥并将其添加到ssh-agent，然后将密钥添加到您的GitHub帐户。将SSH密钥添加到ssh-agent可确保您的SSH密钥通过使用密码短语拥有更多一层的安全。有关更多信息，请参阅“ Working with SSH key passphrases”。 建议定期查看SSH密钥列表，并废除无效或已被盗用的密钥。 如果您的SSH密钥未使用超过一年，那么GitHub将自动删除您不活跃的SSH密钥以确保安全。有关更多信息，请参阅“Deleted or missing SSH keys”。 二、检查现有的SSH密钥本文仅介绍Windows系统的相关操作 Mac或Linux请参考官方帮助文档：https://help.github.com/en/articles/checking-for-existing-ssh-keys 在生成SSH密钥之前，您可以检查是否本地已存在SSH密钥。 注意：在OpenSSH 7.0中不推荐使用DSA密钥。如果您的操作系统使用OpenSSH，则在设置SSH时需要使用RSA密钥或其他类型类型的密钥。例如，如果您的操作系统是MacOS Sierra，则可以使用RSA密钥设置SSH。 1.打开终端Git Bash。 2.输入ls -al ~/.ssh查看是否系统中已存在SSH密钥： $ ls -al ~/.ssh # Lists the files in your .ssh directory, if they exist 3.查看您的列表中是否已存在公共SSH密钥。 默认情况下，公钥的文件名是以下之一： id_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub 如果您的系统中不存在公钥和私钥对，或者没有任何可用的密钥可以连接到GitHub，那么你可以生成新的SSH密钥。 如果列表中存在用于连接到GitHub 的现有公钥和私钥对（例如id_rsa.pub和id_rsa），则可以将SSH密钥添加到ssh-agent。 提示：如果终端返回〜/ .ssh不存在的错误，不用担心！我们将在生成新的SSH密钥时创建它。 三、生成新的SSH密钥并将其添加到ssh-agent本文仅介绍Windows系统的相关操作 Mac或Linux请参考官方帮助文档：https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent 检查现有SSH密钥后，可以生成用于身份验证的新的SSH密钥并将其添加到ssh-agent。 如果您还没有SSH密钥，则必须生成新的SSH密钥。如果您不确定是否已有SSH密钥，请检查现有密钥。 如果您不想在每次使用SSH密钥时重新输入密码，则可以将密钥添加到SSH agent，SSH agent会管理您的SSH密钥并记住您的密码。 生成新的SSH密钥 注意：如果您还没有SSH密钥，则必须生成新的SSH密钥。否则直接跳到下一步将现有的SSH密钥添加到ssh-agent中。 1.打开Git Bash. 2.粘贴下面的文本，用您的GitHub邮箱地址替换双引号中的内容。 $ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 这将使用您提供的电子邮件作为标记创建一个新的ssh密钥。 &gt; Generating public/private rsa key pair. 3.当系统提示您 “Enter a file in which to save the key” 时，按Enter键。密钥将保存在默认的路径下。 &gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter] 4.根据提示，您需要输入密码。更多信息请查看“Working with SSH key passphrases”。 &gt; Enter passphrase (empty for no passphrase): [Type a passphrase] &gt; Enter same passphrase again: [Type passphrase again] 将SSH密钥添加到ssh-agent在将新的SSH密钥添加到ssh-agent以管理密钥之前，您应该检查现有的SSH密钥并生成新的SSH密钥。 如果安装了GitHub Desktop，则可以使用它来克隆存储库而不处理SSH密钥。它还附带了Git Bash工具，这是git在Windows 上运行命令的首选方式。 1.确保ssh-agent正在运行： 如果您使用的Git Shell是随着GitHub Desktop一起安装的，那么ssh-agent应该在运行中。 如果您使用的时其它命令提示符终端，例如Git for Windows，则可以使用“Working with SSH key passphrases”中所说的“Auto-launching the ssh-agent”，或者通过以下命令手动启动： # start the ssh-agent in the background $ eval $(ssh-agent -s) &gt; Agent pid 59566 2.将SSH私钥添加到ssh-agent。如果您使用了其他名称创建密钥，或者要添加不同名称的已有的密钥，请将如下命令中的id_rsa替换为您的私钥文件的名称。 $ ssh-add ~/.ssh/id_rsa 3.将SSH密钥添加到您的GitHub帐户。 四、添加一个新的SSH密钥到您的GitHub帐户要配置您的GitHub帐户使用新的（或现有的）SSH密钥，还需要将其添加到GitHub帐户中。 在向GitHub帐户添加新的SSH密钥之前，您应该已经做了一下两步： 检查现有SSH密钥 生成新的SSH密钥并将其添加到ssh-agent 在您的GitHub帐户中添加新的SSH密钥后，您可以重新配置所有的本地存储库以使用SSH。更多信息，请参阅“Switching remote URLs from HTTPS to SSH”。 注意：在OpenSSH 7.0中不推荐使用DSA密钥。如果您的操作系统使用OpenSSH，则在设置SSH时需要使用RSA密钥或其他类型类型的密钥。例如，如果您的操作系统是MacOS Sierra，则可以使用RSA密钥设置SSH。 1.将SSH密钥复制到剪贴板。 如果您的SSH密钥文件的名称与示例代码不同，请根据您的文件名修改以下命令并执行。复制密钥时，请勿添加任何换行符或空格。 $ clip &lt; ~/.ssh/id_rsa.pub # Copies the contents of the id_rsa.pub file to your clipboard 提示：如果clip不起作用，您可以找到隐藏的.ssh文件夹，用文本编辑器打开密钥文件，然后将其中的内容复制到剪贴板。 2.在GitHub任意页面的右上角，单击您的头像，然后单击“Settings”。 3.在用户设置侧栏中，单击SSH and GPG keys。 4.单击“New SSH key”或“ Add SSH key”。 5.在“Title”文本框中，为新密钥添加描述性标签。例如，如果您使用的是个人Mac，则可以将此键称为“Personal MacBook Air”。 6.将您的密钥粘贴到“Key”对应得文本框。 7.单击“Add SSH key”。 8.如果出现提示，请输入您的GitHub密码以确认。 五、测试SSH连接本文仅介绍Windows系统的相关操作 Mac或Linux请参考官方帮助文档：https://help.github.com/en/articles/testing-your-ssh-connection 在设置SSH密钥并将其添加到GitHub帐户后，您可以测试您的连接。 在测试SSH连接之前，您应该已经做了以下几步： 检查现有SSH密钥 生成新的SSH密钥 为您的GitHub帐户添加了新的SSH密钥 测试连接时，您需要使用您之前创建SSH密钥时的密码验证此操作。有关使用SSH密钥密码的更多信息，请参阅“Working with SSH key passphrases”。 1.打开Git Bash。 2.输入以下内容： $ ssh -T git@github.com # Attempts to ssh to GitHub 您可能会看到如下提示信息： &gt; The authenticity of host &#x27;github.com (IP ADDRESS)&#x27; can&#x27;t be established. &gt; RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. &gt; Are you sure you want to continue connecting (yes/no)? 或者像这样： &gt; The authenticity of host &#x27;github.com (IP ADDRESS)&#x27; can&#x27;t be established. &gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. &gt; Are you sure you want to continue connecting (yes/no)? 3.验证您看到的信息中的编码是否与步骤2中的某条信息匹配，然后输入yes： &gt; Hi username! You&#x27;ve successfully authenticated, but GitHub does not &gt; provide shell access. 4.验证生成的消息是否包含您的用户名。如果返回“permission denied”，请参阅“Error: Permission denied (publickey)”。 六、使用SSH密钥密码您可以加密SSH密钥并配置身份验证代理，这样您就不必在每次使用SSH密钥时重新输入密码。 使用SSH密钥，如果有人获得对您计算机的访问权限，他们也可以访问使用该密钥的每个系统。要添加额外的安全层，可以对SSH密钥添加密码。您可以使用ssh-agent来安全地保存您的密码，这样您就不必重新输入密码。 添加或更改密码您可以通过键入以下命令来更改现有私钥的密码，而无需重新生成密钥对： $ ssh-keygen -p # Start the SSH key creation process &gt; Enter file in which the key is (/Users/you/.ssh/id_rsa): [Hit enter] &gt; Key has comment &#x27;/Users/you/.ssh/id_rsa&#x27; &gt; Enter new passphrase (empty for no passphrase): [Type new passphrase] &gt; Enter same passphrase again: [One more time for luck] &gt; Your identification has been saved with the new passphrase. 如果您的SSH密钥已有密码，系统会提示您输入原密码，验证后才能更改为新密码。 在Git for Windows上自动启动ssh-agent如果您使用的是与GitHub Desktop一起安装的Git Shell，则无需执行以下步骤。GitHub Desktop会自动为您启动ssh-agent。 否则，请按照以下步骤在打开bash或Git shell时自动运行ssh-agent。复制下面的内容，并通过Git Shell将其粘贴到您的~/.profile或~/.bashrc文件： env=~/.ssh/agent.env agent_load_env () &#123; test -f &quot;$env&quot; &amp;&amp; . &quot;$env&quot; &gt;| /dev/null ; &#125; agent_start () &#123; (umask 077; ssh-agent &gt;| &quot;$env&quot;) . &quot;$env&quot; &gt;| /dev/null ; &#125; agent_load_env # agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running agent_run_state=$(ssh-add -l &gt;| /dev/null 2&gt;&amp;1; echo $?) if [ ! &quot;$SSH_AUTH_SOCK&quot; ] || [ $agent_run_state = 2 ]; then agent_start ssh-add elif [ &quot;$SSH_AUTH_SOCK&quot; ] &amp;&amp; [ $agent_run_state = 1 ]; then ssh-add fi unset env 如果您的私钥没有存储在默认位置（~/.ssh/id_rsa或~/.ssh/id_dsa），那么您需要告知您的SSH身份验证代理在哪里找到它。要将你的SSH密钥添加到ssh-agent，请键入ssh-add ~/path/to/my_key。更多信息，请参阅“Generating a new SSH key and adding it to the ssh-agent” 提示：如果您想ssh-agent在一段时间后忘记密钥，可以通过键入命令ssh-add -t &lt;seconds&gt;进行设置。 现在，当您第一次运行Git Bash时，系统会提示您输入密码： &gt; Initializing new SSH agent... &gt; succeeded &gt; Enter passphrase for /c/Users/you/.ssh/id_rsa: &gt; Identity added: /c/Users/you/.ssh/id_rsa (/c/Users/you/.ssh/id_rsa) &gt; Welcome to Git (version 1.6.0.2-preview20080923) &gt; &gt; Run &#x27;git help git&#x27; to display the help index. &gt; Run &#x27;git help &#x27; to display help for specific commands. ssh-agent进程将持续运行，直到您注销，关闭计算机或终止这个进程。","categories":[],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://mxy493.xyz/tags/GitHub/"}]},{"title":"Ubuntu通过Deepin wine for Ubuntu安装QQ、微信","date":"2019-04-09","updated":"2022-03-23","path":"2019040956137/","text":"Deepin wine for Ubuntu 是 Deepin-wine 环境的 Ubuntu 移植版，GitHub上的一个开源项目。 项目地址：https://github.com/wszqkzqk/deepin-wine-ubuntu 以下内容主要参考项目说明。 下载 克隆 (git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.git) 或下载到本地。 在中国推荐用下面的地址，速度更快： (git clone https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu.git) 当然也可以选择下载releases：Github 或者 Gitee 安装下载到本地后（下载的压缩包需要先解压）进入到文件夹根目录，在终端中运行（授予可执行权限后）： sudo sh ./install.sh （ KDE或其他按照普通安装方式安装后运行出现X错误的桌面环境执行：./KDE-install.sh ）。 安装应用容器以项目内容为准，以下仅搬运自项目说明文档 Ubuntu 环境下下载对应应用的 .deb 格式安装包，终端进入到包所在路径执行命令： sudo dpkg -i [软件包名.deb] QQ TIM QQ轻聊版 微信 Deepin wine for Ubuntu 只是一种环境，所以可以安装的应用不限于QQ、微信~","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://mxy493.xyz/tags/Linux/"},{"name":"软件","slug":"软件","permalink":"https://mxy493.xyz/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Ubuntu安装WPS（解决字体缺失问题）","date":"2019-04-08","updated":"2022-03-23","path":"2019040840601/","text":"下载WPSWPS for Linux官网：http://www.wps.cn/product/wpslinux/ 安装双击安装或者命令行安装 sudo dpkg -i ***/wps-office_10.1.0.6757_amd64.deb 字体缺失安装后如果有字体缺失问题 下载：wps_symbol_fonts.zip 将下载好的字体压缩包移至 /usr/share/fonts 文件夹下 sudo mv wps_symbol_fonts.zip /usr/share/fonts 终端进入到 /usr/share/fonts 文件夹 cd /usr/share/fonts 解压缩（解压缩后可以把压缩包删了） sudo unzip wps_symbol_fonts.zip sudo rm wps_symbol_fonts.zip 执行命令生成字体的索引信息： sudo mkfontscale sudo mkfontdir 运行fc-cache命令更新字体缓存： sudo fc-cache","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://mxy493.xyz/tags/Linux/"},{"name":"软件","slug":"软件","permalink":"https://mxy493.xyz/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"Windows平台使用Doxygen+GraphViz生成函数调用关系图","date":"2019-03-25","updated":"2022-03-23","path":"2019032530847/","text":"​ 刚做了数据结构课程设计，报告要求给出函数调用关系图，然后就想有没有自动生成的工具，所以上网搜了下，总结下搜到的内容大概三类：一是用VS的 code maps ，但是前提是必须是专业版或者企业版，社区版无法安装这个组件；第二个是用 CodeViz 和 Graphviz 实现的，具体怎么操作我也没试过了；然后就是我现在要说的，也是网上比较多的一种方案，用 Doxygen + GraphViz 自动生成。 下载如题所述，需要用到两个软件： Doxygen ：http://www.doxygen.nl/ 【下载】 GraphViz ：http://www.graphviz.org/【下载】 点击【下载】可以直接下载官方的安装包 安装安装步骤很简单，除了安装路径可以自己改一下，其它默认就行，一路 next 下去就安装好了 配置主要是配置Doxygen，GraphViz安装好放那儿就行了 运行Doxywizard，界面如图： 1.工作目录需要设置一下，随便设一个空文件夹就可以，项目名称是你项目的名称，其实写什么不重要，最后生成的是一个HTML的网页，项目名称就是这个网页的名字，源码地址必须要设置正确，也就是程序代码的文件夹路径，递进扫描勾选上没坏处吧，然后自己输出路径选一个位置保存，设置完点击右下角 Next 2.如图勾选上就行，Next 3.默认就可以，红框的选项对生成的函数调用图没什么影响，Change color... 可以更改颜色，下面PDF相关的，默认所有的图片都会生成一个PDF文件，继续 Next 4.这一步很重要，这就使用到我们安装的 GraphViz 了，如图勾选上，继续 Next 5.上一个点击 Next 后实际上直接跳到了 Run 标签页，但是还要进行一些设置，所以点击左侧的 Expert 标签，Topics 列表中第一项 Project ，如图，默认为English，可以修改为 Chinese ，但是这一步的语言并不影响生成的函数调用图，只是最后生成的网页为中文 6.左侧选择 Build ，如图将右侧前面几项勾选上 7.左侧往下滑找到 Dot ，如图把对应的勾选上 8.还是 Dot 往下滑，如图把对应的勾选上，DOT_IMAGE_FORMAT 也就是生成的图片的格式，自己根据自己需要选择 9.关于图片格式简单说一下，自动生成的 png ， jpg 和 gif 格式清晰度都比较低，svg 格式是矢量图，清晰度肯定是没问题的，不过 svg 格式图片不能用一般的图片查看器查看，电脑上浏览器就可以查看，如果是要插入到WORD中那也是没问题的，自己可以根据需要选择，前面第③步也提到了函数调用图会生成 PDF 文件，PDF格式的函数调用图也是清晰的 10.到此所有的设置就已经设好了，再将标签页切换到 Run ，点击左侧的 Run doxygen 即可，等待程序自动运行直至结束 11.如图输出 Doxygen has finished 的提示就已经完成了，点击左下角的 Show HTML output 就可以通过浏览器查看生成的函数调用图了，所有生成的文件也可以在第一步设置的保存位置找到 12.Doxygen软件默认不会保存你做的这些设置，但是可以手动保存，下一次使用的时候就可以只更改不同的设置就可以了 效果图附上一个效果图 结语以上仅作为个人学习记录，为了写自己的课设报告，参考的网上的教程一步步做的，对 Doxygen 以及 GraphViz 我也并不太了解，有需要再深入学习吧，现在能作为工具用好它们也就可以了！","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://mxy493.xyz/tags/C/"},{"name":"Doxygen","slug":"Doxygen","permalink":"https://mxy493.xyz/tags/Doxygen/"},{"name":"GraphViz","slug":"GraphViz","permalink":"https://mxy493.xyz/tags/GraphViz/"}]},{"title":"Leetcode 回文链表","date":"2019-03-04","updated":"2022-03-23","path":"2019030426598/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/6/linked-list/45/ 题目请判断一个链表是否为回文链表。 示例 1: 输入: 1-&gt;2 输出: false 示例 2: 输入: 1-&gt;2-&gt;2-&gt;1 输出: true 进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 我的解决方案/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: bool isPalindrome(ListNode* head) &#123; ListNode *newHead = NULL; //新建一个链表，将原链表反转 ListNode *cur = head; while (cur != NULL) //保留原链表的情况下将原链表反转 &#123; ListNode *temp = newHead; newHead = new ListNode(cur-&gt;val); newHead-&gt;next = temp; cur = cur-&gt;next; &#125; while (head != NULL) //原链表和反转链表逐个检点对比 &#123; if (head-&gt;val != newHead-&gt;val) //一旦对应结点不相等，则说明不是回文联表，返回false return false; head = head-&gt;next; newHead = newHead-&gt;next; &#125; return true; //默认返回true &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://mxy493.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Leetcode 合并两个有序链表","date":"2019-03-01","updated":"2020-05-01","path":"2019030162862/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/6/linked-list/44/ 题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 原解题思路需要考虑的几种情况： 1. 两个链表均为空 2. 两个链表中的一个为空 3. 链表只有一个结点 4. 两个链表均有多个结点 如下代码中对前三种较特殊情况都作了相应的特殊处理。 代码（一）/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* root; //返回值，合并后链表的头指针 //1、2种情况 if (l1 == NULL) //考虑特殊情况，l1为空则合并后链表即为l2 root = l2; else if (l2 == NULL) //l2为空则合并后链表即为l1 root = l1; //3、4种情况 else //都不为空则用常规方法合并 &#123; if (l1-&gt;val &lt; l2-&gt;val) //取根结点 &#123; root = l1; l1 = l1-&gt;next; &#125; else &#123; root = l2; l2 = l2-&gt;next; &#125; ListNode* tail = root; //合并链表的尾结点 while (l1 != NULL || l2 !=NULL) //可以直接写while(1)，循环内部根据l1或l2是否为空跳出循环 &#123; if (l1 == NULL) //l1为空，把l2链在尾部即可 &#123; tail-&gt;next = l2; break; &#125; else if (l2 == NULL) //l2为空，把l1链在尾部即可 &#123; tail-&gt;next = l1; break; &#125; if (l1-&gt;val &lt; l2-&gt;val) &#123; tail-&gt;next = l1; //将较小的l1链在尾部 tail = tail-&gt;next; //tail后移 l1 = l1-&gt;next; //l1后移 &#125; else //同上 &#123; tail-&gt;next = l2; tail = tail-&gt;next; l2 = l2-&gt;next; &#125; &#125; &#125; return root; &#125; &#125;; 现解题思路 2020年5月1日更新 刚开始看到这个题目还是有印象做过的，但也没去找，就按着自己思路再做一遍。 其实写完后再找出之前做的看了看，思路几乎是一样的吧，大同小异。 特别需要注意的是， l1 和 l2 都是可能为空的，一般情况下都要将其做特殊处理。 这一次我一开始是想逐个比较 l1 和 l2 的结点大小然后构建一个新的链表的，写的过程中想到，似乎这么做有些麻烦，其实两个链表都是有序链表，任选一个链表来进行更新就可以了。但是选哪一个链表来进行更新是有讲究的，如果选的是第一个值较大的链表，那么就得把另一个链表的第一个结点插入到最前面，实际上这就很麻烦，所以我首先调整了两个链表 l1 和 l2 ，使 l1 始终是头结点较小的那个链表，然后将新构建的链表的头指针指向 l1 ，接下来就只需要逐个移动 l1 和 l2 进行比较和合并了，实际上就是把 l2 合并到 l1 中。 代码（二）class Solution &#123; public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; if (l1 == NULL) &#123; return l2; &#125; else if (l2 == NULL) &#123; return l1; &#125; ListNode* head; if (l1-&gt;val &gt; l2-&gt;val) &#123; head = l1; l1 = l2; l2 = head; &#125; head = l1; while (l1-&gt;next != NULL &amp;&amp; l2 != NULL) &#123; if (l1-&gt;next-&gt;val &lt;= l2-&gt;val) &#123; l1 = l1-&gt;next; &#125; else &#123; ListNode* tmp = l2; l2 = l2-&gt;next; tmp-&gt;next = l1-&gt;next; l1-&gt;next = tmp; l1 = l1-&gt;next; &#125; &#125; if (l2 != NULL) &#123; l1-&gt;next = l2; &#125; return head; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://mxy493.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Leetcode 反转链表","date":"2019-02-27","updated":"2022-03-23","path":"2019022750370/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/6/linked-list/43/ 题目反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 我的解决方案/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* reverseList(ListNode* head) &#123; ListNode *newHead = NULL; //不断取出和向后移动头节点，并将头节点连接到新头节点后面 while (head != NULL) &#123; //单独取出下一个节点 ListNode *next = head-&gt;next; //将头节点连接到新头节点后面 head-&gt;next = newHead; newHead = head; //向后移动头节点 head = next; &#125; return newHead; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://mxy493.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Leetcode 删除链表的倒数第N个节点","date":"2019-02-23","updated":"2022-03-23","path":"2019022320240/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/6/linked-list/42/ 题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 我的解决方案常规的方法会想到要计算出链表的长度L，然后再从头结点开始往后遍历L-n-1个结点，即倒数第n个结点的前一个结点，再删除要删除的倒数第n个结点（pre-&gt;next = pre-&gt;next-&gt;next;）。而题目要求用一趟扫描实现，所以需要用到两个指针pre、cur都初始化为指向链表头结点，然后cur指针往后移n个结点到链表的第 n+1 个结点，再把 pre 和 cur 同时往后移直到 cur 的 next 指针指向 NULL ，即 cur 指向链表最后一个结点，此时 pre 指向倒数第 n 个结点的前一个结点，用同样的方法（pre-&gt;next = pre-&gt;next-&gt;next;）删除倒数第 n 个结点即可。 /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode *root = head; //作为返回值 ListNode *pre = head; ListNode *cur = head; for (int i = 0; i &lt; n; i++) //*cur指向第n+1个结点 cur = cur-&gt;next; if (cur == NULL) //说明倒数第n的结点就是头结点 root = head-&gt;next; //将头指针改为指向第二个节点即可删除头结点 else &#123; while (cur-&gt;next != NULL) //pre和cur同是往后移直到cur指向尾结点 &#123; pre = pre-&gt;next; cur = cur-&gt;next; &#125; pre-&gt;next = pre-&gt;next-&gt;next; //删除pre结点的后一个结点，即倒数第n个结点 &#125; return root; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://mxy493.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Leetcode 删除链表中的节点","date":"2019-02-22","updated":"2022-03-23","path":"2019022256642/","text":"地址：https://leetcode-cn.com/explore/featured/card/top-interview-questions-easy/6/linked-list/41/ 题目请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2: 输入: head = [4,5,1,9], node = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 我的解决方案解题思路： 因为找不到上一个结点的位置，所以是没有办法直接删除当前结点的，但是知道当前结点的位置，就可以删掉后一个结点，所以可以变一下思路通过删除后一个结点来间接地删除当前结点，先用后一个节点覆盖掉当前节点，然后再删除后一个节点。 /** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: void deleteNode(ListNode* node) &#123; node-&gt;val = node-&gt;next-&gt;val; //后一个结点的值赋给当前结点 node-&gt;next = node-&gt;next-&gt;next; //删除后一个结点，将后一个结点的next指针赋给当前结点的next指针 &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"链表","slug":"链表","permalink":"https://mxy493.xyz/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Leetcode 最长公共前缀","date":"2019-02-06","updated":"2022-03-23","path":"2019020649394/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/40/ 题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;] 输出: &quot;fl&quot; 示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;] 输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。 我的解决方案刚读完题就诞生了两个解题思路，所以都尝试写了一下，确实也都是可行的方法。 相对来说，如果公有部分较长的话应该方法二会高效一些，反之方法一可能更高效。个人感觉方法二应该更普适。 方法一： 这个方法比较容易想到，因为要找的是公共前缀，也就是所有字符串有有的前缀，所以从每个字符串的第1个元素开始判断是否都相等，相等则将这个字符插入到返回字符串str，直到找到某个字符不是所有字符串的公共部分，则不再插入到返回值str，并且后续无需继续判断。此时得出的字符串str就是字符串数组的公共前缀。 缺点：如果公共前缀太长的话，会做公共前缀对应长度的无效益的循环用于判断是否这些字符是否是公共的。 class Solution &#123; public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string str = &quot;&quot;; //返回值，初始化为空字符串 if (strs.size() &gt; 0) &#123; //strs为空的话直接执行return语句返回空字符串，否则执行下面的部分 for (int j = 0;; j++) &#123; if (j &gt;= strs[0].size()) //因为总是从第一个字符串开始，所以第一个字符串遍历完后后续就不可能再存在公有的字符了 break; else &#123; char ch = strs[0][j]; //字符串str[0]的第j+1个字符 bool bl = true; //字符ch是否公有的标志 for (int k = 0; k &lt; strs.size(); k++) &#123; if (strs[k][j] != ch) &#123; //如果某个字符串的第j个字符和ch不同说明ch不是公有字符 bl = false; break; &#125; &#125; if (bl == true) //说明ch是公有字符，插入到str尾部 str.insert(str.end(), ch); else break; //说明ch不是公有字符，后续不需要再判断 &#125; &#125; &#125; return str; &#125; &#125;; 方法二： 这个方法感觉高效一些，正好弥补了方法一的缺点。 思路是，任选一个字符串作为初始的str（为了方便遍历字符串数组，所以选第一个字符串strs[0]作为初始值），然后用其余每一个字符串依次和str比较查找公共部分，然后删去非公共部分，当整个字符串数组遍历完的时候也就删掉了字符串str与其余所有字符串的非公共部分，剩下的就是公共部分也就是所有字符串的公共前缀。 class Solution &#123; public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; string str = &quot;&quot;; //返回值，初始化为空字符串 if (strs.size() &gt; 0) &#123; str = strs[0]; //strs至少有一个字符串strs[0]，用它初始化str，因为公有部分的长度一定小于strs中的任意一个字符串 if (strs.size() &gt; 1) &#123; //如果strs.size（）大于1，则需要判断字符串str的哪部分为公有的 for (int i = 1; i &lt; strs.size(); i++) &#123; //从第二个字符串开始依次与str比较寻找公有部分，并删除str的非公有部分 int size = str.size() &lt; strs[i].size() ? str.size() : strs[i].size(); str.erase(str.begin() + size, str.end()); //如果str更长一些可以直接删除多余部分 for (int j = 0; j &lt; size; j++) &#123; if (str[j] != strs[i][j]) &#123; //某一个字符不相等说明从这个字符开始的后面所有字符都是多余的，删除即可 str.erase(str.begin() + j, str.end()); break; &#125; &#125; &#125; &#125; &#125; return str; &#125; &#125;; 测试数据测试1： flower flow flight 测试2： dog racecar car 测试数据需要考虑下数组为空的情况以及strs数组大小为1的较特殊情况。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 报数","date":"2019-02-06","updated":"2022-03-23","path":"2019020640841/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/39/ 题目报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1 输出: &quot;1&quot; 示例 2: 输入: 4 输出: &quot;1211&quot; 我的解决方案题目读懂了的话并不是很难，一开始需要花点时间读题，其实就是每一个数都是由前一个数得来的，也就是1是整个报数过程的开始。 如第五项，从前往后，依次是“三个一”，“两个二”，“一个一”，所以下一个数就是312211，然后根据这个数同样的可以从前往后读出“一个三”，“一个一”，“两个二”，“两个一”，所以再往后一个数是13112221，依次类推。 class Solution &#123; public: string countAndSay(int n) &#123; string str = &quot;1&quot;; //整个报数的开始，第一项是“一个一” for (int i = 1; i &lt; n; i++) &#123; string temp; //保存根据字符串str得出的下一个报数 int q = 0; //记录字符e的数量 char e = str[0]; //记录不同于前一个字符的新出现字符e，初始化为str[0] for (int j = 0; j &lt; str.size(); j++) &#123; if (str[j] == e) &#123; //统计字符e连续出现的次数 q++; &#125; else &#123; //说明出现了新字符，将前一个字符e及其连续出现的次数插入到字符串temp尾部 temp.insert(temp.end(), q + 48); //插入字符e的数量q temp.insert(temp.end(), e); //插入字符e e = str[j]; q = 1; &#125; &#125; temp.insert(temp.end(), int(q + 48)); //插入最后一个字符e的数量q temp.insert(temp.end(), e); //插入最后一个字符e str = temp; &#125; return str; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 实现strStr()","date":"2019-02-06","updated":"2022-03-23","path":"2019020611933/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/38/ 题目实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot; 输出: 2 示例 2: 输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot; 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 我的解决方案class Solution &#123; public: int strStr(string haystack, string needle) &#123; int addr; if (haystack.size() &lt; needle.size()) //当haystack.size() &lt; needle.size()时显然不存在满足条件的情况 addr = -1; else &#123; if (needle.size() == 0) //当needle是空字符串时返回0 addr = 0; else &#123; //当haystack.size() &gt;= needle.size()时 bool find = false; //标记是否找到满足条件的情况 for (int i = 0; i &lt; haystack.size(); i++) &#123; //遍历字符串haystack查找与字符串needle首字符相同的位置 if (haystack[i] == needle[0]) &#123; bool isEqual = true; //标记以下标i开始的长度为needle.size()的字符串是否与字符串needle相等 for (int j = i; j &lt; i + needle.size(); j++) &#123; if (haystack[j] != needle[j - i]) &#123; //一旦某一位不相等说明以i开始的长度为needle.size()的字符串不满足条件 isEqual = false; break; &#125; &#125; if (isEqual == true) &#123; //说明以i开始的长度为needle.size()的字符串与字符串needle不相等 find = true; addr = i; break; &#125; &#125; else continue; &#125; if (find == false) //没找到满足条件的情况，返回-1 addr = -1; &#125; &#125; return addr; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 字符串转换整数(atoi)","date":"2019-02-04","updated":"2022-03-23","path":"2019020458079/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/37/ 题目请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: &quot;42&quot; 输出: 42 示例 2: 输入: &quot; -42&quot; 输出: -42 解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: &quot;4193 with words&quot; 输出: 4193 解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。 示例 4: 输入: &quot;words and 987&quot; 输出: 0 解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: &quot;-91283472332&quot; 输出: -2147483648 解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 我的解决方案class Solution &#123; public: int myAtoi(string str) &#123; long long ans = 0; //和之前做过的一个题类似需要定义一个比int存储得更多的数据类型 int sym = 1; //正负号 bool fir = false; //是否找到第一个数字 for (int i = 0; i &lt; str.size(); i++) &#123; if (fir == false) &#123; //没找到第一个有效元素之前 if (str[i] == &#x27; &#x27;) //跳过空格 continue; else if (str[i] == &#x27;+&#x27;) &#123; //正号默认sym=1，修改fir为true fir = true; continue; &#125; else if (str[i] == &#x27;-&#x27;) &#123; //负号置sym为-1，修改fir为true sym = -1; fir = true; continue; &#125; else if (str[i] &gt;= 48 &amp;&amp; str[i] &lt;= 57) &#123; //第一个有效字符是数字直接存到ans中并修改fir为true ans = int(str[i]) - 48; fir = true; &#125; else return 0; //第一个非空字符无效直接返回0 //第一个非“空格字符”不是正负号也不是数字则直接返回0 &#125; else&#123; //已找到第一个有效字符 if (str[i] &gt;= 48 &amp;&amp; str[i] &lt;= 57) &#123; //如果下一个字符是数字，直接转换为不带正负号的整数存储到ans中 ans = ans * 10 + int(str[i]) - 48; if (sym* ans &lt; INT_MIN) //一旦ans的值超出范围就不再继续转换直接返回INT_MAX或INT_MIN return INT_MIN; else if (sym* ans &gt; INT_MAX) return INT_MAX; &#125; else break; //一旦遇到非数字字符就结束转换，例如“+-2” &#125; &#125; return sym * ans; //返回正常转换的结果 &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 验证回文字符串","date":"2019-02-02","updated":"2022-03-23","path":"2019020249412/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/36/ 题目给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 输入: &quot;A man, a plan, a canal: Panama&quot; 输出: true 示例 2: 输入: &quot;race a car&quot; 输出: false 我的解决方案class Solution &#123; public: bool isPalindrome(string s) &#123; bool bl = true; //作为返回值 string sta; //定义一个字符串sta将原字符串s标准化 for (int i = 0; i &lt; s.size(); i++) &#123; //将原字符串s除字母和数字外的字符去除并将大写字母全部转换为小写字母 if ((s[i] &gt;= 48 &amp;&amp; s[i] &lt;= 57) || (s[i] &gt;= 97 &amp;&amp; s[i] &lt;= 122)) &#123; sta += s[i]; &#125; if (s[i] &gt;= 65 &amp;&amp; s[i] &lt;= 90) &#123; sta += char(s[i] + 32); &#125; &#125; int n = sta.size(); //字符串sta的字符个数 for (int j = 0; j &lt; sta.size() / 2; j++) &#123; //判断是否回文串 if (sta[j] != sta[n - 1 - j]) &#123; //说明不是回文串，将bl置为false并跳出循环，后续不必再判断 bl = false; break; &#125; &#125; return bl; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 有效的字母异位词","date":"2019-02-02","updated":"2022-03-23","path":"201902029846/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/35/ 题目给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。 示例 1: 输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot; 输出: true 示例 2: 输入: s = &quot;rat&quot;, t = &quot;car&quot; 输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 我的解决方案class Solution &#123; public: bool isAnagram(string s, string t) &#123; bool bl = true; //作为返回值，初始化为true int sc[26]; //sc[],tc[]用于记录字符串中各个字符的个数 int tc[26]; for (int i = 0; i &lt; 26; i++) &#123; //初始化sc[],tc[]为全0 sc[i] = 0; tc[i] = 0; &#125; if (s.size() != t.size()) //字符串大小不等显然不是有效的字母异位词 bl = false; else &#123; //字符串大小相等的情况 for (int i = 0; i &lt; s.size(); i++) &#123; int saddr = s[i] - 97; //转换字符s[i]作为数组sc[]的下标 int taddr = t[i] - 97; //同上 sc[saddr]++; //统计以saddr为下标代表的字符在字符串s中出现的次数 tc[taddr]++; //同上 &#125; for (int j = 0; j &lt; 26; j++) &#123; //判断是否有效的字母异位词 if (sc[j] != tc[j]) &#123; //若某个字母在两字符串中的个数不相等，说明不是有效的字母异位词 bl = false; break; &#125; &#125; &#125; return bl; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 字符串中的第一个唯一字符","date":"2019-02-01","updated":"2019-02-01","path":"2019020146060/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/34/ 题目给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 案例: s = &quot;leetcode&quot; 返回 0. s = &quot;loveleetcode&quot;, 返回 2. 注意事项：您可以假定该字符串只包含小写字母。 我的解决方案class Solution &#123; public: int firstUniqChar(string s) &#123; int addr = -1; //保存第一个不重复的字符的索引并初始化为-1 if (s.size() == 1) addr = 0; for (int i = 0; i &lt; s.size(); i++) &#123; //遍历整个字符串的每一个字符 bool isUniq = true; //判断当前字符s[i]是否唯一 for (int j = 0;j &lt; s.size(); j++) &#123; if (i == j) continue; if (s[j] == s[i]) &#123; //如果找到与s[i]相同的字符 isUniq = false; //说明s[i]不唯一，置isUniq为false break; &#125; &#125; if (isUniq == true) &#123; //isUniq为true说明上面的循环中没有找到与s[i]相同的字符 addr = i; //i即第一个不重复的字符的索引 break; //后序字符不必不能继续判断，否则如果后续还有唯一字符就会重写addr导致结果错误 &#125; &#125; return addr; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"关于Hexo yilia主题文章截断功能","date":"2019-02-01","updated":"2022-03-23","path":"2019020144422/","text":"yilia的主题是自带了文章截断的功能的，当然并不是说写一篇文章它会自动给你截断，还是需要自己将截断标记手动写到文章的某个位置。 截断标记：&lt;!--more--&gt; 效果就是标记之前的内容会在博客首页直接展示，而标记之后的内容则需要点击右下角的阅读更多才能显示，但是添加标记后实际的情况是下图这样的： 事实上点击上图中的more&gt;&gt;和点击阅读更多是有相同的作用的，但是不太美观了，大概也不是我们想要的，不然单独做一个阅读更多的按钮干嘛，解决办法很简单。 打开yilia主题根目录下的_config.yml文件，找到excerpt_link，把后面的more删掉，保存，就可以了。 效果如图：","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"yilia","slug":"yilia","permalink":"https://mxy493.xyz/tags/yilia/"}]},{"title":"Leetcode 整数反转","date":"2019-01-31","updated":"2019-01-31","path":"2019013124102/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/33/ 题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1:输入: 123 输出: 321 示例 2:输入: -123 输出: -321 示例 3:输入: 120 输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 我的解决方案4个关键点： 将符号与数值分离单独处理 定义保存结果的变量t，数据类型的选择(long long) 逆转，基础操作 判断是否溢出 算法：class Solution &#123; public: int reverse(int x) &#123; int sym = 1; //符号为正 sym == 1 ，符号为负 sym == -1 //t保存反转后的整数，数据类型必须用long long，否则t溢出后已被处理，无法判断其正确的值是否溢出 long long t = 0; //只能用long long，int或long都不行，需要将t初始化为0 if (x &lt; 0) &#123; //如果x为负，置sym为-1并变x为正 sym = -1; x = -1 * x; &#125; while (x != 0) &#123; //对正数x进行反转 t = t * 10 + x % 10; x = x / 10; &#125; if (t &gt; 0x7fffffff || t &lt; (signed int)0x80000000) //判断逆转后的x是否溢出 return 0; return sym * t; //返回逆转后的数 &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 反转字符串","date":"2019-01-30","updated":"2019-01-30","path":"2019013061953/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/5/strings/32/ 题目编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;] 输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;] 示例 2： 输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;] 输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;] 我的解决方案挺简单的，就是用一个临时变量temp做前后兑换。 class Solution &#123; public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int n = s.size(); for (int i = 0; i &lt; n / 2; i++) &#123; char temp = s[i]; s[i] = s[n - 1 - i]; s[n - 1 - i] = temp; &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://mxy493.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Leetcode 旋转图像","date":"2019-01-29","updated":"2019-01-29","path":"201901292928/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/31/ 题目给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 我的解决方案通过观察找规律会发现： 第i行的元素成了第n-1-i列的元素，而第j列的元素成了第i行的元素； 第i行的元素是由第n-1-j列的元素变换而来的，第j列的元素是由第i行的元素变换而来的。 我的思路是每遍历到一个没有转换过的元素，就一次性把与这个元素有转换关系的另外三个元素都转换完毕，例如题目示例1中遍历到第一个元素matrix[0][0]==1，就完成如下的转换： matrix[0][0]==1 ==&gt;&gt; 7 matrix[2][0]==7 ==&gt;&gt; 9 matrix[2][2]==9 ==&gt;&gt; 3 matrix[0][2]==3 ==&gt;&gt; 1 按照这样的逻辑，就不能遍历二维矩阵的每一个元素，因为每遍历到一个元素其实相当于处理了四个元素，如果对处理过的元素再遍历一次就会再做一次转换最后得到的显然不是正确答案，并且这样的重复操作也是影响代码效率的，所以遍历的两层循环需要理解一下。在题目给的两个示例中就是： 示例1: 1: 1-&gt;3-&gt;9-&gt;7-&gt;1 2: 2-&gt;6-&gt;8-&gt;4-&gt;2 示例2: 5: 5-&gt;11-&gt;16-&gt;15-&gt;5 1: 1-&gt;10-&gt;12-&gt;13-&gt;1 9: 9-&gt;7-&gt;14-&gt;2-&gt;9 4: 4-&gt;8-&gt;6-&gt;3-&gt;4 实际转换的时候，按照上述的第二条规律逆时针方向转换，需要用一个temp来保存遍历到的matrix[i][j]。不能顺时针方向转换，因为当前元素的值已经改变，又赋给下一个对应位置元素，最后就导致对应位置上四个元素的值都是相等的，逻辑上就不对。 实现代码：class Solution &#123; public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); //n×n的二维矩阵 for (int i = 0; i &lt; n / 2; i++) &#123; for (int j = i; j &lt; n - 1 - i; j++) &#123; int temp = matrix[i][j]; //用temp临时记录matrix[i][j]的值 int x = i; //用x,y表示i,j，转换过程中需要改变下标的值，而外层遍历需要保持i,j的值不变 int y = j; for (int l = 1; l &lt;= 3; l++) &#123; //对三个元素进行转换 matrix[x][y] = matrix[n - 1 - y][x]; int t = x; x = n - 1 - y;; y = t; &#125; matrix[j][n - 1 - i] = temp; //最后一个未转换的元素用temp赋值 &#125; &#125; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Leetcode 有效的数独","date":"2019-01-28","updated":"2019-01-28","path":"2019012823538/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/30/ 题目判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 输入: [ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: true 示例 2: 输入: [ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。 我的解决方案class Solution &#123; public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; bool isValid = true; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; //判断i行 if (board[i][j] == &#x27;.&#x27;) continue; for (int k = j + 1; k &lt; 9; k++) &#123; if (board[i][k] == &#x27;.&#x27;) continue; if (board[i][j] == board[i][k]) &#123; //如果i行有两个数字相等跳转至函数返回语句 isValid = false; //置isValid为false goto label; //并跳转至函数返回语句 &#125; &#125; &#125; for (int j = 0; j &lt; 9; j++) &#123; //判断i列 if (board[j][i] == &#x27;.&#x27;) continue; for (int k = j + 1; k &lt; 9; k++) &#123; if (board[k][i] == &#x27;.&#x27;) continue; if (board[j][i] == board[k][i]) &#123; isValid = false; goto label; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; 9; i += 3) &#123; //判断3x3宫内 for (int j = 0; j &lt; 9; j += 3) &#123; //前两层循环用于遍历每个3x3宫格的左上角元素所在位置 vector&lt;int&gt; vec(10); //事实上只用到vec[1]~vec[9]，用于记录3x3宫格内每个数字出现的次数 for (int k = i; k &lt; i + 3; k++) &#123; //后两层循环用于遍历以board[i][j]作为左上角元素的3x3宫格 for (int l = j; l &lt; j + 3; l++) &#123; int num = board[k][l] - 48; //将字符转换为数字 if (num &gt;= 1 &amp;&amp; num &lt;= 9)&#123; //判断字符是否是数字 vec[num]++; //如果是数字，就以这个数字作为下标将vec[num]加一，表示num出现的次数 if (vec[num] &gt; 1) &#123; //vec[num]&gt;1说明这个数字重复出现了 isValid = false; //置isValid为false goto label; //并跳转至函数返回语句 &#125; &#125; &#125; &#125; &#125; &#125; label: return isValid; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Leetcode 两数之和","date":"2019-01-28","updated":"2019-01-28","path":"201901285643/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/29/ 题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 我的解决方案class Solution &#123; public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; ans; for (int i = 0; i &lt; (nums.size() - 1); i++) &#123; for (int j = i + 1; j &lt; nums.size(); j++) &#123; if (nums[i] + nums[j] == target) &#123; ans.insert(ans.end(), i); ans.insert(ans.end(), j); goto label; //事实上这里应该可以直接return返回结果，可能是Leetcode不允许这样，所以用了一个标签语句跳转至程序尾 &#125; &#125; &#125; label:return ans; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Hexo博客（主题：yilia）添加Valine评论系统","date":"2019-01-28","updated":"2019-01-28","path":"201901283204/","text":"序言其实网上关于Hexo的博客添加Valine评论系统的是教程很多的，但是大多针对Next那个主题，确实那个主题各方面的功能都做得很完善了，但是我还是比较喜欢yilia这个主题，然而这两个主题的文件结构就很不一样，教程并不能直接用到yilia这个主题上来。 在我使用yilia主题添加Valine评论系统的过程中着实遇到不少问题，个人没有在网上找到一份完全针对yilia主题添加valine评论系统的详细教程，所以写下这篇教程，也算是写的笔记吧，也许有后来者能用得上。 添加相关代码yilia主题支持了多说、网易云跟帖、畅言、Disqus以及Gitment，但似乎没有写好的valine代码，所以我们首先要手动添加相关代码。 下面的代码来源于yilia主题下的一个Issue：新增对Valine评论系统的支持，可以参照一下（不想踩坑的话请就看我这篇文章，不用谢我），但是对小白来说可能并不太清楚，代码添加到某一个文件，但是并没有说具体添加到什么位置，所以我根据自己的经历写一下对小白来说更加切实的步骤。 需要修改的有三个地方，都是主题目录下对应的文件，不是博客目录，修改后记得保存。 1._config.ymlyilia主题根目录下的_config.yml，不是博客根目录下的_config.yml，打开后添加到什么位置都可以，但是建议根据已经写好的几个评论系统就对应的添加到#5、Gitment的下方 #6、Valine https://valine.js.org valine: appid: #Leancloud应用的appId appkey: #Leancloud应用的appKey verify: false #验证码，verify和notify这两个最好就别动了 notify: false #评论回复提醒 avatar: mm #评论列表头像样式：&#x27;&#x27;/mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go #评论框占位符 如图： 2.layout/_partial/article.ejs这段代码改过一点点，添加了一个判断条件如果在博客首页就不执行下面的代码（具体添加了下面代码的第一行和最后一行），也就是只在阅读全文的时候才在文章底部显示评论框，原Issue下的代码不含这个判断条件，也就是首页每篇博客下方都会有一个评论框，这应该不是我们想要的。 &lt;% if (!index)&#123; %&gt; &lt;% if (theme.valine &amp;&amp; theme.valine.appid &amp;&amp; theme.valine.appkey)&#123; %&gt; &lt;section id=&quot;comments&quot; class=&quot;comments&quot;&gt; &lt;style&gt; .comments&#123;margin:30px;padding:10px;background:#fff&#125; @media screen and (max-width:800px)&#123;.comments&#123;margin:auto;padding:10px;background:#fff&#125;&#125; &lt;/style&gt; &lt;%- partial(&#x27;post/valine&#x27;, &#123; key: post.slug, title: post.title, url: config.url+url_for(post.path) &#125;) %&gt; &lt;/section&gt; &lt;% &#125; %&gt; &lt;% &#125; %&gt; 直接插入在最后面就可以，可以看到上面一段就是Gitment评论系统的相关代码，如图： 3.layout/_partial/post/valine.ejs这个文件是没有的，按照标题路径新建一个valine.ejs，再把下面的代码添加添加进去，保存，注意和Issue给出的代码可能不太一样，说过了不想踩坑请直接使用我给出的。 &lt;div id=&quot;vcomment&quot; class=&quot;comment&quot;&gt;&lt;/div&gt; &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&#x27;//unpkg.com/valine/dist/Valine.min.js&#x27;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var notify = &#x27;&lt;%= theme.valine.notify %&gt;&#x27; == true ? true : false; var verify = &#x27;&lt;%= theme.valine.verify %&gt;&#x27; == true ? true : false; new Valine(&#123; av: AV, el: &#x27;#vcomment&#x27;, notify: notify, app_id: &quot;&lt;%= theme.valine.appid %&gt;&quot;, app_key: &quot;&lt;%= theme.valine.appkey %&gt;&quot;, placeholder: &quot;&lt;%= theme.valine.placeholder %&gt;&quot;, avatar:&quot;&lt;%= theme.valine.avatar %&gt;&quot;, &#125;); &lt;/script&gt; 评论安装接下来就要使用到Leancloud了，大概就是作为我们Valine评论系统的服务器，因为Valine首页就介绍了Valine是“一款快速、简洁且高效的无后端评论系统”，自行注册一个账号并登录。 创建一个应用，应用名看个人喜好。 选择刚刚创建的应用&gt;设置&gt;选择应用 Key，然后你就能看到你的App ID和App Key了，参考下图： 分别复制App ID和App Key粘贴到前面设置的主题根目录下的_config.yml里对应位置，注意“:”后面必须要有一个空格，如图： 为了数据安全，再填写一下安全域名，应用&gt;设置&gt;安全设置中的Web 安全域名，如果是Hexo一般填写自己博客主页的地址和http://localhost:4000/就可以了，如下图： 到这里，你的评论系统就已经可以工作了！ 当然修改了相关代码需要重新部署博客，三步操作： $ hexo clean $ hexo g $ hexo s #本地测试用http://localhost:4000/访问即可，也可以hexo d部署到云端 自己写条评论试试呢，评论的数据会保存到Leancloud你创建的应用里，具体可以登录Leancloud，选择应用&gt;存储&gt;Comment，评论的所有相关信息都可以在这儿看到： 到此如果没有更多的需求已经可以结束不折腾了，进一步的下面介绍实现邮件通知的功能。 部署云引擎（邮件通知）这一部分主要参考这篇博客Valine Admin 配置手册。 1.填写代码仓库在Leancloud云引擎设置界面，填写代码库并保存：https://github.com/DesertsP/Valine-Admin.git（直接复制填上去就行，不是要自己建一个类似的代码仓库，另外注意这个链接是否有变动） 2.设置环境变量以及Web 二级域名在设置页面，设置环境变量以及 Web 二级域名。先后顺序没什么影响，不过可以先设置 Web 二级域名，需要实名认证，自己认证一下。 Web 二级域名用于评论后台管理，如https://mxy493.leanapp.cn 环境变量必填参数务必正确设置： 这里虽然部分是选填的，但是个人建议都填上吧，当然首先要填对，填错了那就没用了。 SMTP_SERVICE建议用QQ，目前我用的QQ邮箱没有任何问题，163邮箱在我设置的过程中似乎有不能发送邮件的问题，应该是网易邮箱那边的限制所以无关你设置得对不对，Gmail似乎是因为被墙了会连接超时，其它我没试过。 变量 示例 说明 SITE_NAME Deserts [必填]博客名称 SITE_URL https://mxy493.github.io/ [必填]首页地址 SMTP_SERVICE QQ [新版支持]邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多 SMTP_USER &#120;&#120;&#x78;&#120;&#x78;&#x78;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d; [必填]SMTP登录用户 SMTP_PASS ccxxxxxxxxch [必填]SMTP登录密码（QQ邮箱需要获取独立密码） SENDER_NAME mxy [必填]发件人 SENDER_EMAIL &#x78;&#x78;&#x78;&#x78;&#120;&#120;&#x40;&#113;&#113;&#x2e;&#x63;&#111;&#109; [必填]发件邮箱 ADMIN_URL https://xxx.leanapp.cn/ [建议]Web主机二级域名，用于自动唤醒 BLOGGER_EMAIL &#120;&#x78;&#120;&#120;&#x78;&#120;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d; [可选]博主通知收件地址，默认使用SENDER_EMAIL 注：环境变量有任何更改都需要重启应用才能生效（云引擎&gt;实例&gt;设置&gt;重启） 3.部署实例切换到部署标签页，分支使用master，点击部署即可。 部署日志显示“部署完成，1个实例部署成功”就部署好了，点击关闭即可。 4.评论管理访问设置的二级域名https://二级域名.leanapp.cn/sign-up，注册管理员登录信息，如：https://mxy493.leanapp.cn/sign-up 注：使用原版Valine如果遇到注册页面不显示直接跳转至登录页的情况，请手动删除_User表中的全部数据。 5.设置定时任务进入云引擎&gt;定时任务，创建定时器，创建两个定时任务。 1.半小时自动唤醒选择self-wake云函数，Cron表达式为0 0/30 7-23 * * ?，表示每天早6点到晚23点每隔30分钟访问云引擎，确定环境变量ADMIN_URL设置正确： 2.八点叫我发邮件选择resend-mails云函数，Cron表达式为0 0 8 * * ?，表示每天早8点检查过去24小时内漏发的通知邮件并补发： 添加完计时器记得点击启动。 至此，评论已经可以通过邮件发送通知了。 邮件通知模板这一部分可选，懒得折腾可以到此为止！ 邮件通知模板在云引擎环境变量中设定，可自定义通知邮件标题及内容模板。 邮件通知包含两种，分别是“被@通知”和“博主通知”，这两种模板都可以完全自定义。默认使用经典的蓝色风格模板（样式来源未知）。 环境变量 示例 说明 MAIL_TEMPLATE_ADMIN 见下文 [可选]博主邮件通知内容模板 MAIL_SUBJECT_ADMIN ${SITE_NAME}上有新评论了 [可选]博主邮件通知主题模板 MAIL_TEMPLATE 见下文 [可选]被@通知邮件内容模板 MAIL_SUBJECT ${PARENT_NICK}，您在${SITE_NAME}上的评论收到了回复 [可选]被@通知邮件主题（标题）模板 默认博主通知邮件内容模板： &lt;div style=&quot;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;&quot;&gt;&lt;h2 style=&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #12ADDB;&quot; href=&quot;$&#123;SITE_URL&#125;&quot; target=&quot;_blank&quot;&gt;$&#123;SITE_NAME&#125;&lt;/a&gt;上的文章有了新的评论&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style=&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;POST_URL&#125;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 博主通知邮件模板中的可用变量与@通知中的基本一致，PARENT_NICK 和 PARENT_COMMENT 变量不再可用。 默认被@通知邮件内容模板： &lt;div style=&quot;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;&quot;&gt;&lt;h2 style=&quot;border-bottom:1px solid #DDD;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #12ADDB;&quot; href=&quot;$&#123;SITE_URL&#125;&quot; target=&quot;_blank&quot;&gt; $&#123;SITE_NAME&#125;&lt;/a&gt;上的评论有了新的回复&lt;/h2&gt; $&#123;PARENT_NICK&#125; 同学，您曾发表评论：&lt;div style=&quot;padding:0 12px 0 12px;margin-top:18px&quot;&gt;&lt;div style=&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;PARENT_COMMENT&#125;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;$&#123;NICK&#125;&lt;/strong&gt;回复说：&lt;/p&gt;&lt;div style=&quot;background-color: #f5f5f5;padding: 10px 15px;margin:18px 0;word-wrap:break-word;&quot;&gt; $&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;POST_URL&#125;&quot; target=&quot;_blank&quot;&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;SITE_URL&#125;&quot; target=&quot;_blank&quot;&gt;$&#123;SITE_NAME&#125;&lt;/a&gt;。&lt;br&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 效果图： 彩虹风格的被@邮件通知模板： &lt;div style=&quot;border-radius: 10px 10px 10px 10px;font-size:13px; color: #555555;width: 666px;font-family:&#x27;Century Gothic&#x27;,&#x27;Trebuchet MS&#x27;,&#x27;Hiragino Sans GB&#x27;,微软雅黑,&#x27;Microsoft Yahei&#x27;,Tahoma,Helvetica,Arial,&#x27;SimSun&#x27;,sans-serif;margin:50px auto;border:1px solid #eee;max-width:100%;background: #ffffff repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 1px 5px rgba(0, 0, 0, 0.15);&quot;&gt;&lt;div style=&quot;width:100%;background:#49BDAD;color:#ffffff;border-radius: 10px 10px 0 0;background-image: -moz-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));background-image: -webkit-linear-gradient(0deg, rgb(67, 198, 184), rgb(255, 209, 244));height: 66px;&quot;&gt;&lt;p style=&quot;font-size:15px;word-break:break-all;padding: 23px 32px;margin:0;background-color: hsla(0,0%,100%,.4);border-radius: 10px 10px 0 0;&quot;&gt;您在&lt;a style=&quot;text-decoration:none;color: #ffffff;&quot; href=&quot;$&#123;SITE_URL&#125;&quot;&gt; $&#123;SITE_NAME&#125;&lt;/a&gt;上的留言有新回复啦！&lt;/p&gt;&lt;/div&gt;&lt;div style=&quot;margin:40px auto;width:90%&quot;&gt;&lt;p&gt;$&#123;PARENT_NICK&#125; 同学，您曾在文章上发表评论：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;$&#123;PARENT_COMMENT&#125;&lt;/div&gt;&lt;p&gt;$&#123;NICK&#125; 给您的回复如下：&lt;/p&gt;&lt;div style=&quot;background: #fafafa repeating-linear-gradient(-45deg,#fff,#fff 1.125rem,transparent 1.125rem,transparent 2.25rem);box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);margin:20px 0px;padding:15px;border-radius:5px;font-size:14px;color:#555555;&quot;&gt;$&#123;COMMENT&#125;&lt;/div&gt;&lt;p&gt;您可以点击&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;POST_URL&#125;#comments&quot;&gt;查看回复的完整內容&lt;/a&gt;，欢迎再次光临&lt;a style=&quot;text-decoration:none; color:#12addb&quot; href=&quot;$&#123;SITE_URL&#125;&quot;&gt; $&#123;SITE_NAME&#125;&lt;/a&gt;。&lt;/p&gt;&lt;style type=&quot;text/css&quot;&gt;a:link&#123;text-decoration:none&#125;a:visited&#123;text-decoration:none&#125;a:hover&#123;text-decoration:none&#125;a:active&#123;text-decoration:none&#125;&lt;/style&gt;&lt;/div&gt;&lt;/div&gt; 效果图： 被@通知模板中的可用变量如下（注，这是邮件模板变量，是指嵌入到HTML邮件模板中的变量，请勿与云引擎环境变量混淆）： 模板变量 说明 SITE_NAME 博客名称 SITE_URL 博客首页地址 POST_URL 文章地址（完整路径） PARENT_NICK 收件人昵称（被@者，父级评论人） PARENT_COMMENT 父级评论内容 NICK 新评论者昵称 COMMENT 新评论内容 有需求代码部分可以自定义，没有需求的话直接复制博主邮件通知代码到MAIL_TEMPLATE_ADMIN，复制被@通知代码到MAIL_TEMPLATE，保存即可。 注：修改了环境变量需要重启实例。","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Valine","slug":"Valine","permalink":"https://mxy493.xyz/tags/Valine/"}]},{"title":"Hexo中插入本地图片","date":"2019-01-27","updated":"2022-03-23","path":"201901272146/","text":"序言在Hexo中插图片的方式，在晚上看到是有多种办法的，但是我暂时只写一种办法，大概也是我认为最简单直接可以解决问题的办法。 插入图片的几种方式：下面是插入图片的几种方式： 传统Markdown方式 Hexo方式post_asset_folder 网络图片插入 Hexo的特定语法 Hexo方式post_asset_folder1.根目录下的配置文件_config.yml里的post_asset_folder选项设置为true。置为true之后新建文章的时候就会同时创建一个与文章同名的文件夹用于存放资源，Hexo官方文档称之为资源文件夹。之后把每篇文章需要插入的图片都放在这个文件夹里。 2.执行命令npm install hexo-asset-image --save ，下载安装一个可以上传本地图片的插件。 3.编辑文章的时候，只需要用markdown语法插入图片![](test.jpg)，图片的路径只需给出图片名字就行。 4.用markdown编辑器编辑时这样的语法是不会直接显示图片的，文章写好后本地测试就有了，然后部署到云端就行。 总结就写这一个添加图片的方式，个人感觉这应该是最简单的方式了，其它几种方式有需要以后再更新吧。","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Hexo yilia主题添加“不蒜子”访问量统计","date":"2019-01-26","updated":"2022-03-23","path":"2019012656295/","text":"不蒜子：https://busuanzi.ibruce.info/ Hexo添加访问量统计功能可以用百度统计、Leancloud，还有不蒜子。 我设置了百度统计，但是百度统计只能在后台查看数据，而今天新添加的不蒜子，可以将统计信息直接显示在网页上，更加直观一些，也减少了登录后台的麻烦。 一、添加不蒜子将下面的代码添加到/themes/根据个人目录修改/layout/_partial/footer.ejs（代码添加到不同的位置，在页面上显示的位置也不同）： &lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 我将它放在了页面下方正中。 这段代码我写在了footer.ejs里，也可以写在header.ejs里或者layout.ejs里。 二、添加站点访问量通常站点的总访问量会显示在footer的位置，所以我们可以在footer.ejs里添加如下标签，两种算法根据需要任选其一即可（如上图）： 算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次 &lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次 &lt;/span&gt; 三、添加文章阅读量添加文章阅读量和站点访问量基本一致，但是要添加一个判断条件只在文章中显示文章阅读量，主页自然是没有阅读量一说的。 将下面的代码添加到/themes/根据个人目录修改/layout/_partial/article.ejs的合适位置： &lt;% if (!index)&#123; %&gt; &lt;span id=&quot;busuanzi_container_page_pv&quot;&gt; ⋉(●本文总阅读量 &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt; 次●)⋊ &lt;/span&gt; &lt;% &#125; %&gt; 例如我放在了如图所示位置，最终会现在在文章底部的标签后面。 四、最终的显示效果文章阅读量： 站点访问量：","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"Leetcode 移动零","date":"2019-01-26","updated":"2022-03-23","path":"2019012610528/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/28/ 一、题目给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 二、我的解决方案class Solution &#123; public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int q = 0; //用于记录当前遍历到的0的个数 for (int i = nums.size() - 1; i &gt;= 0; i--) &#123; //从后往前遍历避免对已经后移的0重复处理 if (nums[i] == 0) &#123; nums.insert(nums.end() - q, 0); //在数组尾第q个0之前插入一个0 nums.erase(nums.begin() + i); //删除nums[i] q++; &#125; &#125; &#125; &#125;; 使用了两个vector的函数insert（用于插入元素）和erase（用于删除元素）。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Leetcode 加一","date":"2019-01-25","updated":"2022-03-23","path":"2019012558421/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/27/ 一、题目给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 二、我的解决方案首先想到用一个int型整数来保存输入的这个数，因为整数+1很容易实现，把数组的各个数字合并成一个整数以及将一个整数拆分成单个数字都很容易实现，所以写出了这份代码，也理所当然的造成了太大的数溢出的问题： class Solution &#123; public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; vector&lt;int&gt; plusone; int integer = digits[0]; //默认输入数组非空，最小为0 if (digits.size() &gt; 0) &#123; //计算出对应的数字integer for (int i = 1; i &lt; digits.size(); i++) &#123; integer = integer * 10 + digits[i]; &#125; &#125; integer += 1; //整数+1 while (integer!=0) &#123; //将整数拆分成单个数字并逆序保存到plusone数组中 plusone.insert(plusone.end(), integer % 10); integer /= 10; &#125; for (int i = 0; i &lt; plusone.size() / 2; i++) &#123; //逆序排列得出结果 int temp = plusone[i]; plusone[i] = plusone[plusone.size() - 1 - i]; plusone[plusone.size() - 1 - i] = temp; &#125; return plusone; &#125; &#125;; 例如当输入的数字为[9,8,7,6,5,4,3,2,1,0]时，将得到错误的结果[1,2,8,6,6,0,8,6,1,9]。 改进后的代码： class Solution &#123; public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int car = 1; //对最后一位+1以及判断当前项是否有进位 for (int i = digits.size() - 1; i &gt;= 0; i--) &#123; //从最后一项开始往前遍历 if (car == 1) &#123; if (digits[i] == 9) &#123; //如果当前项为9并且要+1，则当前项置0，进位标志置1 digits[i] = 0; car = 1; continue; &#125; else &#123; //如果当前项非9并且要+1，当前项直接+1，并将进位标志置0 digits[i] += 1; car = 0; break; //一旦进位标志置0表明往前不会再有进位，无需继续遍历 &#125; &#125; &#125; if (car == 1) //如果上面循环结束后进位标志仍为1，则还需要在数组最前面补1 digits.insert(digits.begin(), 1); return digits; &#125; &#125;; 很明显，改进后的代码相对更简洁一些，同时不再受限于整型溢出导致的错误结果。 前面的代码思路比较简单，也更切合我们日常生活中整数简单+1的操作；事实上改进后的代码思路也并不是很复杂，相对于前面的方法不是那么的抽象，逻辑上略微复杂一点点，因为要把+1的操作作用到单个数字上，要考虑进位的处理（也就是9+1=10的情况下，应该是当前位置0，进位导致前一位要+1）。 不管怎么说，应该可以说后者在各方面都是要优于前者的。","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"Leetcode 两个数组的交集 II","date":"2019-01-24","updated":"2022-03-23","path":"2019012413367/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/26/ 一、题目给定两个数组，编写一个函数来计算它们的交集。 示例 1: 输入: nums1 = [1,2,2,1], nums2 = [2,2] 输出: [2,2] 示例 2: 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出: [4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。 我们可以不考虑输出结果的顺序。 进阶: 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 二、我的解决方案：算法： class Solution &#123; public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; inter; //保存交集的数组 for (int i = 0; i &lt; nums1.size(); i++) &#123; //任选一个数组作为外层循环，选小的数组较好 int q = 0; //用于统计交集中有多少个与当前nums1[i]相等的数 for (int j = 0; j &lt; inter.size(); j++) &#123; //统计 if (inter[j] == nums1[i]) q++; &#125; //q&gt;=1表明交集中已存在q个与nums1[i]相等的数 //q==0表明交集中不存在与nums1[i]相等的数 for (int k = 0; k &lt; nums2.size(); k++) &#123; //在nums2中查找与nums1[i]相等的数 //表明nums1[i]与nums2[k]是一对新相等的数，要插入到inter数组中 if (q == 0 &amp;&amp; nums2[k] == nums1[i]) &#123; inter.insert(inter.end(), nums1[i]); //一旦插入一个新的相交的元素就跳出循环 //否则如果nums2中后序还有相等的数就会多次插入，逻辑错误 break; &#125; //相当于从第q个与nums1[i]相等的数的后开始找新的与nums1[i]相等的数 else if (nums2[k] == nums1[i]) q--; &#125; &#125; return inter; &#125; &#125;; 进阶思路： 如果是已经排好序的两个数组，可以不用每次都从头开始查找，每一次查找的时候记录下当前的位置，这个位置之前的已经不可能存在交集了也就不用再查找一次了 如果 nums1 的大小比 nums2 小很多，可以把nums1作为外层循环 对内存的分配还不太清楚","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"YAML语法简记","date":"2019-01-23","updated":"2022-03-23","path":"2019012330553/","text":"YAML Ain’t Markup Language 基本语法规则 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 #表示注释，从这个字符一直到行尾，都会被解析器忽略 基本语法YAML uses three dashes (“—”) to separate directives from document content. This also serves to signal the start of a document. if no directives are present. Three dots ( “…”) indicate the end of a document without starting a new one, for use in communication channels. YAML以（“—”）表示文章的开始，以（“…”）表示结束（不代表新的文章的开始）。 Structure通过空格来展示。Sequence里的项用”-“来代表，Map里的键值对用”:”分隔。 一般YAML文件扩展名为.yaml。比如：John.yaml name: John Smith age: 37 spouse: name: Jane Smith age: 25 children: - name: Jimmy Smith age: 15 - name: Jenny Smith age: 12 John Smith今年37岁，有一个幸福的四口之家。两个孩子Jimmy 和Jenny活泼可爱。妻子Jane年轻美貌。 可见YAML的可读性是不错。 列表中的所有成员都开始于相同的缩进级别, 并且使用一个 &quot;- &quot; 作为开头(一个横杠和一个空格): --- # 一个美味水果的列表 - Apple - Orange - Strawberry - Mango 一个字典是由一个简单的 键: 值 的形式组成(这个冒号后面必须是一个空格)： --- # 一位职工的记录 name: Example Developer job: Developer skill: Elite 字典也可以使用缩进形式来表示, 如果你喜欢这样的话： --- # 一位职工的记录 &#123;name: Example Developer, job: Developer, skill: Elite&#125; 可以通过以下格式来指定一个布尔值(true/fase)： --- create_key: yes needs_agent: no knows_oop: True likes_emacs: TRUE uses_cvs: false 综合以上信息： --- # 一位职工记录 name: Example Developer job: Developer skill: Elite employed: True foods: - Apple #缩进只能用空格不能用Tab - Orange - Strawberry - Mango languages: ruby: Elite python: Elite dotnet: Lame 尽管 YAML 通常是友好的, 但是下面将会导致一个 YAML 语法错误: foo: somebody said I should put a colon here: so I did 你需要使用引号来包裹任何包含冒号的哈希值, 像这样: foo: &quot;somebody said I should put a colon here: so I did&quot; 然后这个冒号将会被结尾. 此外, Ansible 使用 “” 来引用变量. 如果一个值以 “{” 开头, YAML 将认为它是一个字典, 所以我们必须引用它, 像这样: foo: &quot;&#123;&#123; variable &#125;&#125;&quot; 三种数据结构 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 1. 对象对象的一组键值对，使用冒号结构表示 animal: pets Yaml 也允许另一种写法，将所有键值对写成一个行内对象 hash: &#123; name: Steve, foo: bar &#125; 2.数组一组连词线开头的行，构成一个数组 - Cat - Dog - Goldfish 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 - - Cat - Dog - Goldfish 数组也可以采用行内表示法。 animal: [Cat, Dog] 3. 复合结构对象和数组可以结合使用，形成复合结构。 languages: #数组 - Ruby - Perl - Python websites: #对象 YAML: yaml.org Ruby: ruby-lang.org Python: python.org Perl: use.perl.org 4. 纯量纯量是最基本的、不可再分的值。 字符串 布尔值 整数 浮点数 Null 时间 日期 数值直接以字面量的形式表示。 number: 12.30 { number: 12.30 } 布尔值用true和false表示。 isSet: true null用~表示。 parent: ~ 时间采用 ISO8601 格式。 iso8601: 2001-12-14t21:59:43.10-05:00 日期采用复合 iso8601 格式的年、月、日表示。 date: 1976-07-31 YAML 允许使用两个感叹号，强制转换数据类型。 e: !!str 123 f: !!str true 5. 字符串字符串是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 str: 这是一行字符串 如果字符串之中包含空格或特殊字符，需要放在引号之中。 str: &#x27;内容：字符串&#x27; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 s1: &#x27;内容\\n字符串&#x27; s2: &quot;内容\\n字符串&quot; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 str: &#x27;labor&#x27;&#x27;s day&#x27; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 str: 这是一段 多行 字符串 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 this: | Foo Bar that: &gt; Foo Bar +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 s1: | Foo s2: |+ Foo s3: |- Foo 字符串之中可以插入 HTML 标记。 message: | &lt;p style=&quot;color: red&quot;&gt; 段落 &lt;/p&gt; 6. 引用锚点&amp;和别名*，可以用来引用。 &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 defaults: &amp;defaults #建立锚点&amp;defaults adapter: postgres host: localhost development: database: myapp_development &lt;&lt;: *defaults #引用锚点 test: database: myapp_test &lt;&lt;: *defaults #引用锚点 等同于下面的代码。 defaults: adapter: postgres host: localhost development: database: myapp_development adapter: postgres host: localhost test: database: myapp_test adapter: postgres host: localhost 下面是另一个例子。 &amp;showell Steve #建立showell锚点 Clark Brian Oren *showell #引用锚点showell，即Steve","categories":[],"tags":[{"name":"YAML","slug":"YAML","permalink":"https://mxy493.xyz/tags/YAML/"}]},{"title":"Leetcode 只出现一次的数字","date":"2019-01-22","updated":"2022-03-23","path":"2019012229459/","text":"地址：https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/1/array/25/ 题目： 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 我的解决方案： class Solution &#123; public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; //如果数组为空显然不存在题述两种情况 if (nums.size() == 0) return 0; //如果数组只有一个元素，则直接返回这个元素 else if (nums.size() == 1) return nums[0]; //如果上述两种情况都不满足 for (int i = 0; i &lt; nums.size(); i++) &#123; bool bl = false; for (int j = 0; j &lt; nums.size(); j++) &#123; //如果j==i，显然nums[j]==nums[i]，直接跳过这种情况 if (j == i) continue; //如果j!=i并且nums[j]==nums[i]，说明这个元素出现了不止一次 else if (nums[j] == nums[i]) break; //如果i已经取到了最后一个元素，前面第一个if排除了j==i的情况 //所以这里当j取到倒数第二个元素就判断结束 else if (i == nums.size() - 1 &amp;&amp; j == nums.size() - 2) bl = true; //如果j取到最后一个元素都没有找到与nums[i]相同的元素，则元素nums[i]只出现了一次 else if (j == nums.size() - 1) bl = true; &#125; if (bl == true) return nums[i]; &#125; return 0; &#125; &#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/categories/Leetcode/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://mxy493.xyz/tags/Leetcode/"},{"name":"数组","slug":"数组","permalink":"https://mxy493.xyz/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"GitHub+Hexo搭建博客笔记","date":"2019-01-18","updated":"2022-03-23","path":"2019011817415/","text":"写在前面一直想搭建一个个人博客主要是为了学习吧，我可以不写博客但是我得会搭建博客，会搭博客了我写不写是我的事，哈哈。。。 这是我的博客主页：https://mxy493.github.io/ 采用GitHub+Hexo搭建博客的原因很简单，百度的，很多大佬推荐，要么就是WordPress，大概WordPress要付费的吧，不太清楚，总之GitHub+Hexo的方案目前一分钱没花，应该也是不需要花钱的，都是开源项目。 基本上都是参照网上的教程一步一步傻瓜式操作来的，可以说不需要什么专业知识，顺手写下这篇文章做测试吧。 Hexo介绍Hexo官网有比较清楚的介绍，最好看看官网的文档，写的可以说是很详细很清晰了，可以先不懂，看完基本上就知道是怎么回事了，然后再来一步步操作。 正文环境：Windows系统（我的是Windows 10专业版） 需要安装的软件：Git（不是GitHub），Node.js，Hexo（npm安装） Git安装下载并安装Git（安装不需要设置什么，默认就可以） Git主要用于版本控制，很多操作都需要在Git Bash上进行，Git不懂可以自己学习一下，主要学学命令就行吧，网上很多教程。 Node.js安装关于Node.js的一些介绍可以稍微看一下这篇文章–NodeJS简介，在本教程中NodeJS主要用于管理下载第三方包，例如hexo，而这些工作都是npm在负责的。 1.下载并安装Node.js 官网首页就有醒目的下载按钮，下载好后自选位置（尽量自己记着安装在哪儿）安装就行。 安装后输入Win+R输入cmd打开控制台输入以下代码： node -v npm -v 如果安装没有问题的话，会返回安装的版本号。 Hexo安装为了避免出现错误后面的操作都在Git Bash进行。 首先新建一个存放Hexo文件的目录，自己找个位置就行，然后cd到该目录下，或者直接在该目录下鼠标右键点Git Bash Here就可以，开始安装 $ cd D:/mxy/Documents/Hexo #换成自己新建的的目录，斜杠不能反了，是&#x27;/&#x27;，&#x27;\\&#x27;这样不行 $ npm install hexo-cli -g #安装hexo脚手架，没啥说的，官网给的安装命令 $ hexo init #Hexo自动在当前文件夹下下载搭建网站所需的所有文件 $ npm install #安装依赖包 $ hexo clean #清理缓存 $ hexo g #完整命令为hexo generate，生成静态文件 $ hexo s #完整命令为hexo server，启动服务器，用来本地预览 用浏览器访问 http://localhost:4000/ ，人生第一个博客就生成好了，巨简单，这是Hexo自动生成的博客，现在是本地浏览的，并没有发布到网上，使用了默认主题landscape，可以根据个人喜好更换主题，官网提供了很多可以使用的主题。 通过Github部署到网上本地博客搭建好了接下来是要把它部署到网上，通过GitHub部署，也可以使用Coding，都差不多。 没有GitHub账号的话现在就需要注册一个了，名字别太花哨吧，记着自己注册用的邮箱账号。 Github Page： 浏览器打开GitHub主页，右上角“+”新建仓库New repository， Repository name：mxy493.github.io 填入自己的仓库名称，自己用户名.github.io，最后自己的博客地址就是：https://自己的用户名.github.io/ 配置SSHGit Bash中输入命令：邮件地址为注册GitHub时的邮箱 $ ssh-keygen -t rsa -C &quot;你的邮件地址&quot; 回车回车回车，会提示输入密码，输入即可（输入密码是看不到的），也可以不用输入，然后会确认输入一次，就可以在刚刚的路径看到生成了两个文件，一个是id_rsa，另一个是id_rsa.pub，用VS code或者别的软件打开id_rsa.pub然后选中里面的全部内容，复制下来。 打开GitHub，右上角点击自己的头像，选择settings，左侧选择SSH and GPG keys，然后New SSH key，Title随意把复制的内容粘贴到下面的Key的框里面，最后点击Add SSH key完事。 发布打开D:\\mxy\\Documents\\Hexo\\mxy，用VS code（或者别的可以编辑的软件都可以）打开_config.yml文件，文件最后可以看到 deploy: type: 修改（注意要换上自己的链接） deploy: type: git repository: git@github.com:mxy493/mxy493.github.io.git #这里换成自己的地址 branch: master 不清楚自己的地址可以到GitHub上面看，右上角头像-&gt;Your Rrepositories，找到自己建的代码仓库打开 修改完成保存！ 继续在Git Bash中输入以下命令： $ hexo d #完整命令为hexo deploy，将本地文件发布到page服务平台上 如果遇到异常： $ hexo clean &amp;&amp; hexo g $ hexo d 如果出现以下异常 ERROR Deployer not found: git 尝试输入以下命令，然后重新执行刚刚的两条命令 $ npm install hexo-deployer-git --save 这时候如果弹出一个对话框，输入在GitHub上面的用户名和密码即可 现在，博客就已经发布到网上了，可以通过地址https://自己的用户名.github.io/访问","categories":[{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mxy493.xyz/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"https://mxy493.xyz/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"GitHub","slug":"GitHub","permalink":"https://mxy493.xyz/tags/GitHub/"}]},{"title":"Hello World","date":"2019-01-17","updated":"2022-03-23","path":"2019011716107/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"mxy测试","date":"2019-01-17","updated":"2019-02-01","path":"2019011717555/","text":"Have a nice day","categories":[],"tags":[]}]